\documentclass[a4,natbib=false]{article}
\usepackage{fullpage}
\usepackage{amssymb}
\usepackage{amsmath,amsfonts,amsthm}
\usepackage[dvipsnames]{xcolor}
\usepackage{mathpartir}
\usepackage{cleveref}
\usepackage{multicol}
\usepackage{quiver}
\usepackage{wrapfig}
\usepackage{esvect}
\usepackage[inline, shortlabels]{enumitem}
\usepackage{array}
\usepackage{ulem}
\usepackage{cancel}
\usepackage{soul}

\usepackage[colorinlistoftodos]{todonotes} 

\setlength{\columnsep}{1cm}
\let\citename\relax
\usepackage[natbib=true, abbreviate=false, dateabbrev=true, isbn=true, doi=false, urldate=comp, url=true, maxbibnames=9, maxcitenames=2, backref=false, backend=biber, style=alphabetic, language=american]{biblatex}
\addbibresource{biblio.bib}

\newcounter{daggerfootnote}
\newcommand*{\daggerfootnote}[1]{%
  \setcounter{daggerfootnote}{\value{footnote}}%
  \renewcommand*{\thefootnote}{\fnsymbol{footnote}}%
  \footnote[2]{#1}%
  \setcounter{footnote}{\value{daggerfootnote}}%
  \renewcommand*{\thefootnote}{\arabic{footnote}}%
}


\newtheorem{lemma}{Lemma}
\newtheorem{definition}{Definition}
\newtheorem{notation}{Notation}
\newtheorem{corollary}{Corollary}
\newtheorem{proposition}{Proposition}

%% \newcommand{\ilyam}[2][]{\todo[linecolor=red,backgroundcolor=red!25,bordercolor=red,#1]{I: #2}}
\newcommand{\ilya}[2][]{\todo[linecolor=red,backgroundcolor=red!25,bordercolor=red,inline,#1]{Ilya: #2}}
\newcommand{\ilyam}[1]{{\color{red} \texttt{Ilya:  #1}}}

%%
\newcommand{\bnfalt}{\;\;|\;\;}


% Now we give some commands to define the syntax of the language. 

\newcommand{\fun}[2]{\lambda {#1}.\,{#2}}


\newcommand{\letname}{\mathsf{let}}
\newcommand{\dletname}{\mathsf{dlet}}

\newcommand{\letval}[3]{\letname\; {#1} \,:=\, {#2} \;\mathsf{in}\; {#3}}
\newcommand{\dletval}[3]{\dletname\; {#1} \,:=\, {#2} \;\mathsf{in}\; {#3}}

\newcommand{\pair}[2]{\left\langle{#1}, {#2}\right\rangle}
\newcommand{\fst}[1]{\mathsf{fst}\,{#1}}
\newcommand{\snd}[1]{\mathsf{snd}\,{#1}}

\newcommand{\unit}{\langle\rangle}
\newcommand{\unittype}{\mathsf{1}}

\newcommand{\ctov}{\mathcal{U}}
\newcommand{\vtoc}{\mathcal{F}}

\newcommand{\unival}{\square^{v}}
\newcommand{\unicomp}{\square^{c}}

\newcommand{\vtype}{\mathsf{vtype}}
\newcommand{\ctype}{\mathsf{ctype}}

\newcommand{\comptoval}[1]{\downarrow \hspace{-2pt} #1}
\newcommand{\valtocomp}[1]{\uparrow \hspace{-2pt} #1}
\newcommand{\sigmatype}[2]{\Sigma {#1}.\,#2}
\newcommand{\pitype}[2]{\Pi {#1}.\,#2}
\newcommand{\foralltype}[2]{\forall {#1}.\,#2}
\newcommand{\eqtype}[3]{\mathsf{eq}{#1}\,{#2}\,{#3}}
\newcommand{\refl}[1]{\mathsf{refl}_{#1}}
\newcommand{\force}[1]{\mathsf{force}\,{#1}}
\newcommand{\return}[1]{\mathsf{return}\,{#1}}
\newcommand{\thunk}[1]{\{{#1}\}}

\newcommand{\recsigmaname}{\mathsf{rec}_{\Sigma}}
\newcommand{\recsigma}[3]{\recsigmaname^{#2}({#1},{#3})}
\newcommand{\receqname}{\mathsf{rec}_{\mathsf{eq}}}
\newcommand{\receq}[3]{\receqname^{#2}({#1},{#3})}

\newcommand{\subst}[3]{{#1}\{{#2}\,:=\,{#3}\}}
\newcommand{\rename}[3]{{#1}\{{#2}\rightsquigarrow{#3}\}}

\newcommand{\subt}{\leqslant}
\newcommand{\vsubt}{\leqslant^v}
\newcommand{\csubt}{\leqslant^c}

\newcommand{\isvtype}[1]{{#1} \, \mathsf{vtype}}
\newcommand{\isctype}[1]{{#1} \, \mathsf{ctype}}

\newcommand{\ctxtapp}[2]{[{#1}] {#2}}
\newcommand{\evarassign}[2]{({#1} \mathsf{:=} {#2})}
\newcommand{\spcdot}{\mkern 2mu\cdot\mkern 2mu}
\newcommand{\emptyctx}{\spcdot}
\newcommand{\mapentry}[2]{{#1} \mapsto {#2}}

\newcommand{\fventry}[2]{{#1}^{#2}}

\newcommand{\reduces}[2]{{#1} \rightarrow {#2}}
\newcommand{\contracts}[2]{{#1} \rightharpoonup {#2}}
\newcommand{\bigstepsto}[2]{{#1} \Downarrow {#2}}
\newcommand{\nf}[1]{\Downarrow \hspace{-2pt} {#1}}

\newcommand{\nattype}{\mathbb{N}}
\newcommand{\natzero}{\mathsf{0}}
\newcommand{\natsucc}[1]{\mathsf{succ}({#1})}
\newcommand{\recnat}[4]{\mathsf{rec}_{\nattype}^{#2}({#1},{#3},{#4})}

\newcommand{\narg}[1]{|{#1}|}
\newcommand{\arity}[1]{\mathsf{ar}{#1}}


% This is a command to define a judgement -- we'll one command per judgement
% for delta-CBPV

\newcommand{\judge}[3]{{#1} \vdash {#2} : {#3}}
\newcommand{\judgectx}[2]{{#1} \vdash {#2}}
\newcommand{\judgesafeinenv}[2]{{#1}  \vdash {#2}}
\newcommand{\judgesafeinenvv}[3]{{#1}[{#2}]  \vdash {#3}}


\newcommand{\checks}{{\color{blue} \Leftarrow}}
\newcommand{\infers}{{\color{brown} \Rightarrow}}

\newcommand{\judgec}[3]{{#1} \vdash_{c} {#2} : {#3}}
\newcommand{\judgecCheck}[3]{{#1} \vdash_{c} {#2} \, \checks \,  {#3}}
\newcommand{\judgecInfer}[3]{{#1} \vdash_{c} {#2} \, \infers \, {#3}}

\newcommand{\judgev}[3]{{#1} \vdash_{v} {#2} : {#3}}
\newcommand{\judgevCheck}[3]{{#1} \vdash_{v} {#2} \, \checks \, {#3}}
\newcommand{\judgevInfer}[3]{{#1} \vdash_{v} {#2} \, \infers \, {#3}}

\newcommand{\judgeInctx}[2]{{#1} \in {#2}}

\newcommand{\judgevtype}[2]{{#1} \vdash \isvtype{#2}}
\newcommand{\judgectype}[2]{{#1} \vdash \isctype{#2}}


\newcommand{\judgevsubt}[3]{{#1} \vdash {#2} \vsubt {#3}}
\newcommand{\judgecsubt}[3]{{#1} \vdash {#2} \csubt {#3}}

\newcommand{\judgeApp}[4]{{#1} \vdash {#2} \, {\color{OliveGreen} \bullet} \,
  {#3} \,
  {\color{OliveGreen} \Rightarrow \hspace{-5pt} \Rightarrow} {#4}}

% Fully algorithmic rules

\newcommand{\judgecCheckAlg}[4]{{#1} \vdash_{c} {#2} \, \checks \,  {#3} \dashv\,{#4}}
\newcommand{\judgecInferAlg}[4]{{#1} \vdash_{c} {#2} \, \infers \, {#3} \dashv\,{#4}}

\newcommand{\judgevCheckAlg}[4]{{#1} \vdash_{v} {#2} \, \checks \, {#3} \dashv\,{#4}}
\newcommand{\judgevInferAlg}[4]{{#1} \vdash_{v} {#2} \, \infers \, {#3} \dashv\,{#4}}

\newcommand{\judgeAppAlg}[5]{{#1} \vdash {#2} \, {\color{OliveGreen} \bullet} \,
  {#3} \,
  {\color{OliveGreen} \Rightarrow \hspace{-5pt} \Rightarrow} {#4} \dashv\,{#5}}

\newcommand{\judgevtypeAlg}[3]{{#1} \vdash \isvtype{#2} \dashv \,{#3}}
\newcommand{\judgectypeAlg}[3]{{#1} \vdash \isctype{#2} \dashv \,{#3}}




\newcommand{\judgeequiv}[4]{{#1} \vdash {#2} \equiv {#3} : {#4}}
\newcommand{\judgeequivunt}[2]{{#1} \equiv {#2}}
\newcommand{\judgeequivuntg}[3]{{#1} \vdash {#2} \equiv {#3}}

\newcommand{\judgealpha}[2]{{#1} \sim_{\alpha} {#2}}

\newcommand{\judgeavsubt}[4]{{#1}\,{\color{purple}\vdash} {#2} \vsubt {#3} {\color{purple}\dashv}\,{#4}}
\newcommand{\judgeacsubt}[4]{{#1}\,{\color{purple}\vdash} {#2} \csubt {#3} {\color{purple}\dashv}\,{#4}}

\newcommand{\judgeunify}[4]{{#1}\,{\color{purple}\vdash} {#2} \equiv {#3} {\color{purple}\dashv}\,{#4}}

\newcommand{\judgeSnf}[1]{{#1}\,\mathsf{NF}}
\newcommand{\judgeSatom}[1]{{#1}\,\mathsf{ATOM}}
\newcommand{\judgeSinert}[1]{{#1}\,\mathsf{INERT}}
\newcommand{\judgeSok}[2]{{#1} \in^{?} {#2}\,\mathsf{OK}}
\newcommand{\judgeSOK}[2]{{#1} \in^{!} {#2}\,\mathsf{OK}}
\newcommand{\judgeSokterm}[1]{{#1} \,\mathsf{OK}}

\newcommand{\judgeinst}[2]{{#1} \vdash {#2}}

\newcommand{\ctxtexdends}[2]{{#1} \subseteq {#2}}


\newcommand{\fv}[1]{\mathsf{FV}(#1)}
\newcommand{\evok}[1]{\mathsf{EV}^{\mathsf{OK}}(#1)}
\newcommand{\ev}[1]{\mathsf{EV}(#1)}
\newcommand{\trace}[1]{\mathsf{tr}({#1})}
\newcommand{\tracecont}[2]{\mathsf{tr}({#1}, {#2})}
\newcommand{\codom}[1]{\mathsf{im}(#1)}
\newcommand{\background}[2]{\mathsf{bg}({#1}, {#2})}

\newcommand{\absclose}[2]{\vv{x}^{#1} #2}

\newcommand{\vars}[1]{\mathsf{vars}(#1)}


\newcommand{\fullterm}[2]{{#1}\,#2_1 \dots #2_{\narg{#1}}}
\newcommand{\fulltermm}[2]{{#1}\,(\absclose{\arity{#1}_1}{#2_1}) \dots (\absclose{\arity{#1}_{\narg{#1}}}{#2_{\narg{#1}})}}
\newcommand{\fulltermmm}[1]{{#1}\,P^{\arity{#1}} \dots P^{\arity{#1}_{\narg{#1}}}}

% This is a command to define an inference rule. The optional argument to
% \inferrule* is the label for the rule. 
% 
\newcommand{\Infer}[3]{\inferrule*[right={#1}]{#2}{#3}}

\newcommand\declareop[3]{%
  \newcommand#1{%
    \mskip\muexpr\medmuskip*#2\relax
    {#3}%
    \mskip\muexpr\medmuskip*#2\relax
  }}

\declareop\inc{3}{\mathrel{+}=}

\newcolumntype{L}{>{$}l<{$}} % math-mode version of "l" column type
\newcommand{\mathcolorbox}[2]{\colorbox{#1}{$\displaystyle #2$}}

\begin{document}
\section{Syntax}
\begin{definition}[Syntax of terms]
  \label{def:syntax}

  We write \emph{term} meaning a computation or a value, denoting it $\sigma$ or $\tau$.

\begin{mathpar}
  \begin{array}{llcl}
    \mbox{Computations} & X, Y, t, u & ::= & t v \bnfalt
    \valtocomp{A} \bnfalt \pitype{x:A}{X} \bnfalt \foralltype{x:A}{X} \bnfalt \force {v} \bnfalt \return{v}
    \bnfalt \fun{x:A}{t} \bnfalt \\ & & & \letval{x : A}{t}{u} \bnfalt
    \dletval{x : A}{t}{u} \bnfalt \recsigma{v}{x.X}{t} \bnfalt \receq{v}{x.y.X}{t}
    \\[1em]

    \mbox{Values} & A, B, v, w & ::= & x \bnfalt a \bnfalt \comptoval{X}
    \bnfalt \sigmatype{x:A}{B} \bnfalt \refl{v} \bnfalt \eqtype{A}{v}{w} \bnfalt
    \thunk{t} \bnfalt \pair{v}{w} \\[1em]

    % \mbox{Contexts} & \Gamma & ::= & \emptyctx \bnfalt \Gamma, x:A \bnfalt \Gamma, \isvtype{B} \\[1em]
  \end{array}
\end{mathpar}

\end{definition}

We use different non-terminal symbols to emphasize the distinction between type-level terms
and term-level terms, which manifests properly in \cref{sec:rules}.
The upper-case literals represent type-terms, and the lower-case
represent term-terms (which can be typed with some type-terms)
with one exception: in $\letval{x : A}{t}{u}$,
$u$ can represent a type-term.

We reserve $x$ and $y$ to denote term-level variables, and $a$ and $b$ to denote
type-level variables.

\section{Computational form of the terms}

Let us consider the term syntax from a different perspective:

\begin{definition}[Computational syntax of terms]
  \label{def:comp-syntax}


\begin{mathpar}
  \begin{array}{llcl}
    \mbox{Constructors} & C & ::= & \lambda \bnfalt (,) \bnfalt \refl{} \bnfalt \return{} \bnfalt \thunk{} 
    \\[1em]
    \mbox{Eliminators} & E & ::= & @ \bnfalt \recsigma{}{}{} \bnfalt \receq{}{}{}
                                   \bnfalt \letname \bnfalt \dletname
                                   \bnfalt \force{}
    \\[1em]

    \mbox{Neutral Formers} & N & ::= & \comptoval \bnfalt \Pi \bnfalt \forall \bnfalt
                                       \valtocomp{} \bnfalt \Sigma \bnfalt x
    \\[1em]

    \mbox{Formers} & F & ::= & C \bnfalt E \bnfalt N
    \\[1em]

    \mbox{Abstractor Heads} & \vv{x}^0 & ::= & .\\
                        & \vv{x}^{n + 1} & ::= & x\,.\, \vv{x}^n \\
                       & \vv{x}          & ::= & \vv{x}^0 \bnfalt \vv{x}^1
                                                 \bnfalt \dots
    \\[1em]

    \mbox{Abstractors} & P^n, Q^n & ::= & \vv{x}^n \tau\\
                       & P, Q    &  ::= & P^1 \bnfalt P^2 \bnfalt \dots
    \\[1em]

    % \mbox{Terms} & \sigma, \tau, \nu & ::= & \fullterm{F}{\tau}
    \mbox{Terms} & \sigma, \tau, \nu & ::= & \fulltermm{F}{\tau}
  \end{array}
\end{mathpar}

\end{definition}

\begin{definition} [Arity]
  For every term former $F$ we define its arity $\arity{F}$ as the array of integers desctibing its
  arguments. Integer denotes the number of new binding variables ``created'' by
  $F$ that can be used in the corresponding subterm. For brevity, we denote
  length of $\arity{F}$ as $\narg{F}$.
   
  \begin{table}[h]
    \setlength\tabcolsep{5pt}
    \begin{tabular}{L|LLLLLLLLLLLLLLLLL}
      F         & \lambda & (,)   & \refl{} & \return{} & \thunk{} & @     & \recsigmaname & \receqname & \letname & \dletname & \force{} & \comptoval & \Pi   & \forall & \valtocomp{} & \Sigma & x  \\
      \hline
      \arity{F} & [0, 1]  & [0,0] & []    & [0]       & [0]      & [0,0] & [0,1,0]         & [0,2,0]       & [0,1,0]  & [0,1,0]   & [0]      & [0]        & [0,1] & [0,1]   & [0]          & [0,1]  & [] \\
      \narg{F}  & 2       & 2     & 0     & 1         & 1        & 2     & 3               & 3             & 3        & 3         & 1        & 1          & 2     & 2       & 1            & 2      & 0 
    \end{tabular}
  \end{table}

\end{definition}

\ilyam{Notice that we rearrange the arguments in $\lambda$ and let-bindings so
  that any redex is always an eliminator whose \emph{first} argument is a constructor}

It is easy to see that the syntax of \emph{terms} from \cref{def:syntax} defines
the \emph{subset} of terms defined by \cref{def:comp-syntax}. In fact, any
\emph{well-typed} term must have a form defined by \cref{def:syntax}. We will
use these two representation interchangeably.

\section{Alpha-equivalence}

\begin{definition}[Variable Renaming]
  \begin{mathpar}
    \Infer{}{ }{\rename{x}{x}{z} = z} \and
    \Infer{}{x \neq y}{\rename{x}{y}{z} = x} \and
    \Infer{}{F \neq x}{\rename{\fullterm{F}{P}}{y}{z} = F\, (\rename{P_1}{y}{z}) \dots (\rename{P_{\narg{F}}}{y}{z})} \and
    \Infer{}{ }{\rename{.\tau}{y}{z} = .(\rename{\tau}{y}{z})} \and
    \Infer{}{x' \text{ is fresh} }{\rename{x.P}{y}{z} = x'.(\rename{(\rename{P}{x}{x'})}{y}{z})}
  \end{mathpar}
\end{definition}

\begin{definition}[Alpha-equivalence]
  \begin{mathpar}
    \Infer{}
    {\forall i, \judgealpha{P_i}{Q_i}}
    {\judgealpha{\fullterm{F}{P}}{\fullterm{F}{Q}}}
    \and
    \Infer{}
    {\judgealpha{\sigma}{\tau}}
    {\judgealpha{.\sigma}{.\tau}}
    \and
    \Infer{}
    { y \text{ is fresh}\\
      \judgealpha{\rename{\sigma}{x}{y}}{\rename{\tau}{x}{y}}}
    {\judgealpha{x.\sigma}{x.\tau}}
    \and
  \end{mathpar}

\end{definition}

\begin{lemma}
  Alpha-equivalence is an equivalence relation on terms and abstractors.
\end{lemma}
\ilyam{Admitted.}

\begin{lemma}[Functionality of Variable Renaming]
  Variable Renaming is a functional on the classes of alpha-equivalence.
\end{lemma}
\ilyam{Admitted.}

Hereafter, we assume every statement about terms and abstractors defined on the
equivalence classes. Whenever we use the ``concrete term syntax'', we mean the
alpha-equivalence class of this term if the term is in the covariant position of
the statement or definition (e.g. we are constructing a function returning an
equivalence class as an output); and \emph{any term of this form from this
  class} if the term is in the contravariant position (e.g. we are constructing
a function taking an equivalence class as an input).


\section{Susbtititution}
\begin{definition}[Substitution]
  \ilyam{todo}
\end{definition}

\begin{lemma}[Functionality of Substituion]
  Substitution is a functional on the classes of alpha-equivalence.
\end{lemma}
\ilyam{Admitted.}


\section{Reduction}

First, we define the \emph{redex contraction}.
\begin{definition}[Redex Contraction]
  \label{def:redex-contr}
  We define the top-level redex contraction in the following way:
  \begin{multicols}{2}
    \begin{itemize}

    \item $\contracts{(\fun{x:\nu}{\sigma})\tau}{\subst{\sigma}{x}{\tau}}$
      
    \item $\contracts{\letval{x:\nu}{\return{\sigma}}{\tau}}{\subst{\tau}{x}{\sigma}}$

    \item $\contracts{\dletval{x:\nu}{\return{\sigma}}{\tau}}{\subst{\tau}{x}{\sigma}}$

    \item $\contracts{\force{\thunk{\tau}}}{\tau}$

    \item $\contracts{\recsigma{\pair{\tau_1}{\tau_2}}{\nu}{\sigma}}{\sigma \,
        \tau_1 \, \tau_2}$

    \item $\contracts{\receq{\refl{v}}{\nu}{\tau}}{\tau}$

    \end{itemize}
  \end{multicols}

  The terms on the left hand side of $\contracts{\spcdot}{\spcdot}$ are called \emph{redexes}.
  
\end{definition}

Notice that any redex from \cref{def:redex-contr} is an elimination of a
constructor, i.e. a term of the form $E\,(\fullterm{C}{P})\, Q_2 \dots
Q_{\narg{E}}$ where $E$ and $C$ are ``matched''.
Vice versa, if a term of the form
$E\,(\fullterm{C}{P})\, Q_2 \dots Q_{\narg{E}}$ is
\emph{well-typed}, it is a redex. 


Informally, reduction of a term $\tau$ is a redex contraction happening in some
\emph{subterm} of $\tau$.

\begin{definition}[Reduction]
  \begin{mathpar}
    \Infer{Redex}{\contracts{\tau}{\tau'}}{\reduces{\tau}{\tau'}}
    \and
    \Infer{Cong$^F_i$}{\reduces{\tau}{\tau'}}
    {\reduces
      {F\,P_1\dots (\absclose{\arity{F}_i}{\tau}) \dots P_{\narg{F}}}
      {F\,P_1\dots (\absclose{\arity{F}_i}{\tau'}) \dots P_{\narg{F}}}}
  \end{mathpar}

\end{definition}

\begin{lemma}[Substitution preserves reduction]
  \label{lemma:subst-res}

  \begin{mathpar}
    \Infer{}
    {\reduces{\tau}{\tau'}}
    {\reduces{\subst{\tau}{x}{\sigma}}
      {\subst{\tau'}{x}{\sigma}}}
  \end{mathpar}
\end{lemma}
\begin{proof}
  Induction on $\reduces{\tau}{\tau'}$. Substitution is congruent, therefore,
  the induction goes down to the redexes.

  \begin{itemize}
    \item
  Suppose that
  $\reduces{(\fun{x:\nu}{\sigma})\sigma'}{\subst{\sigma}{x}{\sigma'}}$.
  We need to prove that
  $\reduces{\subst{(\fun{x:\nu}{\sigma})\sigma'}{y}{\tau}}{\subst{\subst{\sigma}{x}{\sigma'}}{y}{\tau}}$.
  We know that $\subst{(\fun{x:\nu}{\sigma})\sigma'}{y}{\tau} =
  (\fun{x:\nu}{\subst{\sigma}{y}{\tau}})(\subst{\sigma'}{y}{\tau})$,
  which reduces to
  $\subst{\subst{\sigma}{y}{\tau}}{x}{\subst{\sigma'}{y}{\tau}}$. But
  $$\subst{\subst{\sigma}{y}{\tau}}{x}{\subst{\sigma'}{y}{\tau}} =
  \subst{\subst{\sigma}{x}{\sigma'}}{y}{\tau},$$
  assuming that $x \notin \fv{\tau}$, which is guaranteed because the
  substitution is capture-avoiding. 

  \item
    The other cases are similar or straightforward
  \end{itemize}
\end{proof}

\section{Normal Form}

Using the syntax from \cref{def:comp-syntax}, it is convenient to express
computational properties of the term, e.g. being in the normal form
($\mathsf{NF}$).

\begin{definition}[Normal Form]
\begin{mathpar}
  \Infer{}{\judgeSatom{\tau}}{\judgeSnf{\tau}}
  \and
  \Infer{}{\judgeSnf{\tau_{1}}~\dots~\judgeSnf{\tau_{\narg{C}}}}{\judgeSnf{\fullterm{C}{\vv{x}\tau}}}
  \and
  \Infer{}{\judgeSnf{\tau_{1}}~\dots~\judgeSnf{\tau_{\narg{N}}}}{\judgeSatom{\fullterm{N}{\vv{x}\tau}}}
  \and
  \Infer{}{\judgeSatom{\tau_1}\\\judgeSnf{\tau_2}~\dots~\judgeSnf{\tau_{\narg{E}}}}{\judgeSatom{\fullterm{E}{\vv{x}\tau}}
  }
\end{mathpar}
\end{definition}

The intuition is that
\begin{enumerate*}
\item[(i)] normal terms are not reducible;
\item[(ii)] atomic terms are not reducible and, in addition, do not cause
  reduction when the eliminators are applied to them.
\end{enumerate*}

Although it is easy to see that the terms in normal form are not reducible,
the opposite is only true for the well-typed terms:

\begin{proposition}[Normal form and irreducibility]
  \label{prop:nf-irred}
  \begin{mathpar}
    \Infer{}{\judgeSnf{\tau}}{\nexists \tau', \reduces{\tau}{\tau'}}
    \and
    \Infer{}{\tau \text{ is well-typed } \\ \nexists \tau', \reduces{\tau}{\tau'}}{\judgeSnf{\tau}}
  \end{mathpar}
\end{proposition}

\begin{definition}[Reduction to the Normal Form]
  \begin{mathpar}
    \Infer{}{\reduces{\tau}{\tau'} \\ \judgeSnf{\tau'}}{\bigstepsto{\tau}{\tau'}}
  \end{mathpar}
\end{definition}

\begin{proposition}[Reduction-Substitution distributivity]
  \label{prop:red-subst-distr}
  $$\nf{(\subst{\sigma}{x}{\nf{v}})} = \nf{(\subst{\sigma}{x}{v})}$$
\end{proposition}

% Hereafter, we assume all the terms are well typed.
% \ilyam{Well-typedness is required for the unification and equivalence to be
%   well-founded (otherwise induction is not possible). TODO: normalization (halting)!}

% \begin{definition}[Syntactic normal form]
%   We say that the term $\tau$ is in the syntactic
%   normal form if and only if it is formed by the following grammar:

%   \begin{mathpar}
%     \begin{array}{llcl}
%       \mbox{Normal Computations} & t_n, X_n & ::= &
%       \fun{x:A_n}{t_n} \bnfalt
%       \return{v_n} \bnfalt
%       t_a
%       \\[1em]

%       \mbox{Atomic Computations} & t_a & ::= &
%                                                \force{v_a} \bnfalt
%       t_a v_n \bnfalt
%       \recsigma{v_a}{X_n}{t_n} \bnfalt
%       \receq{v_a}{X_n}{t_n} \bnfalt \\ &&& 
%       \letval{x : A_n}{t_a}{t_n} \bnfalt
%       \dletval{x : A_n}{t_a}{t_n} \\ &&&
%       \valtocomp{A_n} \bnfalt
%       \pitype{x:A_n}{X_n} \bnfalt
%       \foralltype{x:A_n}{X_n}
%       \\[1em]

%       \mbox{Normal Values} & v_n, A_n & ::= &
%       \pair{v_n}{v_n} \bnfalt
%       \thunk{t_n} \bnfalt
%       \refl \bnfalt
%       v_a
%       \\[1em]

%       \mbox{Atomic Values} & v_a & ::= & x \bnfalt \\ &&& \comptoval{X_n} \bnfalt
%                                          \sigmatype{x:A_n}{A_n} \bnfalt \eqtype{A_n}{v_n}{v_n}
%       \\[1em]

%     \end{array}
%   \end{mathpar}
% \end{definition}


\section{Safe Occurrence}

\ilyam{Hmm.. Discussing the type system before actually introducing it...}

In this section, we describe the basis of the restriction that we put on the type system to
make the type checking and type inference decidable. First, let us motivate why we need to
restrict the type system.

\subsection{The necessity of the restrictions}

We motivate the restrictions that we put on the type system by considering two
well-known undecidable problems: the Inhabitation problem and Hilbert's tenth
problem. We will show that both of them can be reduced to the typing problems in
the unrestricted system.

\paragraph{The Inhabitation}

Let us consider the term $\unit$ checked against type $\foralltype{x : \tau}{\unittype}$.
It is easy to see that the checking succeed if and only if $\tau$ is inhabited.
Thus, to ensure the decidability of the type checking, we require $x$, bound by 
some $\forall$, to occur within the body of that $\forall$. In other words, 
only do we allow $\foralltype{x:\sigma}{\tau}$ to be formed, if
$x \in \fv{\tau}$.

% We want the typing to be preserved under reduction.
% It means that we must ensure that so are the restrictions we put on terms/types.
% The property ``$x \in \fv{\tau}$'' is clearly fails to be the invariant, since reduction
% may reduce the set of free variables. 

% Fortunately, ``$x \in \fv{\tau}$'' becomes an invariant as soon as we restrict
% the positions where $x$ can occur in $\tau$. This positional restriction is
% dictated by another undecidability that we want to avoid.

\paragraph{Hilbert's Tenth Problem}

As will be shown in
\cref{sec:rules,sec:declarative-supbyping,sec:algorithmic-subtyping},
the ``driver'' of the type inference algorithm is the subtyping algorithm, and
the ``driver'' of the subtyping, is the unification. Let us show that in the
unrestricted case, the unification is undecidable.

The type system can be easily extended with natural numbers. To this purpose, we
must add $\nattype$, $\natzero$, and $\natsucc{v}$ to the values, and
$\recnat{v}{X}{base}{step}$ to the computations with obvious typing inference
rules.
We also add $\contracts{\recnat{\natzero}{X}{b}{s}}{b}$ and
$\contracts{\recnat{\natsucc{v}}{X}{b}{s}}{s \, v \, \recnat{v}{X}{b}{s}}$ to the contraction rules.

Then the unification that we will not provide is, for example, the following:
$\recnat{\hat{v}}{X}{\natzero}{\fun{x\,y}{\natzero}} \equiv \natzero$, where
$\hat{v}$ is the unification variable that we must initialize.
Although $\evarassign{\hat{v}}{\natzero}$ solves this unification,
we rule out such cases from our unification algorithm.
This is because having the unification variable on the reducible position
means being able to ``invert'' the recursion, which is too powerful to be decidable.

Specifically, after we defined integers,
arithmetic operations, we can define any arbitrary polynomial 
$P(\hat{x}_1, \dots, \hat{x}_n)$.
The unification of this polynomial with $\natzero$
corresponds to solving a diophantine equation, which is undecidable.

\subsection{The Restriction on Quantifiers}

To deal with both aforementioned undecidabilities, we introduce a syntactic 
judgement ``\emph{safe occurrence of the variable}''. The judgement $\judgeSok{x}{\tau}$ means $x$
occurs safely in $\tau$.

Ideally, we would like to forbid the situations when \emph{in some normal form}
of $\tau$, some instantiation of $x$ generates a new redex. In other words, we
would like to ensure that
\emph{all normal forms} of $\tau$ do not contain $E \, x \, \tau_2 \dots
\tau_{\narg{E}}$ as a subterm.

However, this property is undecidable by Rice's theorem. Notice that
\begin{enumerate*}

\item[(i)] we do not require terms to have types at this stage, thus, the
  system is Turing complete;

\item[(ii)] the property is non-trivial;

\item[(iii)] the property judges about the normal forms and thus, is invariant
  under ``algorithmic equivalence''.
\end{enumerate*}

As it is undecidable, it is impossible to express this judgement using
well-founded inference rules (i.e. unambiguously generating finite trees).
Since precise syntactic representation of this property is impossible, we
under-approximate this property via $\judgeSok{x}{\tau}$ judgement:


\begin{definition}[Safe Occurrence]

\ilyam{TODO: add safe occurrence in abstractors}

\begin{mathpar}
  \Infer{C-Cong}{\judgeSok{x}{\tau_{1}}~\dots~\judgeSok{x}{\tau_{\narg{C}}}}{\judgeSok{x}{\fullterm{C}{\vv{x}\tau}}}
  \and
  \Infer{N-Cong}{\judgeSok{x}{\tau_{1}}~\dots~\judgeSok{x}{\tau_{\narg{N}}}}{\judgeSok{x}{\fullterm{N}{\vv{x}\tau}}}
  \and
  \Infer{E-FV}{x \notin \fv{\fullterm{E}{\tau}}}{\judgeSok{x}{\fullterm{E}{\vv{x}\tau}}}
  \and
  \Infer{E-Cong}
  {\judgeSok{x}{\tau_{1}}~\dots~\judgeSok{x}{\tau_{\narg{E}}}
    \\ 
    \tau_1 \neq x
    \\ 
    \judgeSinert{\fullterm{E}{\vv{x}\tau}}
  }
  {\judgeSok{x}{\fullterm{E}{\vv{x}\tau}}
   \\ \ilyam{(implicit $\alpha$-rename!)}
  }
\end{mathpar}
\end{definition}

In the last rule, ``$\tau_1 \neq x$'' means literal syntactic inequality.
Intuitively, ``$\judgeSinert{\tau}$'' means that $\tau$ preserves its
top-level structure under the reduction, i.e. the reduction always happens in
the subterms of $\tau$ but never on the top level. In fact, the relation we
define is a little bit stronger, as it also forbids changing of the structure 
of the eliminator's first argument. Formally, it is defined as follows:

\begin{definition}[Inert Terms]
\begin{mathpar}
  \Infer{}{ }{\judgeSinert{\fullterm{N}{\vv{x}\tau}}}
  \and
  \Infer{}{ }{\judgeSinert{\fullterm{C}{\tau}}}
  \and
  \Infer{}{ }{\judgeSinert{E\,(\fullterm{N}{\vv{x}\sigma})\,\vv{x}\tau_2 \dots \vv{x}\tau_{\narg{E}}}}
  \and
  \Infer{EE-Inert}
  {\judgeSinert{\fullterm{E'}{\vv{x}\sigma}}}
  {\judgeSinert{E\,(\fullterm{E'}{\vv{x}\sigma})\,\vv{x}\tau_2 \dots \vv{x}\tau_{\narg{E}}}}
\end{mathpar}
\end{definition}

As a heuristics, it is possible to extend the ``Safe Occurrence'' property by
embedding \emph{some} of the redex contractions from \cref{def:redex-contr} into the
inference system. Notice that only non-substituting contractions are allowed.
This is because otherwise, we embed the full evaluation into the inference
system, which makes it non-well-founded (and undecidable).

\begin{definition}[Safe Occurrence Extension]
\label{def:safe-occurrence-extension}
\begin{mathpar}
  \Infer{}
  {\judgeSok{x}{\tau}}
  {\judgeSok{x}{\force{\thunk{\tau}}}}
  \and
  \Infer{}
  {
    \judgeSok{x}{{@\, (@\, \sigma \, \tau_1)\, \tau_2}} \\
    x \notin \tau' \\
  }
  {\judgeSok{x}{
      \recsigma{\pair{\tau_1}{\tau_2}}{\tau'}{\sigma}}
  }
  \and
  \Infer{}
  {
    x \notin \sigma
    % \judgeSok{x}{\sigma} \\
    \judgeSok{x}{\tau} \\
    \judgeSok{x}{v} \\
  }
  {\judgeSok{x}{
      \receq{\refl{v}}{x.y.\sigma}{\tau}}
  }
  \and
  \ilyam{The blue rules are experimental!}
  \and
  {\color{blue}
  \Infer{}
  { x \notin \tau \\
    x \notin \nu \\
    \judgeSok{x}{\sigma} \\
  }
  { \judgeSok{x}{(\fun{y:\nu}{\sigma})\tau} }

  \and

  \Infer{}
  { x \notin \sigma \\
    x \notin \nu \\
    \judgeSok{x}{\tau} \\
  }
  { \judgeSok{x}{\letval{y:\nu}{\return{\sigma}}{\tau}} }

  }
  \and
  {
  \color{blue}
  \Infer{}
  { x \notin \sigma \\
    x \notin \nu \\
    \judgeSok{x}{\tau} \\
  }
  { \judgeSok{x}{\dletval{y:\nu}{\return{\sigma}}{\tau}} }
  }
\end{mathpar}
\end{definition}

% \begin{lemma}[Correctness of the definition]
%   Safe occurrence is defined up to alpha-equivalence. 
% \end{lemma}
% \begin{proof}
% \ilyam{todo}
% \end{proof}

\begin{lemma}[Conguence of the safe occurrence]
  \label{lemma:cong-safe-occurrence}
  \begin{mathpar}
  \Infer{}
  {
    \judgeSok{x}{\fullterm{F}{P}}
    % \ilyam{x is not captured by the abstractors}
  }
  {
    \judgeSok{x}{P_1} \\
    \cdots \\
    \judgeSok{x}{P_{\narg{F}}}
  }
  \end{mathpar}
\end{lemma}
\begin{proof}
  Trivial induction.
\end{proof}


\begin{lemma}[Reduction-Substitution Commutativity]
  \label{lemma:red-subst-commute}
  \begin{mathpar}
    \Infer{}
    {
      \judgeSok{x}{\sigma}\\
      \judgeSnf{\tau}\\
      \reduces{\subst{\sigma}{x}{\tau}}{\sigma'}\\
    }
    {\exists \sigma^* \text{ s.t. } \reduces{\sigma}{\sigma^*} \text{ and } \subst{\sigma^*}{x}{\tau} = \sigma' }
  \end{mathpar}

  Or in the commutative diagram form: 
    if $\judgeSok{x}{\sigma}$ and $\judgeSnf{\tau}$ then
    \begin{tikzcd}
        \sigma & {\sigma^*} \\
        \bullet & {\sigma'}
        \arrow["{{x:=\tau}}"', from=1-1, to=2-1]
        \arrow["\rightarrow"', from=2-1, to=2-2]
        \arrow["\rightarrow", dashed, from=1-1, to=1-2]
        \arrow["{x := \tau}", dashed, from=1-2, to=2-2]
      \end{tikzcd}
\end{lemma}

\begin{proof}
  Let us destruct the substitution $\subst{\sigma}{x}{\tau}$. Notice that
  $\sigma \neq x$ because $\subst{x}{x}{\tau} = \tau \nrightarrow \spcdot$. It
  means that the substitution is performed by congruence: $\sigma =
  \fullterm{F}{\sigma}$ (for some $F \neq x$), and $\subst{\sigma}{x}{\tau} =
  F\, (\subst{\sigma_1}{x}{\tau}) \dots (\subst{\sigma_{\narg{F}}}{x}{\tau}) $.
  Notice that $\judgeSok{x}{\sigma_i}$ for $i = 1 \dots \narg F$ by
  \cref{lemma:cong-safe-occurrence}.

  Induction on $\reduces{\subst{\sigma}{x}{\tau}}{\sigma'}$.
  The reduction step can be justified either by the congruence or the redex contraction.
  \begin{itemize}
  \item If the reduction step is done by congruence, then the required
    $\sigma^*$ is of the form $\fullterm{F}{\sigma^*}$ where $\sigma^*_1 \dots
    \sigma^*_{\narg{F}}$ are constructed by the straightforward application of
    the induction hypothesis to $\sigma_1 \dots \sigma_{\narg{F}}$.

  \item If the reduction is the top-level redex contraction, then
    $\subst{\sigma}{x}{\tau}$ is a redex, i.e. $F$ is an eliminator $E$ and
    $\subst{\sigma_1}{x}{\tau}$ is formed by a constructor $C$.
    Notice that because
    $\judgeSok{x}{\fullterm{E}{\sigma}}$, $\sigma_1
    \neq x$. Therefore, the substitution $\subst{\sigma_1}{x}{\tau}$ is also done by
    congruence: $\sigma_1 = \fullterm{C}{\zeta}$ and thus,
    $\sigma = E \, (\fullterm{C}{\zeta}) \, \sigma_2 \dots \sigma_{\narg{E}}$.

    Let us destruct $\judgeSok{x}{\sigma}$. Since $\sigma$ is not inert, either
    \begin{enumerate*}
      \item[(i)] $x \notin \fv{\sigma}$, then the substitution is the identity, and we
        can take $\sigma^* = \sigma'$); or
      \item[(ii)] one of the ``additional'' rules is applied to get
        $\judgeSok{x}{\sigma}$. In all of these three cases, we can perform the
        same top-level redex contraction to acquire $\sigma^*$. This operation
        commutes with substitution because all it does is restructuring the
        top-level form of $\sigma$ without changing the subterms $\zeta_1,
        \dots, \zeta_{\narg{C}}, \sigma_2, \dots, \sigma_{\narg{E}}$, thus, the
        required property holds.

        \ilyam{to be fair, the beta-reduction also commutes with the
          substitution, but we still need the inertness so that OK is preserved
          under reduction.}
        
    \end{enumerate*}
  \end{itemize}
\end{proof}

\begin{corollary}[Normalization-Substitution Commutativity]
  \label{corollary:nf-subst-commute}
  \begin{mathpar}
    \Infer{}
    {
      \judgeSok{x}{\sigma}\\
      \judgeSnf{\tau}\\
    }
    { \nf{(\subst{\sigma}{x}{\tau})} = \subst{(\nf{\sigma})}{x}{\tau} }
    
    \Infer{}
    {
      \judgeSok{x}{\sigma}\\
    }
    { \nf{(\subst{\sigma}{x}{\tau})} = \subst{(\nf{\sigma})}{x}{\nf{\tau}} }
  \end{mathpar}
\end{corollary}
\begin{proof}
  By replicating \cref{lemma:red-subst-commute}. 
  If $\tau$ is not in the normal form, \cref{prop:red-subst-distr} is applied.
\end{proof}



\begin{lemma}[Reduction preserves inertness]
  \label{lemma:inertness-pres}
  \begin{mathpar}
    \Infer{}{\judgeSinert{\tau} \\ \reduces{\tau}{\tau'}}{\judgeSinert{\tau'}}
  \end{mathpar}
\end{lemma}

\begin{proof}
  Induction on $\judgeSinert{\tau}$.
\end{proof}


\begin{lemma}[Reduction preserves safe occurrence]
  \label{lemma:safe-occur-pres}
  \begin{mathpar}
    \Infer{}{\judgeSok{x}{\tau} \\ \reduces{\tau}{\tau'}}{\judgeSok{x}{\tau'}}
  \end{mathpar}
\end{lemma}

\begin{proof}
  Induction on $\judgeSok{x}{\tau}$.
  \begin{itemize}
    \item For C-Cong (N-Cong), we apply the induction hypothesis and C-Cong (N-Cong, resp.).
    \item For E-FV, notice that the reduction does not increase the set of free variables,
      and thus, E-FV is applicable after the reduction of one of the $\tau_i$.
    \item The E-Cong case is a little bit more complicated.
      Notice that $\tau_1 \nrightarrow x$. This is because if $\tau_1$ is an
      eliminator, it must be inert by EE-Inert.
      Then we can consider in which $\tau_i$ the reduction happened, 
      apply the induction hypothesis and \cref{lemma:inertness-pres}.
    \item For the additional rules, the reduction can be either by congruence
      (and then we apply the induction hypothesis,
      \cref{lemma:cong-safe-occurrence} and the same rule) or by the
      top-level redex contraction, and then the required property is exactly one
      of the premises.
  \end{itemize}

\end{proof}

Notice that \emph{no occurrence means safe occurrence}, that is
$\judgeSok{x}{\tau}$ does not imply $x \in \fv{\tau}$. We use notation
$\judgeSOK{x}{\tau}$ to denote $\judgeSok{x}{\tau}$ \emph{and} $x \in
\fv{\tau}$.

\begin{definition}[Strictly Safe Occurrence]
  \begin{mathpar}
    \Infer{}{\judgeSok{x}{\tau} \\ x \in \fv{\tau}}{\judgeSOK{x}{\tau}}
  \end{mathpar}
\end{definition}

\begin{proposition}[Safe occurrence in a redex]
  \label{prop:safe-occurrence-in-a-redex}
  If $\tau$ is a top-level redex and $\judgeSOK{x}{\tau}$,
  then the redex is non-substitutive, i.e. the judgement
  $\judgeSok{x}{\tau}$  was constructed by one of the rules from 
  $\cref{def:safe-occurrence-extension}$
\end{proposition}


\begin{lemma}[Reduction preserves strictly safe occurrence]
  \label{lemma:striclty-safe-occur-pres}
  \begin{mathpar}
    \Infer{}{\judgeSOK{x}{\tau} \\ \reduces{\tau}{\tau'}}{\judgeSOK{x}{\tau'}}
  \end{mathpar}
\end{lemma}
\begin{proof}
  Induction on $\reduces{\tau}{\tau'}$.
  Since the redex contraction is special case of reduction, by \cref{lemma:safe-occur-pres}, it preserves 
  the non-strict safe occurrence. Let us show that the actual occurrence $x \in \fv{\tau}$ is preserved as well.

  $x$ can only disappear after the contraction of the redex $r \subseteq \tau$ if $x$ occurred
  inside this redex (i.e. $x \in \fv{r}$). By the trivial implication of
  \cref{lemma:cong-safe-occurrence}, since $r \subseteq \tau$ and $\judgeSok{x}{\tau}$,
  $\judgeSok{x}{r}$. Then by \cref{prop:safe-occurrence-in-a-redex}, $r$ can
  only be non-substitutive. However, non-substitutive redexes preserve the variables,
  hence, $x$ could not have disappeared.
  
\end{proof}

\begin{multicols}{2}

\begin{definition}[Safe Existential Variable Set]
  $$\evok{\rho} = \{\hat{x} \mid \judgeSOK{\hat{x}}{\rho}\}$$
\end{definition}

\begin{corollary}[Reduction preserves the Safe Existential Variable Set]
  \label{corollary:evok-pres}
  \begin{mathpar}
    \Infer{}{\reduces{\tau}{\tau'}}{\evok{\tau} = \evok{\tau'}} \and
    \Infer{}{\bigstepsto{\tau}{\tau'}}{\evok{\tau} = \evok{\tau'}}
  \end{mathpar}
\end{corollary}

  \begin{definition}[Existential Variable Set]
    $$\ev{\rho} = \{\hat{x} \mid \hat{x} \in {\fv{\rho}}\}$$
  \end{definition}

  \begin{proposition}[Existential Variable Set is monotonous w.r.t. Reduction]
    \label{prop:ev-monotonous}
    \begin{mathpar}
      \Infer{}{\reduces{\tau}{\tau'}}{\ev{\tau} \supseteq \ev{\tau'}} \and
      \Infer{}{\bigstepsto{\tau}{\tau'}}{\ev{\tau} \supseteq \ev{\tau'}}
    \end{mathpar}
  \end{proposition}
\end{multicols}

\section{Equivalence and Unification}

\begin{definition}[Syntax of algorithmic terms]
  \label{def:alg-terms}
  Throughout the algorithm, we will use the auxiliary pre-cooked terms,
  containing some unassigned parts. For this purpose, we extend the syntax of
  terms (\cref{def:syntax}) by adding the ``hatted'' unification (existential)
  variables $\hat{x}$ to the set of values:
  $$\mbox{Values} \inc \hat{x}$$
  Similarly, we extend the syntax from \cref{def:comp-syntax} by adding
  $\hat{x}$ to the Neutral Formers:
  $$\mbox{Neutral Formers} \inc \hat{x}$$
\end{definition}

\begin{notation}
To denote that the term is algorithmic, i.e. potentially contains the
unification variables, we use $\pi$ and $\rho$. If the term does not contain the
unification variables it is called \emph{ground} and denoted as $\sigma$ and
$\tau$.
\end{notation}

\begin{definition}[Safe algorithmic term]
  We say that the algorithmic term $\rho$ is \emph{safe} iff 
  all the unification variables occur safely in it:
  \begin{mathpar}
    \Infer{}
    {\forall \hat{x},~ \judgeSok{\hat{x}}{\rho}}
    {\judgeSokterm{\rho}}
  \end{mathpar}
\end{definition}

\begin{definition}[Binding Context]
  \begin{mathpar}
    \Gamma ::= \emptyctx \bnfalt \Gamma, ~ x
  \end{mathpar}
\end{definition}


We define equivalence on terms. Notice that the terms are not necessarily ground.
The unification variables are treated as normal ones.
However, since unification variables cannot be abstrated over,
the binding context $\Gamma$ consists of normal variables only.

\begin{definition}[Equivalence]
  \hfill

  \begin{itemize}

  \item[Reduction closure]
    \begin{mathpar}
      \Infer{Red-L}
      {
        \reduces{\rho_1}{\rho_1'}\\
        \judgeequivuntg{\Gamma}{\rho_1'}{\rho_2}
      }
      {
        \judgeequivuntg{\Gamma}{\rho_1}{\rho_2}
      }
      \and
      \Infer{}
      {
        \reduces{\rho_2}{\rho_2'}\\
        \judgeequivuntg{\Gamma}{\rho_1}{\rho_2'}\\
        \judgeSnf{\rho_1}
      }
      {
        \judgeequivuntg{\Gamma}{\rho_1}{\rho_2}
      }
    \end{mathpar}

  \item[Congruence]
    \begin{mathpar}

      \Infer{}
      {
        \judgeequivuntg{\Gamma}{P_1}{Q_1} \\
        \dots\\
        \judgeequivuntg{\Gamma}{P_{\narg{F}}}{Q_{\narg{F}}} \\
        \judgeSnf{\fullterm{F}{P}} \\
        \judgeSnf{\fullterm{F}{Q}}
      }
      {
        \judgeequivuntg{\Gamma}{\fullterm{F}{P}}{\fullterm{F}{Q}}
      }
      \and

      \Infer{}
      {
        \judgeequivuntg{\Gamma, x}
      {\absclose{n}{\pi}}
      {\absclose{n}{\rho}}
      }
        {
          \judgeequivuntg{\Gamma}{x.\absclose{n}{\pi}}{x.\absclose{n}{\rho}}
      }
        \and


      \Infer{}
      {
        \judgeequivuntg{\Gamma}{\sigma}{\rho}
      }
      {
        \judgeequivuntg{\Gamma}{.\sigma}{.\rho}
      }
    \end{mathpar}

  \end{itemize}

\end{definition}

\begin{lemma}[Equivalent terms have equal normal forms]
  \label{lemma:equiv-nf}
  \begin{mathpar}
    \Infer{}
    {\judgeequivuntg{\Gamma}{\pi}{\rho}}
    {\nf{\pi} = \nf{\rho}}
  \end{mathpar}
\end{lemma}

\begin{lemma}[Equivalent terms have equal safe existential variable sets]
  \label{lemma:equiv-evok}
  \begin{mathpar}
    \Infer{}
    {\judgeequivuntg{\Gamma}{\pi}{\rho}}
    {\evok{\pi} = \evok{\rho}}
  \end{mathpar}
\end{lemma}
\begin{proof}
  Trivial induction using \cref{corollary:evok-pres}.
\end{proof}



\begin{definition}[Free Variable Environment] Free variable environment $E$ is a
  (partial) \emph{mapping} from unification variables to sets of regular
  variables. $E[\hat{v}]$ is a set $\Gamma$ of variables associated with $\hat{v}$
  that are allowed to be used in the initialization. Morally, $\Gamma$ is a
  binding context at the moment when $\hat{v}$ was introduced.
  \begin{mathpar}
    E ::= \emptyctx \bnfalt E, ~ \mapentry{\hat{v}}{\Gamma}
  \end{mathpar}
\end{definition}

\begin{definition}[Admissible term]
  \begin{mathpar}
    \Infer{}
    {\fv{\tau} \subseteq \Gamma}
    {\judgesafeinenv{\Gamma}{\tau}}
  \end{mathpar}
\end{definition}

\begin{definition}[Unification Context] Unification context represents a
  (partial) solution of the unification problem. Syntactically, it is a \emph{set} of
  pairs. Each pair represent an initialization of a unification variable: 
  $$\varphi, \psi ::= \emptyctx \bnfalt \varphi, \evarassign{\hat{v}}{\tau} $$
  where $\tau$ is a ground term.
\end{definition}

The unification (or algorithmic equivalence) judgement is of the form
$\judgeunify{E; \varphi}{\rho}{\rho'}{\varphi'}$ where $\rho$ and $\rho'$ are
algorithmic terms (potentially with unassigned variables), $\varphi$ and
$\varphi'$ are unification contexts, E is a free variable environment.


\begin{definition}[Admissible unification context] The unification context $\varphi$ is
  admissible by the environment $E$ if the term $\tau$ it assigns to the unification
  variable $\hat{v}$ is admissible by the set of variables $E[\hat{v}]$
  (in particular, $E$ is defined on $\hat{v}$).
  \begin{mathpar}
    \Infer{}
    { }
    {\judgesafeinenv{E}{\emptyctx}}

    \and
    \Infer{}
    {\judgesafeinenvv{E}{\hat{v}}{\tau}}
    {\judgesafeinenv{E}{\varphi, \evarassign{\hat{v}}{\tau}}}
  \end{mathpar}
\end{definition}


\begin{definition}[Well-formed unification context]
  We say that a unification context $\varphi$ is well-formed if the mapping it
  represents is a partial function, whose image terms are normal and ground:
  \begin{mathpar}

    \Infer{}
    { }
    {
      \judgectx{ }{\emptyctx}
    }
    \and
    \Infer{}
    { 
    \judgectx{ }{\varphi} \\
    \evarassign{\hat{x}}{\spcdot} \notin \varphi \\
    \judgeSnf{\tau}
    }
    {
      \judgectx{ }{\varphi, \evarassign{\hat{x}}{\tau}}
    }
  \end{mathpar}
\end{definition}

% \begin{definition}[Safe unification context]
%   We say that a unification context $\varphi$ is safe under the binding context $B$
%   ($\judgesafeinenv{B}{\varphi}$)
%   if the free variables of $\varphi$ do not intersect with $B$.
% \end{definition}

\begin{definition}[Application of the well-formed context]
  If the unification context $\varphi$ is well-formed,
  We write $\ctxtapp{\varphi}{\tau}$ meaning the application of the partial
  (substitution) function represented by $\varphi$ to the term $\tau$:
  \begin{itemize}
  \item $\ctxtapp{\emptyctx}{\tau} = \tau$
  \item $\ctxtapp{\varphi, \evarassign{\hat{x}}{\sigma}}{\tau} = \subst{(\ctxtapp{\varphi}{\tau})}{\hat{x}}{\sigma}$
  \end{itemize}

\end{definition}

Intuitively, when a context is applied to a term, the components of
the context are applied to the term one-by-one. This way, the properties holding
for a single substitution, can be lifted up to the context application.
\begin{corollary}[Context application commutes with the reduction]
  \label{corollary:red-app-commute}
    \begin{mathpar}
      \Infer{}
      {
        \judgectx{}{\Omega}\\
        \judgeSokterm{\rho}\\
        \reduces{\ctxtapp{\Omega}{\rho}}{\rho'}\\
      }
      {\exists \rho^* \text{ s.t. } \reduces{\rho}{\rho^*} \text{ and } \ctxtapp{\Omega}{\rho^*} = \rho'}
    \end{mathpar}
  \end{corollary}

  \begin{figure}[h]
    \centering
    \begin{tikzcd}
      \rho & {\rho^*} \\
      \bullet & {\rho^*_2} \\
      \bullet & {\rho^*_n} \\
      {[\Omega]\rho} & {\rho'}
      \arrow["{\hat{x}_1:=\tau_1}"', from=1-1, to=2-1]
      \arrow["{\hat{x}_1:=\tau_1}", dashed, from=1-2, to=2-2]
      \arrow["\rightarrow", dashed, from=1-1, to=1-2]
      \arrow["\rightarrow", dashed, from=2-1, to=2-2]
      \arrow[dotted, no head, from=2-1, to=3-1]
      \arrow[dotted, no head, from=2-2, to=3-2]
      \arrow["{\hat{x}_n := \tau_n}"', from=3-1, to=4-1]
      \arrow["\rightarrow", from=4-1, to=4-2]
      \arrow["\rightarrow", dashed, from=3-1, to=3-2]
      \arrow["{\hat{x}_n:=\tau_n}", dashed, from=3-2, to=4-2]
    \end{tikzcd}
    \caption{Proof scheme}
    \label{fig:red-app-commute-scheme}
  \end{figure}

  \begin{proof}
    Induction on $\ctxtapp{\Omega}{\rho}$ using \cref{lemma:red-subst-commute}.
    See \cref{fig:red-app-commute-scheme} for the details: we acquire $\rho^*$
    by consequently applying \cref{lemma:red-subst-commute} bottom-to-top to
    construct $\rho^*_n, \dots, \rho^*_2, \rho^*$.
    The premises required for \cref{lemma:red-subst-commute} hold because 
    $\judgectx{}{\Omega}$ and $\judgeSokterm{\rho}$.
  \end{proof}

  \begin{corollary} [Context application preserves reduction]
    \label{corollary:ctx-app-pres-red}
    \begin{mathpar}
      \Infer{}{\judgectx{}{\Omega} \\ \reduces{\rho}{\rho'}}
      {\reduces{\ctxtapp{\Omega}{\rho}}{\ctxtapp{\Omega}{\rho'}}}
    \end{mathpar}
  \end{corollary}
  \begin{proof}
    Induction on $\Omega$ using  \cref{lemma:subst-res}.
  \end{proof}
 
  \begin{corollary} [Reduction preserves safety]
    \label{corollary:safety-pres}
    \begin{mathpar}
      \Infer{}{\judgeSokterm{\rho} \\ \reduces{\rho}{\rho'}}{\judgeSokterm{\rho'}}
    \end{mathpar}
  \end{corollary}
  \begin{proof}
    Follows from \cref{lemma:safe-occur-pres}.
  \end{proof}


\begin{definition}[Unification]  The unification algorithm is defined
  as follows:

\begin{itemize}
    \item[Base rules]
      \begin{mathpar}
        \Infer{U-Add}
        { 
          \evarassign{\hat{v}}{\spcdot} \notin \varphi \\
          \judgeSnf{\tau} \\
          \judgesafeinenvv{E}{\hat{v}}{\tau} \\
        }
        {
          \judgeunify{\Gamma; E; \varphi}{\hat{v}}{\tau}{\varphi, \evarassign{\hat{v}}{\tau}}
        }
        \and
        \Infer{U-Keep}
        { 
          \evarassign{\hat{v}}{\tau} \in \varphi
        }
        {
          \judgeunify{\Gamma; E;\varphi}{\hat{v}}{\tau}{\varphi}
        }
      \end{mathpar}

    \item[Reduction closure]
      \begin{mathpar}
        \Infer{Red-L}
        {
          \reduces{\rho_1}{\rho_1'}\\
          \judgeunify{\Gamma; \varphi}{\rho_1'}{\tau_2}{\varphi'}
        }
        {
          \judgeunify{\Gamma; E; \varphi}{\rho_1}{\tau_2}{\varphi'}
        }
        \and
        \Infer{Red-R}
        {
          \reduces{\tau_2}{\tau_2'}\\
          \judgeunify{\Gamma; \varphi}{\rho_1}{\tau_2'}{\varphi'}\\
          \judgeSnf{\rho_1}
        }
        {
          \judgeunify{\Gamma; E; \varphi}{\rho_1}{\tau_2}{\varphi'}
        }
      \end{mathpar}

    \item[Congruence]
   \begin{mathpar}
     \Infer{}
     {
       \judgeunify{\Gamma; E;\varphi_0}{P_1}{Q_1}{\varphi_1} ~
       \dots ~
       \judgeunify{\Gamma; E;\varphi_{\narg{F}-1}}{P_{\narg{F}}}{Q_{\narg{F}}}{\varphi_{\narg{F}}} \\
       \judgeSnf{\fullterm{F}{P}} \\
       \judgeSnf{\fullterm{F}{Q}}
     }
     {
       \judgeunify{\Gamma; E; \varphi_0}{\fullterm{F}{P}}{\fullterm{F}{Q}}{\varphi_{\narg{F}}}
     } \and
     % \Infer{}
     % {
     %   z \text{ is fresh} \\
     %   \judgeunify{B,z; \varphi}
     %   {\rename{\absclose{n}{\rho}}{x}{z}}
     %   {\rename{\absclose{n}{\tau}}{y}{z}}
     %   {\psi}
     % }
     % {
     %   \judgeunify{B; \varphi}
     %   {x.\absclose{n}{\rho}}
     %   {y.\absclose{n}{\tau}}
     %   {\psi}
     % } \and

     \Infer{}
     {
       \judgeunify{\Gamma, x; E; \varphi}
       {\absclose{n}{\rho}}
       {\absclose{n}{\tau}}
       {\psi}
     }
     {
       \judgeunify{\Gamma; E; \varphi}
       {x.\absclose{n}{\rho}}
       {x.\absclose{n}{\tau}}
       {\psi}
     }
     \and

     \Infer{}
     {
       \judgeunify{\Gamma; E; \varphi}
       {\rho}
       {\tau}
       {\psi}
     }
     {
       \judgeunify{\Gamma; E; \varphi}
       {.\rho}
       {.\tau}
       {\psi}
     } \and


\end{mathpar}

\end{itemize}
\end{definition}


We prove the soundness and completeness of the unification w.r.t. the equality
defined above. Intuitively, soundness means that the output context produced by
the unification algorithm does not make the terms non-unifiable.

\begin{lemma} [Unification soundness]
  \begin{mathpar}
    \Infer{}
    { \judgectx{}{\varphi_1}\\
      \judgeunify{\Gamma; E; \varphi_1}{\rho}{\tau}{\varphi_2} \\
      \judgesafeinenv{E}{\varphi_1} \\
      \codom{E} \subseteq \Gamma
    }
    { \judgectx{}{\varphi_2}\\
      \judgeequivuntg{\Gamma}{\ctxtapp{\varphi_2}{\rho}}{\tau} \\
      \varphi_1 \subseteq \varphi_2 \\
      \judgesafeinenv{E}{\varphi_2} \\
    }
  \end{mathpar}
\end{lemma}

\begin{proof}
  Induction on $\judgeunify{\Gamma; E; \varphi_1}{\rho}{\tau}{\varphi_2}$.
  \begin{itemize}
    \item
      $
      \Infer{}
      { 
        \evarassign{\hat{v}}{\spcdot} \notin \varphi_1 \\
        \judgeSnf{\tau} \\
        \judgesafeinenvv{E}{\hat{v}}{\tau}
      }
      {
        \judgeunify{\Gamma; E; \varphi_1}{\hat{v}}{\tau}{\varphi_1, \evarassign{\hat{v}}{\tau}}
      }
      $
      Then $\rho = \hat{v}$ and $\varphi_2 = \varphi_1, \evarassign{\hat{v}}{\tau}$.
      \begin{itemize}
        \item It is easy to see that $\judgectx{}{\varphi_2}$ because
          $\judgectx{}{\varphi_1, \evarassign{\hat{v}}{\tau}}$  by definition of the
          well-formed context (all the required premises are given);
        \item $\ctxtapp{\varphi_2}{\rho} = \ctxtapp{\varphi_1,
            \evarassign{\hat{v}}{\tau}}{\hat{v}} = \tau$.
          $\judgeequivuntg{\Gamma}{\tau}{\tau}$;
        \item $\varphi_1 \subseteq \varphi_1, \evarassign{\hat{v}}{\tau}$ by definition;

        \item $\judgesafeinenv{E}{\varphi_1, \evarassign{\hat{v}}{\tau}}$
          because $\judgesafeinenv{E}{\varphi_1}$ and $\judgesafeinenvv{E}{\hat{v}}{\tau}$.
     \end{itemize}
   \item 
      $
      \Infer{}
      { 
        \evarassign{\hat{v}}{\tau} \in \varphi
      }
      {
        \judgeunify{\Gamma; E; \varphi}{\hat{v}}{\tau}{\varphi}
      }
      $
      Then $\rho = \hat{v}$ and $\varphi_1 = \varphi_2 = \varphi$.
      \begin{itemize}
      \item $\judgectx{}{\varphi_2}$ because $\varphi_2 = \varphi_1$ and
        $\judgectx{}{\varphi_1}$ is in the premises;
      \item $\judgeequivuntg{\Gamma}{\ctxtapp{\varphi_2}{\hat{v}}}{\tau}$ because
        $\judgectx{}{\varphi_2}$ and $\evarassign{\hat{v}}{\tau} \in \varphi_2$.
      \item $\varphi \subseteq \varphi$ trivially.
      \item $\judgesafeinenv{E}{\varphi_2}$ because $\varphi_2 = \varphi_1$ and
        $\judgesafeinenv{E}{\varphi_1}$ is in the lemma premises.
      \end{itemize}
    \item
      $
      \Infer{}
      {
        \reduces{\rho}{\rho'}\\
        \judgeunify{\Gamma; E; \varphi_1}{\rho'}{\tau}{\varphi_2}
      }
      {
        \judgeunify{\Gamma; E; \varphi_1}{\rho}{\tau}{\varphi_2}
      }
      $
      Then by the induction hypothesis:
      $\varphi_1 \subseteq \varphi_2$,
      $\judgectx{}{\varphi_2}$,
      $\judgesafeinenv{E}{\varphi_2}$,
      and $\judgeequivuntg{\Gamma}{\ctxtapp{\varphi_2}{\rho'}}{\tau}$.
      To prove that $\judgeequivuntg{\Gamma}{\ctxtapp{\varphi_2}{\rho}}{\tau}$ we apply Red-L:
      $$
      \Infer{Red-L}
      {
        \reduces{\ctxtapp{\varphi_2}{\rho}}{\ctxtapp{\varphi_2}{\rho'}}\\
        \judgeequivuntg{\Gamma}{\ctxtapp{\varphi_2}{\rho'}}{\tau}
      }
      {
        \judgeequivuntg{\Gamma}{\ctxtapp{\varphi_2}{\rho}}{\tau}
      }
      $$
      Here $\reduces{\ctxtapp{\varphi_2}{\rho}}{\ctxtapp{\varphi_2}{\rho'}}$
      holds by \cref{corollary:ctx-app-pres-red}.
    \item
      $
      \Infer{}
      {
        \reduces{\tau}{\tau'}\\
        \judgeunify{\Gamma; E; \varphi_1}{\rho}{\tau'}{\varphi_2}\\
        \judgeSnf{\rho}
      }
      {
        \judgeunify{\Gamma; E; \varphi_1}{\rho}{\tau}{\varphi_2}
      }
      $
      Analogously to the previous case.

    \item
      $
      \Infer{}
      {
        \judgeunify{\Gamma; E;\psi_0}{P_1}{Q_1}{\psi_1} \\
        \dots\\
        \judgeunify{\Gamma; E;\psi_{\narg{F}-1}}{P_{\narg{F}}}{Q_{\narg{F}}}{\psi_{\narg{F}}} \\
        \judgeSnf{\fullterm{F}{P}} \\
        \judgeSnf{\fullterm{F}{Q}}
      }
      {
        \judgeunify{\Gamma; E; \psi_0}{\fullterm{F}{\rho}}{\fullterm{F}{\tau}}{\psi_{\narg{F}}}
      }
      $

      Then $\varphi_1 = \psi_0$, $\varphi_2 = \psi_{\narg{F}}$, $\rho =
      \fullterm{F}{P}$, $\tau = \fullterm{F}{Q}$. 

      We can apply the induction hypothesis to the first unification judgement
      in the premise (i.e. to $\judgeunify{\Gamma; E; \psi_0}{P_1}{Q_1}{\psi_1}$) acquiring:
      $\judgectx{}{\psi_1}$,
      $\judgectx{E}{\psi_1}$,
      and
      $\judgeequivuntg{\Gamma}{\ctxtapp{\psi_1}{P_1}}{Q_1}$. Then, because
      $\judgectx{}{\psi_1}$, we can apply the induction hypothesis to the second
      premise. Continuing this process, we acquire:
      \begin{itemize}
        \item
          $\varphi_1 = \psi_0 \subseteq \cdots \subseteq \psi_{\narg{F}} = \varphi_2$;
        \item
          $\judgectx{}{\varphi_2}$
        \item
          $\judgectx{E}{\varphi_2}$
        \item $\judgeequivuntg{\Gamma}{\ctxtapp{\psi_i}{P_i}}{Q_i}$ for $i =
          1\dots\narg{F}$. Hence, because $\psi_i \subseteq \varphi_2$,
          $\judgeequivuntg{\Gamma}{\ctxtapp{\varphi_2}{P_i}}{Q_i}$, which implies
          that $\judgeequivuntg{\Gamma}{\ctxtapp{\varphi_2}{\fullterm{F}{P}}}{\fullterm{F}{Q}}$
      \end{itemize}

      \item
        $
        \Infer{}
        {
          \judgeunify{\Gamma, x; E; \varphi_1}
          {\absclose{n}{\rho}}
          {\absclose{n}{\tau}}
          {\varphi_2}
        }
        {
          \judgeunify{\Gamma; E; \varphi_1}
          {x.\absclose{n}{\rho}}
          {x.\absclose{n}{\tau}}
          {\varphi_2}
        }
      $

      Then we apply the induction hypothesis to
      $ \judgeunify{\Gamma, x; E; \varphi_1} {\absclose{n}{\rho}} {\absclose{n}{\tau}} {\varphi_2} $
      and acquire 
      \begin{itemize}
        \item $\judgectx{}{\varphi_2}$
        \item $\varphi_1 \subseteq \varphi_2$
        \item $\judgectx{E}{\varphi_2}$
        \item
          $\judgeequivunt{\ctxtapp{\varphi_2}{\absclose{n}{\rho}}}{\absclose{n}{\tau}}$.
          By the Barendrecht's convention, $x \notin \Gamma$, hence, 
          $x \notin \codom{E}$. Since $\judgectx{E}{\varphi_2}$, $x \notin \fv{\varphi_2}$.
          Therefore, $x.\ctxtapp{\varphi_2}{\absclose{n}{\rho}} =
          \ctxtapp{\varphi_2}{x.\absclose{n}{\rho}}$, which gives us the
          required equivalence. 
          \ilyam{extract a lemma}
      \end{itemize}

    \item
      $
      \Infer{}
      {
        \judgeunify{\Gamma; E; \varphi}
        {\rho}
        {\tau}
        {\psi}
      }
      {
        \judgeunify{\Gamma; E; \varphi}
        {.\rho}
        {.\tau}
        {\psi}
      }
      $ 
      Trivially by the induction hypothesis. 




  \end{itemize}

\end{proof}


% \begin{lemma}[Reflexivity of unification]
%   $\judgeunify{\Gamma; E;\varphi}{\tau}{\tau}{\varphi}$
% \end{lemma}
% \begin{proof}
%   Straightforward induction.
% \end{proof}

% \begin{lemma} [Unification invariance under substitution]
%   \label{lemma:unif-inv-under-subst}
%   \begin{mathpar}
%     \Infer{}
%     {\judgeunify{\Gamma; E;\varphi}{\rho}{\tau}{\psi} \\
%      x \notin \fv{\psi}
%     }
%     {\judgeunify{\Gamma; E;\varphi}{\subst{\rho}{x}{\sigma}}{\subst{\tau}{x}{\sigma}}{\psi}}
%   \end{mathpar}
% \end{lemma}
% \begin{proof}
%   Induction on 
%   $\judgeunify{E;\varphi}{\rho}{\tau}{\psi}$.
%   \ilyam{seems straightforward}
% \end{proof}


\begin{lemma} [Unification completeness]
  \begin{mathpar}
    \Infer{}
    {
      \judgectx{E}{\Omega}\\
      \judgectx{}{\Omega}\\
      \judgeSokterm{\rho}\\
      \judgeequivuntg{\Gamma}{\ctxtapp{\Omega}{\rho}}{\tau}\\
    }
    {
      \forall \varphi \subseteq \Omega. ~ \exists \psi \subseteq \Omega. ~
      \judgeunify{\Gamma; E; \varphi}{\rho}{\tau}{\psi} \\
    }
  \end{mathpar}

\end{lemma}

\begin{proof}
  Induction on $\judgeequivunt{\ctxtapp{\Omega}{\rho}}{\tau}$.
  
  \begin{itemize}
  \item
    $
    \Infer{}
      {
        \reduces{\ctxtapp{\Omega}{\rho}}{\rho'}\\
        \judgeequivuntg{\Gamma}{\rho'}{\tau}
      }
      {
        \judgeequivuntg{\Gamma}{\ctxtapp{\Omega}{\rho}}{\tau}
      }
      $ By \cref{corollary:red-app-commute}, there exists $\rho^*$ s.t.
      $\reduces{\rho}{\rho^*}$ and $\ctxtapp{\Omega}{\rho^*} = \rho'$.


      By \cref{lemma:safe-occur-pres}, $\judgeSokterm{\rho^*}$.
      Then we apply the induction hypothesis to $E$, $\Omega$, $\rho^*$, and $\tau$.
      To acquire $\forall \varphi \subseteq \Omega. ~ \exists \psi \subseteq \Omega. ~
      \judgeunify{\Gamma; E; \varphi}{\rho^*}{\tau}{\psi}$,
      where we can replace $\rho^*$ with $\rho$ by Red-L.

  \item
    $
    \Infer{}
    {
      \reduces{\tau}{\tau'}\\
      \judgeequivuntg{\Gamma}{\ctxtapp{\Omega}{\rho}}{\tau'}\\
      \judgeSnf{\ctxtapp{\Omega}{\rho}}
    }
    {
      \judgeequivuntg{\Gamma}{\ctxtapp{\Omega}{\rho}}{\tau}
    }
    $
    We can apply the induction hypothesis to $E, \Omega$, $\rho$, $\Gamma$, and $\tau'$ right
    away to acquire $\forall \varphi \subseteq \Omega. ~ \exists \psi \subseteq
    \Omega. ~ \judgeunify{\Gamma; E;\varphi}{\rho}{\tau'}{\psi}$, where we replace $\tau'$
    with $\tau$ by Red-R.

  \item
    $
    \Infer{}
    {
      \judgeequivuntg{\Gamma}{Q_1}{Q'_1} \\
      \dots\\
      \judgeequivuntg{\Gamma}{Q_{\narg{F}}}{Q'_{\narg{F}}} \\
      \judgeSnf{\fullterm{F}{Q}} \\
      \judgeSnf{\fullterm{F}{Q'}}
    }
    {
      \judgeequivuntg{\Gamma}{\fullterm{F}{Q}}{\fullterm{F}{Q'}}
    }
    $
    Then $\ctxtapp{\Omega}{\rho} = \fullterm{F}{Q}$ and $\tau =
    \fullterm{F}{Q'}$.
    Let us destruct $\ctxtapp{\Omega}{\rho}$. \ilyam{we need a lemma to destruct
    it this way}
    \begin{itemize}
      \item $\rho = \hat{x}$ and $\evarassign{\hat{x}}{\fullterm{F}{Q}} \in
        \Omega$. Let us consider an arbitrary $\varphi \subseteq \Omega$.
        $\varphi$ is well-formed, then either $\evarassign{\hat{x}}{\fullterm{F}{Q}} \in
        \varphi$ or $\evarassign{\hat{x}}{\spcdot} \notin \varphi$.
        \begin{itemize}
        \item $\evarassign{\hat{x}}{\fullterm{F}{Q}} \in \varphi$ then we
          take $\psi = \varphi$ and apply U-Keep. 
        \item $\evarassign{\hat{x}}{\spcdot} \notin \varphi$ then we
          take $\psi = \varphi, \evarassign{\hat{x}}{\fullterm{F}{Q}}$
          and apply U-Add. The term $\fullterm{F}{Q}$
          is in the normal form by one
          of the premises. $\judgectx{E[\hat{x}]}{\fullterm{F}{Q}}$ because
          $\judgectx{E}{\Omega} \ni \evarassign{\hat{x}}{\fullterm{F}{Q}}$.

        \end{itemize}
      \item $\rho = \fullterm{F}{P}$, $F \neq \hat{x}$, 
        $\ctxtapp{\Omega}{P_i} = Q_i$ and $\judgeequivuntg{\Gamma}{Q_i}{Q'_i}$ for $i = 1\dots\narg{F}$.

        By the corollary of \cref{lemma:cong-safe-occurrence},
        $\judgeSokterm{P_i}$. So we can apply the induction hypothesis to all
        the components to acquire $\narg{F}$ facts: $\forall \varphi \subseteq \Omega.
        ~ \exists \psi \subseteq \Omega. ~ \judgeunify{\Gamma; E; \varphi}{P_i}{Q'_i}{\psi}$.

        Let us apply the first fact to an arbitrary $\varphi = \psi_0 \subseteq
        \Omega$ to acquire $\psi_1 \subseteq \Omega$. Then we apply the second
        fact to $\psi_1 $, acquiring $\psi_2 \subseteq \Omega$. Repeating the process, we have:
        $\judgeunify{\Gamma; E; \psi_0}{P_1}{Q'_1}{\psi_1}, ~ \dots, ~
        \judgeunify{\Gamma; E; \psi_{\narg{F}-1}}{P_{\narg{F}}}{Q'_{\narg{F}}}{\psi_{\narg{F}}}$.

        Notice that by \cref{lemma:subst-res,prop:nf-irred},
        $\judgeSnf{\fullterm{F}{P}}$. Then we apply the congruence
        unification rule and get
        $\judgeunify{\Gamma; E;\varphi}{\fullterm{F}{P}}{\fullterm{F}{Q'}}{\psi_{\narg{F}}}$,
        i.e. $\judgeunify{\Gamma; E;\varphi}{\rho}{\tau}{\psi_{\narg{F}}}$, so we take
        $\psi_{\narg{F}}$ as $\psi$.

    \end{itemize}
    
  \item
    $
    \Infer{}
    {\judgeequivuntg{\Gamma, x}{\absclose{n}{\sigma}} {\absclose{n}{\tau}} }
    {\judgeequivuntg{\Gamma}{x.\absclose{n}{\sigma}}{x.\absclose{n}{\tau}}}
    $

    Then
    $\ctxtapp{\Omega}{\rho} = x.\absclose{n}{\sigma}$, which means that $\rho =
    x.\absclose{n}{\rho'}$, and  $\ctxtapp{\Omega}{\absclose{n}{\rho'}} =
    \absclose{n}{\sigma}$. Notice that
    $\judgeSokterm{\absclose{n}{\rho'}}$, which means the induction hypothesis
    is applicable and gives us $\forall \varphi \subseteq \Omega. ~ \exists \psi
    \subseteq \Omega. ~
    \judgeunify{\Gamma,x;E;\varphi}{\absclose{n}{\rho'}}{\absclose{n}{\tau}}{\psi}$.
    % We choose a fresh variable $y$. By \cref{lemma:unif-inv-under-subst},
    % $\forall \varphi \subseteq \Omega. ~ \exists \psi \subseteq \Omega. ~
    % \judgeunify{E;\varphi}{\rename{(\absclose{n}{\rho'})}{x}{y}}{\rename{(\absclose{n}{\sigma})}{x}{y}}{\psi}$.
    Then we can apply the corresponding
    unification rule to get the required unification judgement: 
    $\judgeunify{\Gamma; E; \varphi}{x.\absclose{n}{\rho'}}{x.\absclose{n}{\tau}}{\psi}$.

  \item
    $
    \Infer{}
    {
      \judgeequivunt{\sigma}{\tau}
    }
    {
      \judgeequivunt{.\sigma}{.\tau}
    }
    $
    Trivially by the induction hypothesis.
    
  \end{itemize}

\end{proof}



% \begin{lemma} [Unification completeness]
%   If $\varphi(\rho)$ or $\varphi(\rho')$ is ground and 
%   $\judgeunify{\varphi}{\rho}{\rho'}{\varphi'}$ holds, then $\varphi'(\rho)$
%   and $\varphi'(\rho')$ are ground.
% \end{lemma}
% \ilyam{There might be some problems with the meaningless existential variables}




\section{Typing}
\label{sec:rules}

\subsection{Declarative Type System}

\begin{definition}[Declarative Typing Context]
\begin{mathpar}
  \begin{array}{llcl}
    \Gamma & ::= & \emptyctx \bnfalt \Gamma,\, x:A
  \end{array}
\end{mathpar}
\end{definition}


To make the typing decidable, we restrict the system in several ways. In particular,
when we form $\foralltype{x:A}{X}$, we require $x$ to belong to $\fv{X}$ and occur
safely in $X$.



\begin{description}
  \item[Var]
\begin{mathpar}

\Infer{Var}
      { \judgeInctx{x:A}{\Gamma} }
      { \judgevInfer{\Gamma}{x}{A} }
\and

\Infer{VarT}
{ }
{\judgevtype{\Gamma}{a}}

\end{mathpar}
\item[Declarative Subsumption]

\begin{mathpar}
  
  \Infer{$\csubt$}
        { \judgecInfer{\Gamma}{t}{X} \\
          \judgecsubt{\vars{\Gamma}}{X}{Y} \\
        }
        { \judgecCheck{\Gamma}{t}{Y} }
  \and

  \Infer{$\vsubt$}
        { \judgevInfer{\Gamma}{v}{A} \\
          \judgevsubt{\vars{\Gamma}}{A}{B} \\
        }
        { \judgevCheck{\Gamma}{v}{B} }
\end{mathpar}

\item[Type Formation]
\label{sec:rules:universes}

\begin{mathpar}
  \Infer{$\vtoc$}
        { \judgevtype{\Gamma}{A} }
        { \judgectype{\Gamma}{\valtocomp{A}} }
        \and

  \Infer{$\ctov$}
        { \judgectype{\Gamma}{X} }
        { \judgevtype{\Gamma}{\comptoval{X}} }
  \and

  \Infer{$\Pi$}
        { \judgevtype{\Gamma}{A} \\
          \judgectype{\Gamma, x:A}{X} }
        { \judgectype{\Gamma}{\pitype{x:A}{X}} }
  \and

  \Infer{$\forall$}
        { \judgevtype{\Gamma}{A} \\
          \judgectype{\Gamma, x:A}{X} \\
          \judgeSOK{x}{X}
        }
        { \judgectype{\Gamma}{\foralltype{x:A}{X}} }
        \and

  \Infer{$\Sigma$}
        { \judgevtype{\Gamma}{A} \\
          \judgevtype{\Gamma, x:A}{B}}
        { \judgevtype{\Gamma}{\sigmatype{x:A}{B}}}
  \and
  

  \Infer{$\mathsf{eq}$}
  {
    % \judgevtypeAlg{\Gamma_1}{A}{\Gamma_2} \\
          \judgevCheck{\Gamma}{v}{A} \\
          \judgevCheck{\Gamma}{w}{A}}
        { \judgevtype{\Gamma}{\eqtype{A}{v}{w}}}
  \and

  \Infer{Let-type}
  { \judgevtype{\Gamma}{A} \\
    \judgectype{\Gamma, x:A}{X} \\
    \judgecCheck{\Gamma}{e}{\valtocomp{A}}}
  { \judgectype{\Gamma}{(\letval{x:A}{e}{X})}}
  \and

\end{mathpar}

\item[$\vtoc$ and $\ctov$]
\begin{mathpar}

  \xcancel{
  \Infer{$\ctov$I$\checks$}
        { \judgecCheck{\Gamma}{t}{X} }
        { \judgevCheck{\Gamma}{\thunk{t}}{\comptoval{X}}} }

  \and
  \Infer{$\ctov$I$\infers$}
        { \judgecInfer{\Gamma}{t}{X} }
        { \judgevInfer{\Gamma}{\thunk{t}}{\comptoval{X}}}

  \and

  \Infer{$\ctov$E$\checks$}
        { \judgevCheck{\Gamma}{v}{\comptoval{X}} }
        { \judgecCheck{\Gamma}{\force{v}}{X} }

  \and
  \Infer{$\vtoc$E$\infers$}
        { \judgevInfer{\Gamma}{v}{\comptoval{X}} }
        { \judgecInfer{\Gamma}{\force{v}}{X} }
  \and


  \Infer{$\vtoc$I$\checks$}
        { \judgevCheck{\Gamma}{v}{A} }
        { \judgecCheck{\Gamma}{\return{v}}{\valtocomp{A}} }
  \and

  \Infer{$\vtoc$I$\infers$}
        { \judgevInfer{\Gamma}{v}{A} }
        { \judgecInfer{\Gamma}{\return{v}}{\valtocomp{A}} }
  \and
\end{mathpar}

\item[Let and Dependent Let]

\begin{mathpar}

  \Infer{Let$\infers$}
        {
          \judgevtype{\Gamma}{A} \\ 
          \judgecInfer{\Gamma, x : A}{u}{X} \\
          \judgecCheck{\Gamma}{t}{\valtocomp{A}} \\
          \judgectype{\Gamma}{X} \\ 
        }
        { \judgecInfer{\Gamma}{\letval{x : A}{t}{u}}{X} }
  \and

  \Infer{Let$\checks$}
       {
          \judgevtype{\Gamma}{A} \\ 
          \judgecCheck{\Gamma}{t}{\valtocomp{A}} \\ 
          \judgectype{\Gamma}{X} \\ 
          \judgecCheck{\Gamma, x : A}{u}{X}
       }
       { \judgecCheck{\Gamma}{\letval{x : A}{t}{u}}{X} }
  \and

  \Infer{DLet$\infers$}
        {
          \judgevtype{\Gamma}{A} \\ 
          \judgecInfer{\Gamma, x:A}{u}{X} \\
          \judgecCheck{\Gamma}{t}{\valtocomp{A}} \\
          \judgectype{\Gamma, x:A}{X} \\ 
        }
        { \judgecInfer{\Gamma}{\dletval{x:A}{t}{u}}{(\letval{x:A}{t}{X})} }
  \and

  \Infer{DLet$\checks$}
        {
          \judgevtype{\Gamma}{A} \\ 
          \judgecCheck{\Gamma}{t}{\valtocomp{A}} \\ 
          \judgectype{\Gamma, x:A}{X} \\ 
          \judgecCheck{\Gamma, x:A}{u}{X}}
        { \judgecCheck{\Gamma}{\dletval{x:A}{t}{u}}{(\letval{x:A}{t}{X})} }
  \and

\end{mathpar}

\item[$\forall$, $\Pi$, and $\Sigma$]

\begin{mathpar}

  \Infer{$\forall$I$\checks$}
        {
          \judgevtype{\Gamma}{A} \\ 
          \judgectype{\Gamma, x:A}{X} \\
          \judgecCheck{\Gamma, x:A}{t}{X} }
        { \judgecCheck{\Gamma}{\fun{x:A}{t}}{\foralltype{x:A}{X}} }
  \and

  \Infer{$\Pi$I$\checks$}
        {
          \judgevtype{\Gamma}{A} \\ 
          \judgectype{\Gamma, x:A}{X} \\
          \judgecCheck{\Gamma, x:A}{t}{X} }
        { \judgecCheck{\Gamma}{\fun{x:A}{t}}{\pitype{x:A}{X}} }
  \and

  \Infer{$\Sigma$I$\checks$}
        { \judgevCheck{\Gamma}{v}{A} \\
          \judgevCheck{\Gamma}{w}{\subst{B}{x}{v}} \\
          \judgevtype{\Gamma}{\sigmatype{x:A}{B}} }
        { \judgevCheck{\Gamma}{\pair{v}{w}}{\sigmatype{x:A}{B}} }
   \and


  \Infer{$\Sigma$E}
        {
          \judgevInfer{\Gamma}{v}{\sigmatype{x:A}{B}} \\
          \judgectype{\Gamma, p : (\sigmatype{x:A}{B})}{X} \\
          \judgecCheck{\Gamma}{t}{\pitype{(x:A)(y:B)}{\subst{X}{p}{\pair{x}{y}}}}}
        { \judgecInfer{\Gamma}{\recsigma{v}{p.X}{t}}{\subst{X}{p}{v}}}
  \and

\end{mathpar}

\item[Equality]

\begin{mathpar}

  \Infer{$\mathsf{eq}$I}
  { \judgevInfer{\Gamma}{v}{A} }
  { \judgevInfer{\Gamma}{\refl{v}}{\eqtype{A}{v}{v}} }

  \and

  \Infer{$\mathsf{eq}$E$\checks$}
        { \judgevInfer{\Gamma}{v}{\eqtype{A}{w_1}{w_2}} \\
          \judgectype{\Gamma, x:A, p:\eqtype{A}{w_1}{x}}{X} \\
          \judgecCheck{\Gamma}{t}{\subst{\subst{X}{x}{w_1}}{p}{\refl{w_1}}}}
        { \judgecInfer{\Gamma}{\receq{v}{x.p.X}{t}}{\subst{\subst{X}{x}{w_2}}{p}{v}}}

\end{mathpar}

\item[Declarative Polymorphic Application]

\begin{mathpar}

  \Infer{$\Pi$E}
  {
    \judgecInfer{\Gamma}{t}{Y} \\
    \judgeApp{\Gamma}{Y}{v}{X} \\
  }
  { \judgecInfer{\Gamma}{t\,v}{X} }
  \and

  \Infer{$\forall$App}
  {
    \judgevCheck{\Gamma}{\mathcolorbox{pink}{w}}{A}\\
    \judgeApp{\Gamma}{\subst{X}{x}{\mathcolorbox{pink}{w}}}{v}{Y}
  }
  { \judgeApp{\Gamma}{\foralltype{x:A}{X}}{v}{Y} }
  \and

  \Infer{$\Pi$App}
  {
    \judgevCheck{\Gamma}{v}{A}
  }
  { \judgeApp{\Gamma}{\pitype{x:A}{X}}{v}{\subst{X}{x}{v}} }
  \and
  
\end{mathpar}

\item[Declarative Subtyping]
\label{sec:declarative-supbyping}

\begin{mathpar}
  \Infer{$\subt \Sigma$}
        {
          \judgevsubt{\Gamma}{A_1}{B_1}\\
          \judgevsubt{\Gamma, x:A_1}{A_2}{B_2}\\
        }
        {\judgevsubt{\Gamma}{\sigmatype{x:A_1}{A_2}}{\sigmatype{x:B_1}{B_2}}}

 \Infer{$\subt \Pi$}
       {
         \judgevsubt{\Gamma}{A_2}{A_1}\\
         \judgecsubt{\Gamma, x:A_2}{X_1}{X_2}\\
       }
       {\judgecsubt{\Gamma}{\pitype{x:A_1}{X_1}}{\pitype{x:A_2}{X_2}}}

       \Infer{$\subt$Var}
       { }
       {\judgevsubt{\Gamma}{a}{a}}

  \Infer{$\subt \ctov$}
        {
          \judgecsubt{\Gamma}{X_1}{X_2} \\
          \judgecsubt{\Gamma}{X_2}{X_1} \\
        }
        {\judgevsubt{\Gamma}{\comptoval{X_1}}{\comptoval{X_2}}}

  \Infer{$\subt \vtoc$}
        {
          \judgevsubt{\Gamma}{A_1}{A_2} \\
          \judgevsubt{\Gamma}{A_2}{A_1} \\
        }
        {\judgecsubt{\Gamma}{\valtocomp{A_1}}{\valtocomp{A_2}}}

  \Infer{$\subt$Eq}
        {
          \judgevsubt{\Gamma}{A}{B} \\
          \judgeequivuntg{\vars{\Gamma}}{v_1}{v_2} \\
          \judgeequivuntg{\vars{\Gamma}}{w_1}{w_2} \\
        }
        {\judgevsubt{\Gamma}{\eqtype{A}{v_1}{w_1}}{\eqtype{B}{v_2}{w_2}}}
      
  \Infer{$\forall \subt$}
        {
          \judgevCheck{\Gamma}{\mathcolorbox{pink}{v}}{A}\\
          \judgecsubt{\Gamma}{\subst{X}{x}{\mathcolorbox{pink}{v}}}{Y}
        }
        {\judgecsubt{\Gamma}{(\foralltype{x:A}{X})}{Y}}
        
  \Infer{$\subt \forall$}
        {
          \judgecsubt{\Gamma, y : A}{X}{Y}\\
        }
        {\judgecsubt{\Gamma}{X}{(\foralltype{y:A}{Y})}}

  \Infer{let$\subt$}
        {
          \bigstepsto{e}{\return{v}}\\
          \judgecsubt{\Gamma}{\subst{X}{x}{v}}{Y}\\
        }
        { \judgecsubt{\Gamma}{(\letval{x:A}{e}{X})}{Y}}
        
  \Infer{$\subt$let}
        {
          \bigstepsto{e}{\return{v}}\\
          \judgecsubt{\Gamma}{X}{\subst{Y}{y}{v}}\\
        }
        { \judgecsubt{\Gamma}{X}{(\letval{y:A}{e}{Y})}}

  \Infer{let$\subt$let}
        {
          \judgevsubt{\Gamma}{A}{B}\\
          \judgevsubt{\Gamma}{B}{A}\\
          \judgeequivuntg{\vars{\Gamma}}{e_1}{e_2}\\
          \judgecsubt{\Gamma, x:A}{X}{Y}\\
         }
        {
          \judgecsubt{\Gamma}{\letval{x:A}{e_1}{X}}{\letval{x:B}{e_2}{Y}}
        }
\end{mathpar}

\end{description}

\section{Algorithmic Type System}

In the declarative system, there are two places where the oracle is involved
(highlighted red): ($\forall \subt$) and ($\forall$App). To make the system
algorithmic, we must amend these rules.


\begin{definition}[Algorithmic Typing Context]
  \begin{mathpar}
    \begin{array}{llcl}

      \Theta & ::= & \emptyctx \bnfalt
                     \Theta,\, x:A \bnfalt
                     \Theta,\, \hat{x}:A \bnfalt
                     \Theta,\, \evarassign{\hat{x}}{v}:A
    \end{array}
  \end{mathpar}
\end{definition}



\begin{description}


\item[Algorithmic Polymorphic Application]

  \begin{mathpar}

    \Infer{$\forall$AppA}
    {
      \judgeAppAlg{\Theta_1, \hat{x}:A}{\subst{X}{x}{\hat{x}}}{v}{Y}{\Theta_2}
    }
    { \judgeAppAlg{\Theta_1}{\foralltype{x:A}{X}}{v}{Y}{\Theta_2} }
    \and

    \Infer{$\Pi$AppA}
    {
      \judgevCheckAlg{\Theta_1}{v}{A}{\Theta_2} 
    }
    { \judgeAppAlg{\Theta_1}{\pitype{x:A}{X}}{v}{\subst{X}{x}{v}}{\Theta_2} }
    \and
  \end{mathpar}
  
\item[Algorithmic Type Checking]

  \begin{mathpar}
    
    \Infer{$\csubt$}
    { \judgecInferAlg{\Theta_1}{t}{X}{\Theta_2} \\
      \judgeacsubt{\Theta_2}{X}{Y}{\Theta_3} \\
    }
    { \judgecCheckAlg{\Theta_1}{t}{Y}{\Theta_3} }
    \and

    \Infer{$\vsubt$}
    { \judgevInferAlg{\Theta_1}{v}{A}{\Theta_2} \\
      \judgeavsubt{\Gamma_2}{A}{B}{\Gamma_3} \\
    }
    { \judgevCheckAlg{\Theta_1}{v}{B}{\Theta_3} }
  \end{mathpar}
    


  

\item[Algorithmic Subtyping]
\label{sec:algorithmic-subtyping}

\begin{mathpar}

  \Infer{$\subt \Sigma$}
        {
          \judgeavsubt{\Gamma; E; \varphi}{A_1}{B_1}{\varphi'}\\ 
          \judgeavsubt{\Gamma, x:A_1; E; \varphi'}{A_2}{B_2}{\varphi''}\\
        }
        {\judgeavsubt{\Gamma; E; \varphi}{\sigmatype{x:A_1}{A_2}}{\sigmatype{x:B_1}{B_2}}{\varphi''}}

  \Infer{$\subt \Pi$}
        {
          \judgeavsubt{\Gamma; E; \varphi}{A_2}{A_1}{\varphi'}\\
          \judgeacsubt{\Gamma, x:A_2; E; \varphi'}{X_1}{X_2}{\varphi''}\\
        }
        {\judgeacsubt{\Gamma; E; \varphi}{\pitype{x:A_1}{X_1}}{\pitype{x:A_2}{X_2}}{\varphi''}}

  \Infer{$\subt \ctov$}
        {
          \judgeacsubt{\Gamma; E; \varphi}{X_2}{X_1}{\varphi'} \\
          \judgeacsubt{\Gamma; E; \varphi'}{X_1}{\ctxtapp{\varphi'}{X_2}}{\varphi''} \\
        }
        {\judgeavsubt{\Gamma; E; \varphi}{\comptoval{X_1}}{\comptoval{X_2}}{\varphi''}}

  \Infer{$\subt \vtoc$}
        {
          \judgeavsubt{\Gamma; E; \varphi}{A_2}{A_1}{\varphi'} \\
          \judgeavsubt{\Gamma; E; \varphi'}{\ctxtapp{\varphi'}{A_1}}{A_2}{\varphi''} \\
        }
        {\judgeacsubt{\Gamma; E; \varphi}{\valtocomp{A_1}}{\valtocomp{A_2}}{\varphi''}}
  
  \Infer{$\subt$Eq}
        {
          \judgeavsubt{\Gamma; E; \varphi}{A}{B}{\varphi'} \\
          \judgeunify{\vars{\Gamma}; E; \varphi'}{v_2}{v_1}{\varphi''} \\
          \judgeunify{\vars{\Gamma}; E; \varphi''}{w_2}{w_1}{\varphi'''} \\
        }
        {\judgevsubt{\Gamma}{\eqtype{A}{v_1}{w_1}}{\eqtype{B}{v_2}{w_2}}}

   \Infer{$\forall \subt$}
         {
           \judgeacsubt{\Gamma; E, (\mapentry{\hat{v}}{\vars{\Gamma}}); \varphi}
                       {\rename{X}{x}{\hat{v}}}
                       {Y}
                       {\varphi'}
         }
         {\judgeacsubt{\Gamma; E; \varphi}{(\foralltype{x:A}{X})}{Y}{\varphi'}}

   \Infer{$\subt \forall$}
         {
           \judgeacsubt{\Gamma, y : A; E; \varphi}{X}{Y}{\varphi'}\\
         }
         {\judgeacsubt{\Gamma; E; \varphi}{X}{(\foralltype{y:A}{Y})}{\varphi'}}

   \Infer{let$\subt$}
         {
           % {\color{blue} e \text{ and } A \text{ are ground}}\\
           \judgeequivuntg{\vars{\Gamma}}{e}{\return{v}}\\
           \judgeacsubt{\Gamma; E; \varphi}
                       {\subst{X}{x}{v}}{Y}{\varphi'}\\
         }
         { \judgeacsubt{\Gamma; E; \varphi}{(\letval{x:A}{e}{X})}{Y}{\varphi'}}

   \Infer{$\subt$let}
         {
           \judgeequivuntg{\vars{\Gamma}}{e}{\return{v}}\\
           \judgeacsubt{\Gamma; E; \varphi}
                       {X}
                       {\subst{Y}{y}{v}}
                       {\varphi'}\\
         }
         { \judgeacsubt{\Gamma; E; \varphi}{X}{(\letval{y:A}{e}{Y})}{\varphi'} }

   \Infer{let$\subt$let}
         {
           \judgeavsubt{\Gamma; E; \varphi}{B}{A}{\varphi_1}\\
           \judgeavsubt{\Gamma; E; \varphi_1}{\ctxtapp{\varphi_1}{A}}{B}{\varphi_2}\\
           \judgeunify{\vars{\Gamma};  E; \varphi_2}{e_1}{e_2}{\varphi_3}\\
           \judgeacsubt{\Gamma, x:{\color{blue} \ctxtapp{\varphi_1}{A}}; E; \varphi_3}{X}{Y}{\varphi_4}\\
         }
         {
           \judgeacsubt{\Gamma; E; \varphi}{\letval{x:A}{e_1}{X}}{\letval{x:B}{e_2}{Y}}{\varphi_4}
         }

\end{mathpar}

\end{description}




\section{The Safe Variable Invariant}

In \cref{sec:algorithmic-subtyping}, we will prove the exhaustiveness of the
algorithmic subtyping. For this purpose, we need to provide a certain
invariant of how the existential variables are distributed in the  well-formed types.



\begin{definition}[The Trace of the Term]
    Suppose $\rho$ is a term. 
    Let us define $\trace{\rho}$ as
    $$ \trace{\rho} = \ev{\nf{\rho}} $$
\end{definition}


\begin{definition}[The Contextual Background of the Term]
  Suppose $\Gamma$ is a context, $\rho$ is a term. 
  Let us define $\background{\Gamma}{\rho}$ as
  the minimal set of ground variables, such that
  \begin{enumerate}
  \item $\fv{\nf{\rho}} \setminus \ev{\nf{\rho}} \subseteq \background{\Gamma}{\rho}$
  \item if $x \in \background{\Gamma}{\rho}$ and $(x : \pi) \in \Gamma$ then
    $\fv{\nf{\pi}} \setminus \ev{\nf{\pi}} \subseteq \background{\Gamma}{\rho}$.
  \end{enumerate}
  Intuitively, we take an empty set,
  add all the non-existential variables of $\rho$ into it,
  and recursively repeat this process for the types of the added variables.
\end{definition}


\begin{definition}[The Contextual Trace of the Term]
  Suppose $\Gamma$ is a context, $\rho$ is a term. 
  Let us define $\tracecont{\Gamma}{\rho}$ as

  $$ \tracecont{\Gamma}{\rho} = \trace{\rho} \cup \bigcup_{(x :
    \pi) \leftarrow \Gamma,\,  x \leftarrow \background{\Gamma}{\rho}} \trace{\pi} $$

  \ilyam{the old definition:}
  {\color{red}
  $$ \tracecont{\Gamma}{\rho} = \trace{\rho} \cup \{\trace{\pi} \mid    (x :
  \pi) \leftarrow \Gamma,\,  x \leftarrow \fv{\nf{\rho}} \setminus \ev{\nf{\rho}}\}$$
  }
\end{definition}

\subsection{Trace Transferred from Types}

\begin{definition}[Reticent Terms Syntax]
  
\begin{mathpar}
  \begin{array}{llcl}
    \mbox{Reticent  Values} & r_v & ::= & \hat{x} \bnfalt \thunk{r_c}  
    \\[1em]
    \mbox{Reticent Computations} & r_c & ::= & \return{r_v} \bnfalt
                                               \letval{x:A}{t}{r_c} \bnfalt
                                               \dletval{x:A}{t}{r_c}
  \end{array}
\end{mathpar}

\end{definition}

\begin{proposition}[Inferred Types of Reticent Terms]
  \begin{mathpar}
    \Infer {}
    {\judgevInfer{\Gamma}{r_v}{A}}
    {r_v = \hat{x} ~ \text{ or } ~ A = \comptoval{X}}

    \Infer {}
    {\judgecInfer{\Gamma}{r_c}{X}}
    {X = \valtocomp{A} ~ \text{ or } ~ X = \letval{x:A}{t}{Y}}
  \end{mathpar}
\end{proposition}


\begin{lemma}[Inferred Types Trace]

  Intuitively, the non-reticent terms (contextually) expose the trace of the inferred types.
  \begin{mathpar}
    \Infer {}
    {
      \judgeSokterm{v}\\
      \judgevInfer{\Gamma}{v}{A}
    }
    {\trace{A} \subseteq \tracecont{\Gamma}{v} \text{ or } v = r_v}

    \Infer {}
    {
      \judgeSokterm{t}\\
      \judgecInfer{\Gamma}{t}{X}
    }
    {\trace{X} \subseteq \tracecont{\Gamma}{t} \text{ or } t = r_c}
  \end{mathpar}
\end{lemma}
\begin{proof}
  Mutual induction.
\end{proof}

\subsection{Trace Transferred from Context}

As the declarative type formation inference rules are intertwined with typing
and subtyping, the inductive proof forces us to augment the proved invariant.
Specifically, the invariant we are proving is spread across the following three
lemmas. The proof should be read as \emph{one mutual induction}.



\begin{lemma}[The Safe Variable Invariant for Type Formation]
  \label{lemma:type-formation-invariant}
  \begin{mathpar}
    \Infer{}
    {
      % \judgevtype{\Gamma}{A} \\
      \judgectype{\Gamma[\hat{x}:A]}{X} \\
      \judgeSOK{\hat{x}}{X}
    }
    {{\tracecont{\Gamma}{A}} \subseteq \tracecont{\Gamma}{X}}

    \Infer{}
    {
      % \judgevtype{\Gamma}{A} \\
      \judgevtype{\Gamma[\hat{x}:A]}{B} \\
      \judgeSOK{\hat{x}}{B}
    }
    {\tracecont{\Gamma}{A} \subseteq \tracecont{\Gamma}{B}}
  \end{mathpar}
\end{lemma}

\begin{lemma}[The Safe Variable Invariant for Typing]
  \label{lemma:typing-invariant}
  \begin{mathpar}
    \Infer{}
    {
      % \judgevtype{\Gamma}{A} \\
      \judgeSokterm{v}\\
      \judgevCheck{\Gamma[\hat{x}:A]}{v}{C} \\
      \judgeSOK{\hat{x}}{v}
    }
    {\tracecont{\Gamma}{{A}} \subseteq \tracecont{\Gamma}{v} \cup \tracecont{\Gamma}{{C}}}

    \Infer{}
    {
      % \judgevtype{\Gamma}{A} \\
      \judgeSokterm{e}\\
      \judgevCheck{\Gamma[\hat{x}:A]}{e}{Y} \\
      \judgeSOK{\hat{x}}{e}
    }
    {\tracecont{\Gamma}{{A}} \subseteq \tracecont{\Gamma}{{e}} \cup \tracecont{\Gamma}{{Y}}}

    \Infer{}
    {
      % \judgevtype{\Gamma}{A} \\
      \judgeSokterm{v}\\
      \judgevInfer{\Gamma[\hat{x}:A]}{v}{C} \\
      \judgeSOK{\hat{x}}{v}
    }
    {\tracecont{\Gamma}{{A}} \subseteq \tracecont{\Gamma}{{v}} \cup \tracecont{\Gamma}{C}}

    \Infer{}
    {
      % \judgevtype{\Gamma}{A} \\
      \judgeSokterm{e}\\
      \judgevInfer{\Gamma[\hat{x}:A]}{e}{Y} \\
      \judgeSOK{\hat{x}}{e}
    }
    {\tracecont{\Gamma}{{A}} \subseteq \tracecont{\Gamma}{{e}} \cup \tracecont{\Gamma}{{Y}}}
  \end{mathpar}
\end{lemma}


% \begin{lemma}[The Safe Varialbe Invariant for Typing]
%   \begin{mathpar}
%     \Infer{}
%     {\judgevtype{\Gamma}{A} \\ \judgevCheck{\Gamma, x:A}{v}{C} \\ \judgeSOK{x}{v}}
%     {\evok{\nf{A}} \subseteq \evok{\nf{C}}}

%     \Infer{}
%     {\judgevtype{\Gamma}{A} \\ \judgevCheck{\Gamma, x:A}{e}{Y} \\ \judgeSOK{x}{e}}
%     {\evok{\nf{A}} \subseteq \evok{\nf{Y}}}

%     \Infer{}
%     {\judgevtype{\Gamma}{A} \\ \judgevInfer{\Gamma, x:A}{v}{C} \\ \judgeSOK{x}{v}}
%     {\evok{\nf{A}} \subseteq \evok{\nf{C}}}
    
%     \Infer{}
%     {\judgevtype{\Gamma}{A} \\ \judgevInfer{\Gamma, x:A}{e}{Y} \\ \judgeSOK{x}{e}}
%     {\evok{\nf{A}} \subseteq \evok{\nf{Y}}}
%   \end{mathpar}
% \end{lemma}

\begin{lemma}[The Safe Variable Invariant for Subtyping]
  \label{lemma:subtyping-invariant}
  \begin{mathpar}
    \Infer{}
    {\judgevsubt{\Gamma}{A}{B}}
    {\tracecont{\Gamma}{{A}} = \tracecont{\Gamma}{{B}}}

    \Infer{}
    {\judgecsubt{\Gamma}{X}{Y}}
    {\tracecont{\Gamma}{{X}} \subseteq \tracecont{\Gamma}{{Y}}}
  \end{mathpar}
\end{lemma}

\begin{proof}[Proof of \cref{lemma:type-formation-invariant}]
  Mutual (with \cref{lemma:typing-invariant,lemma:subtyping-invariant})
  induction on the type formation judgement. 
  \begin{multicols}{2}
    \begin{description}
    \item[VarT] Holds vacuously, since $\hat{x} \notin^{!} a$. 
    % \item[$\vtoc$]
    %   \Infer{$\ctov$}
    %   \Infer{$\Pi$}
    %   \Infer{$\forall$}


    \end{description}
  \end{multicols}
\end{proof}

\begin{proof}[Proof of \cref{lemma:subtyping-invariant}]

  Mutual (with \cref{lemma:typing-invariant,lemma:type-formation-invariant}) induction on the subtyping judgement. 
  \begin{multicols}{2}
  \begin{description}
  \item[$\subt$Var] Trivial.
  \item[$\subt \Sigma$] By the induction hypothesis and congruence of $\ev{}$
    and $\nf{}$.
  \item[$\subt \Pi$] Similar to the $\subt \Sigma$ case. It is essential that
    the proved property is symmetrical for the value-subtyping.
  \item[$\subt \ctov$] By the induction hypothesis. The symmetry of the premise
    of the rule is essential.
  \item[$\subt \vtoc$] By the induction hypothesis. The symmetry of the premise
    is \emph{not} essential here.
  \item[$\subt$Eq] By the induction hypothesis and \cref{lemma:equiv-nf}.

  \item[$\subt \forall$] $\trace{{X}} \subseteq \trace{{Y}} \subseteq \trace{{\foralltype{y:A}{Y}}}$.
  \item[let$\subt$ and $\subt$let]
    After one evaluation step, the proven inclusion coincides with the induction hypothesis.
  \item[let$\subt$let] By congruence, the induction hypothesis, and \cref{lemma:equiv-nf}.
    % By the congruence of $\ev{}$ and $\evok{}$, the
    % induction hypothesis, and \cref{lemma:equiv-evok}, which implies that
    % $\evok{e_1} \subseteq \evok{e_2} \subseteq \ev{e_2}$.
\item[$\forall \subt$]
  \begin{alignat*}{2}
                  & \trace{{\foralltype{x:A}{X}}}    &  \text{(by congruence)}\\
     \subseteq{ } & \trace{{A}} \cup \trace{{X}}     &  \text{(by {\color{green}\cref{lemma:type-formation-invariant}}, because }\\
                  &                                  &  {\color{red}\judgectype{\Gamma, x:A}{X}} \text{)}\\
     \subseteq{ } & \trace{{X}}                      &  \\
     \subseteq{ } & \ev{\subst{(\nf{X})}{x}{\nf{v}}} &  \text{(by \cref{corollary:nf-subst-commute})}\\
     ={ }         & \trace{{(\subst{X}{x}{v})}}      &  \text{(by the IH)}\\
     \subseteq{ } & \trace{{Y}}      &  \\
    \end{alignat*}


    % $\ev{\nf{A}} \cup \ev{\nf{X}} \subseteq \ev{\nf{A}} \cup \ev{\subst{(\nf{X})}{x}{v}} =
    % \ev{\nf{A}} \cup \ev{\nf{(\subst{X}{x}{\nf{v}}))}
    % \subseteq \evok{A}
    % \cup \ev{Y}$. The latter inclusion holds by the induction hypothesis.
    % \ilyam{$\evok{A} \subseteq \evok{X}$ BY THE PARENT INDUCTION HYPOTHESIS!}
  \end{description}

\end{multicols}
\end{proof}


\printbibliography

\end{document}
