\documentclass[a4,natbib=false]{article}
\usepackage{fullpage}
\usepackage{amssymb}
\usepackage{amsmath,amsfonts,amsthm}
\usepackage{xcolor}
\usepackage{mathpartir}
\usepackage{cleveref}
\usepackage{multicol}
\usepackage{quiver}
\usepackage[inline, shortlabels]{enumitem}

\usepackage[colorinlistoftodos]{todonotes} 

\setlength{\columnsep}{1cm}
\let\citename\relax
\usepackage[natbib=true, abbreviate=false, dateabbrev=true, isbn=true, doi=false, urldate=comp, url=true, maxbibnames=9, maxcitenames=2, backref=false, backend=biber, style=alphabetic, language=american]{biblatex}
\addbibresource{biblio.bib}


\newtheorem{lemma}{Lemma}
\newtheorem{definition}{Definition}
\newtheorem{notation}{Notation}
\newtheorem{corollary}{Corollary}
\newtheorem{proposition}{Proposition}

%% \newcommand{\ilyam}[2][]{\todo[linecolor=red,backgroundcolor=red!25,bordercolor=red,#1]{I: #2}}
\newcommand{\ilya}[2][]{\todo[linecolor=red,backgroundcolor=red!25,bordercolor=red,inline,#1]{Ilya: #2}}
\newcommand{\ilyam}[1]{{\color{red} \texttt{Ilya:  #1}}}

%%
\newcommand{\bnfalt}{\;\;|\;\;}



% Now we give some commands to define the syntax of the language. 

\newcommand{\fun}[2]{\lambda {#1}.\,{#2}}


\newcommand{\letname}{\mathsf{let}}
\newcommand{\dletname}{\mathsf{dlet}}

\newcommand{\letval}[3]{\letname\; {#1} \,:=\, {#2} \;\mathsf{in}\; {#3}}
\newcommand{\dletval}[3]{\dletname\; {#1} \,:=\, {#2} \;\mathsf{in}\; {#3}}

\newcommand{\pair}[2]{\left\langle{#1}, {#2}\right\rangle}
\newcommand{\fst}[1]{\mathsf{fst}\,{#1}}
\newcommand{\snd}[1]{\mathsf{snd}\,{#1}}

\newcommand{\unit}{\langle\rangle}

\newcommand{\ctov}{\mathcal{U}}
\newcommand{\vtoc}{\mathcal{F}}

\newcommand{\unival}{\square^{v}}
\newcommand{\unicomp}{\square^{c}}

\newcommand{\vtype}{\mathsf{vtype}}
\newcommand{\ctype}{\mathsf{ctype}}

\newcommand{\comptoval}[1]{\downarrow \hspace{-2pt} #1}
\newcommand{\valtocomp}[1]{\uparrow \hspace{-2pt} #1}
\newcommand{\sigmatype}[2]{\Sigma {#1}.\,#2}
\newcommand{\pitype}[2]{\Pi {#1}.\,#2}
\newcommand{\foralltype}[2]{\forall {#1}.\,#2}
\newcommand{\eqtype}[3]{\mathsf{eq}{#1}\,{#2}\,{#3}}
\newcommand{\refl}{\mathsf{refl}}
\newcommand{\force}[1]{\mathsf{force}\,{#1}}
\newcommand{\return}[1]{\mathsf{return}\,{#1}}
\newcommand{\thunk}[1]{\{{#1}\}}

\newcommand{\recsigma}[3]{\mathsf{rec}_{\Sigma}^{#2}({#1},{#3})}
\newcommand{\receq}[3]{\mathsf{rec}_{\mathsf{eq}}^{#2}({#1},{#3})}

\newcommand{\subst}[3]{{#1}\{{#2}\,:=\,{#3}\}}

\newcommand{\subt}{\leqslant}
\newcommand{\vsubt}{\leqslant^v}
\newcommand{\csubt}{\leqslant^c}

\newcommand{\isvtype}[1]{{#1} \, \mathsf{vtype}}
\newcommand{\isctype}[1]{{#1} \, \mathsf{ctype}}

\newcommand{\ctxtapp}[2]{[{#1}] {#2}}
\newcommand{\evarassign}[2]{({#1} \mathsf{:=} {#2})}
\newcommand{\spcdot}{\mkern 2mu\cdot\mkern 2mu}
\newcommand{\emptyctx}{\spcdot}


\newcommand{\reduces}[2]{{#1} \rightarrow {#2}}
\newcommand{\contracts}[2]{{#1} \rightharpoonup {#2}}

\newcommand{\nattype}{\mathbb{N}}
\newcommand{\natzero}{\mathsf{0}}
\newcommand{\natsucc}[1]{\mathsf{succ}({#1})}
\newcommand{\recnat}[4]{\mathsf{rec}_{\nattype}^{#2}({#1},{#3},{#4})}

\newcommand{\narg}[1]{|{#1}|}


% This is a command to define a judgement -- we'll one command per judgement
% for delta-CBPV

\newcommand{\judge}[3]{{#1} \vdash {#2} : {#3}}
\newcommand{\judgectx}[2]{{#1} \vdash {#2}}


\newcommand{\checks}{{\color{blue} \Leftarrow}}
\newcommand{\infers}{{\color{brown} \Rightarrow}}

\newcommand{\judgec}[3]{{#1} \vdash_{c} {#2} : {#3}}
\newcommand{\judgecCheck}[3]{{#1} \vdash_{c} {#2} \, \checks \,  {#3}}
\newcommand{\judgecInfer}[3]{{#1} \vdash_{c} {#2} \, \infers \, {#3}}

\newcommand{\judgev}[3]{{#1} \vdash_{v} {#2} : {#3}}
\newcommand{\judgevCheck}[3]{{#1} \vdash_{v} {#2} \, \checks \, {#3}}
\newcommand{\judgevInfer}[3]{{#1} \vdash_{v} {#2} \, \infers \, {#3}}

\newcommand{\judgeInctx}[2]{{#1} \in {#2}}

\newcommand{\judgevtype}[2]{{#1} \vdash \isvtype{#2}}
\newcommand{\judgectype}[2]{{#1} \vdash \isctype{#2}}


\newcommand{\judgevsubt}[3]{{#1} \vdash {#2} \vsubt {#3}}
\newcommand{\judgecsubt}[3]{{#1} \vdash {#2} \csubt {#3}}

\newcommand{\judgeequiv}[4]{{#1} \vdash {#2} \equiv {#3} : {#4}}
\newcommand{\judgeequivunt}[2]{{#1} \equiv {#2}}

\newcommand{\judgeavsubt}[4]{{#1}\,{\color{purple}\vdash} {#2} \vsubt {#3} {\color{purple}\dashv}\,{#4}}
\newcommand{\judgeacsubt}[4]{{#1}\,{\color{purple}\vdash} {#2} \csubt {#3} {\color{purple}\dashv}\,{#4}}

\newcommand{\judgeunify}[4]{{#1}\,{\color{purple}\vdash} {#2} \equiv {#3} {\color{purple}\dashv}\,{#4}}

\newcommand{\judgeSnf}[1]{{#1}\,\mathsf{NF}}
\newcommand{\judgeSatom}[1]{{#1}\,\mathsf{ATOM}}
\newcommand{\judgeSinert}[1]{{#1}\,\mathsf{INERT}}
\newcommand{\judgeSok}[2]{{#1} \in {#2}\,\mathsf{OK}}
\newcommand{\judgeSokterm}[1]{{#1} \,\mathsf{OK}}

\newcommand{\judgeinst}[2]{{#1} \vdash {#2}}

\newcommand{\ctxtexdends}[2]{{#1} \subseteq {#2}}


\newcommand{\fv}[1]{\mathsf{FV}(#1)}

\newcommand{\fullterm}[2]{{#1}\,#2_1 \dots #2_{\narg{#1}}}

% This is a command to define an inference rule. The optional argument to
% \inferrule* is the label for the rule. 
% 
\newcommand{\Infer}[3]{\inferrule*[right={#1}]{#2}{#3}}

\newcommand\declareop[3]{%
  \newcommand#1{%
    \mskip\muexpr\medmuskip*#2\relax
    {#3}%
    \mskip\muexpr\medmuskip*#2\relax
  }}

\declareop\inc{3}{\mathrel{+}=}



\begin{document}

\section{Syntax}

\begin{definition}[Syntax of terms]
  \label{def:syntax}

  We write \emph{term} meaning a computation or a value, denoting it $\sigma$ or $\tau$.

\begin{mathpar}
  \begin{array}{llcl}
    \mbox{Computations} & X, Y, t, u & ::= & t v \bnfalt
    \valtocomp{A} \bnfalt \pitype{x:A}{X} \bnfalt \foralltype{x:A}{X} \bnfalt \force {v} \bnfalt \return{v}
    \bnfalt \fun{x:A}{t} \bnfalt \\ & & & \letval{x : A}{t}{u} \bnfalt
    \dletval{x : A}{t}{u} \bnfalt \recsigma{v}{X}{t} \bnfalt \receq{v}{X}{t}
    \\[1em]

    \mbox{Values} & A, B, v, w & ::= & x \bnfalt \comptoval{X}
    \bnfalt \sigmatype{x:A}{B} \bnfalt \refl \bnfalt \eqtype{A}{v}{w} \bnfalt
    \thunk{t} \bnfalt \pair{v}{w} \\[1em]

    % \mbox{Contexts} & \Gamma & ::= & \emptyctx \bnfalt \Gamma, x:A \bnfalt \Gamma, \isvtype{B} \\[1em]
  \end{array}
\end{mathpar}

\end{definition}

We use different non-terminal symbols to emphasize the distinction between type-level terms
and term-level terms, which manifests properly in \cref{sec:rules}.
The upper-case literals represent type-terms, and the lower-case
represent term-terms (which can be typed with some type-terms)
with one exception: in $\letval{x : A}{t}{u}$,
$u$ can represent a type-term.

\section{Computational form of the terms}

Let us consider the term syntax from a different perspective:

\begin{definition}[Computational syntax of terms]
  \label{def:comp-syntax}


\begin{mathpar}
  \begin{array}{llcl}
    \mbox{Constructors} & C & ::= & \lambda x \bnfalt (,) \bnfalt \refl \bnfalt \return{} \bnfalt \thunk{} 
    \\[1em]
    \mbox{Eliminators} & E & ::= & @ \bnfalt \recsigma{}{}{} \bnfalt \receq{}{}{}
                                   \bnfalt \letname \bnfalt \dletname
                                   \bnfalt \force{}
    \\[1em]

    \mbox{Neutral Formers} & N & ::= & \comptoval \bnfalt \Pi x \bnfalt \forall x \bnfalt
                                       \valtocomp{} \bnfalt \Sigma x \bnfalt x
    \\[1em]

    \mbox{Formers} & F & ::= & C \bnfalt E \bnfalt N
    \\[1em]

    \mbox{Terms} & \sigma, \tau, \nu & ::= & \fullterm{F}{\tau}
  \end{array}
\end{mathpar}
Here $\narg{F}$ designates the number of the arguments of the term former $F$.
\ilyam{todo: table for \narg{F}}.
\end{definition}

It is easy to see that the syntax of \emph{terms} from \cref{def:syntax} defines
the \emph{subset} of terms defined by \cref{def:comp-syntax}. In fact, any
\emph{well-typed} term must have a form defined by \cref{def:syntax}. We will
use these two representation interchangeably.

\section{Reduction}

First, we define the \emph{redex contraction}.
\begin{definition}[Redex Contraction]
  \label{def:redex-contr}
  We define the top-level redex contraction in the following way:
  \begin{multicols}{2}
    \begin{itemize}

    \item $\contracts{(\fun{x:\nu}{\sigma})\tau}{\subst{\sigma}{x}{\tau}}$
      
    \item $\contracts{\letval{x:\nu}{\return{\sigma}}{\tau}}{\subst{\tau}{x}{\sigma}}$

    \item $\contracts{\dletval{x:\nu}{\return{\sigma}}{\tau}}{\subst{\tau}{x}{\sigma}}$

    \item $\contracts{\force{\thunk{\tau}}}{\tau}$

    \item $\contracts{\recsigma{\pair{\tau_1}{\tau_2}}{\nu}{\sigma}}{\sigma \,
        \tau_1 \, \tau_2}$

    \item $\contracts{\receq{\refl}{\nu}{\tau}}{\tau}$

    \end{itemize}
  \end{multicols}

  The terms on the left hand side of $\contracts{\spcdot}{\spcdot}$ are called \emph{redexes}.
  
\end{definition}

Notice that any redex from \cref{def:redex-contr} is an elimination of a
constructor, i.e. a term of the form $E\,(\fullterm{C}{\sigma})\, \tau_2 \dots
\tau_{\narg{E}}$ where $E$ and $C$ are ``matched''.
Vice versa, if a term of the form
$E\,(\fullterm{C}{\sigma})\, \tau_2 \dots \tau_{\narg{E}}$ is
\emph{well-typed}, it is a redex. 


Informally, reduction of a term $\tau$ is a redex contraction happening in some
\emph{subterm} of $\tau$.

\begin{definition}[Reduction]
  \begin{mathpar}
    \Infer{Redex}{\contracts{\tau}{\tau'}}{\reduces{\tau}{\tau'}}
    \and
    \Infer{Cong$^F_i$}{\reduces{\tau_i}{\tau_i'}}
    {\reduces
      {F\,\tau_1\dots\tau_i\dots\tau_{\narg{F}}}
      {F\,\tau_1\dots\tau_i'\dots\tau_{\narg{F}}}}
  \end{mathpar}

\end{definition}

\begin{lemma}[Substitution preserves reduction]
  \label{lemma:subst-res}

  \ilyam{Functoriality of the substitution?}
  \begin{mathpar}
    \Infer{}
    {\reduces{\tau}{\tau'}}
    {\reduces{\subst{\tau}{x}{\sigma}}
      {\subst{\tau'}{x}{\sigma}}}
  \end{mathpar}
\end{lemma}
\begin{proof}
  Induction on $\reduces{\tau}{\tau'}$. Substitution is congruent, therefore,
  the induction goes down to the redexes.

  \begin{itemize}
    \item
  Suppose that
  $\reduces{(\fun{x:\nu}{\sigma})\sigma'}{\subst{\sigma}{x}{\sigma'}}$.
  We need to prove that
  $\reduces{\subst{(\fun{x:\nu}{\sigma})\sigma'}{y}{\tau}}{\subst{\subst{\sigma}{x}{\sigma'}}{y}{\tau}}$.
  We know that $\subst{(\fun{x:\nu}{\sigma})\sigma'}{y}{\tau} =
  (\fun{x:\nu}{\subst{\sigma}{y}{\tau}})(\subst{\sigma'}{y}{\tau})$,
  which reduces to
  $\subst{\subst{\sigma}{y}{\tau}}{x}{\subst{\sigma'}{y}{\tau}}$. But
  $$\subst{\subst{\sigma}{y}{\tau}}{x}{\subst{\sigma'}{y}{\tau}} =
  \subst{\subst{\sigma}{x}{\sigma'}}{y}{\tau},$$
  assuming that $x \notin \fv{\tau}$, which is guaranteed because the
  substitution is capture-avoiding. 

  \item
    The other cases are similar or straightforward
  \end{itemize}
\end{proof}

\section{Normal Form}

Using the syntax from \cref{def:comp-syntax}, it is convenient to express
computational properties of the term, e.g. being in the normal form
($\mathsf{NF}$).

\begin{definition}[Normal Form]
\begin{mathpar}
  \Infer{}{\judgeSatom{\tau}}{\judgeSnf{\tau}}
  \and
  \Infer{}{\judgeSnf{\tau_{1}}~\dots~\judgeSnf{\tau_{\narg{C}}}}{\judgeSnf{\fullterm{C}{\tau}}}
  \and
  \Infer{}{\judgeSnf{\tau_{1}}~\dots~\judgeSnf{\tau_{\narg{N}}}}{\judgeSatom{\fullterm{N}{\tau}}}
  \and
  \Infer{}{\judgeSatom{\tau_1}\\\judgeSnf{\tau_2}~\dots~\judgeSnf{\tau_{\narg{E}}}}{\judgeSatom{\fullterm{E}{\tau}}}
\end{mathpar}
\end{definition}

The intuition is that
\begin{enumerate*}
\item[(i)] normal terms are not reducible;
\item[(ii)] atomic terms are not reducible and, in addition, do not cause
  reduction when the eliminators are applied to them.
\end{enumerate*}

Although it is easy to see that the terms in normal form are not reducible,
the opposite is only true for the well-typed terms:

\begin{proposition}[Normal form and irreducibility]
  \begin{mathpar}
    \Infer{}{\judgeSnf{\tau}}{\nexists \tau', \reduces{\tau}{\tau'}}
    \and
    \Infer{}{\tau \text{ is well-typed } \\ \nexists \tau', \reduces{\tau}{\tau'}}{\judgeSnf{\tau}}
  \end{mathpar}
\end{proposition}

Hereafter, we assume all the terms are well typed.
\ilyam{Well-typedness is required for the unification and equivalence to be
  well-founded (otherwise induction is not possible). TODO: normalization (halting)!}

% \begin{definition}[Syntactic normal form]
%   We say that the term $\tau$ is in the syntactic
%   normal form if and only if it is formed by the following grammar:

%   \begin{mathpar}
%     \begin{array}{llcl}
%       \mbox{Normal Computations} & t_n, X_n & ::= &
%       \fun{x:A_n}{t_n} \bnfalt
%       \return{v_n} \bnfalt
%       t_a
%       \\[1em]

%       \mbox{Atomic Computations} & t_a & ::= &
%                                                \force{v_a} \bnfalt
%       t_a v_n \bnfalt
%       \recsigma{v_a}{X_n}{t_n} \bnfalt
%       \receq{v_a}{X_n}{t_n} \bnfalt \\ &&& 
%       \letval{x : A_n}{t_a}{t_n} \bnfalt
%       \dletval{x : A_n}{t_a}{t_n} \\ &&&
%       \valtocomp{A_n} \bnfalt
%       \pitype{x:A_n}{X_n} \bnfalt
%       \foralltype{x:A_n}{X_n}
%       \\[1em]

%       \mbox{Normal Values} & v_n, A_n & ::= &
%       \pair{v_n}{v_n} \bnfalt
%       \thunk{t_n} \bnfalt
%       \refl \bnfalt
%       v_a
%       \\[1em]

%       \mbox{Atomic Values} & v_a & ::= & x \bnfalt \\ &&& \comptoval{X_n} \bnfalt
%                                          \sigmatype{x:A_n}{A_n} \bnfalt \eqtype{A_n}{v_n}{v_n}
%       \\[1em]

%     \end{array}
%   \end{mathpar}
% \end{definition}


\section{Safe Occurrence}

Another important property that we express in this syntax is \emph{safe
  occurrence of the variable}. The judgement $\judgeSok{x}{\tau}$ means $x$
occurs safely in $\tau$.

Ideally, we would like to forbid the situations when \emph{in some normal form}
of $\tau$, some instantiation of $x$ generates a new redex. In other words, we
would like to ensure that
\emph{all normal forms} of $\tau$ do not contain $E \, x \, \tau_2 \dots
\tau_{\narg{E}}$ as a subterm.

However, this property is undecidable by Rice's theorem: notice that
\begin{enumerate*}

\item[(i)] we do not require terms to have types at this stage, thus, the
  system is Turing complete;

\item[(ii)] the property is non-trivial;

\item[(iii)] the property judges about the normal forms and thus, is invariant
  under ``algorithmic equivalence''.
\end{enumerate*}
As it is undecidable, it is impossible to express this judgement using
well-founded inference rules (i.e. unambiguously generating finite trees).

Since precise syntactic representation of this property is impossible, we
under-approximate this property in the following way:

\begin{mathpar}
  \Infer{C-Cong}{\judgeSok{x}{\tau_{1}}~\dots~\judgeSok{x}{\tau_{\narg{C}}}}{\judgeSok{x}{\fullterm{C}{\tau}}}
  \and
  \Infer{N-Cong}{\judgeSok{x}{\tau_{1}}~\dots~\judgeSok{x}{\tau_{\narg{N}}}}{\judgeSok{x}{\fullterm{N}{\tau}}}
  \and
  \Infer{E-FV}{x \notin \fv{\fullterm{E}{\tau}}}{\judgeSok{x}{\fullterm{E}{\tau}}}
  \and
  \Infer{E-Cong}
  {\judgeSok{x}{\tau_{1}}~\dots~\judgeSok{x}{\tau_{\narg{E}}}
    \\ 
    \tau_1 \neq x
    \\ 
    \judgeSinert{\fullterm{E}{\tau}}
  }
  {\judgeSok{x}{\fullterm{E}{\tau}}}
\end{mathpar}
In the last rule, ``$\tau_1 \neq x$'' means literal syntactic inequality.
Intuitively, ``$\judgeSinert{\tau}$'' means that $\tau$ preserves its
top-level structure under the reduction, i.e. the reduction always happens in
the subterms of $\tau$ but never on the top-level. In fact, the relation we
define is a little bit stronger, as it also forbids changing of the structure 
of the eliminator's first argument. Formally, it is defined as follows:

\begin{mathpar}
  \Infer{}{ }{\judgeSinert{\fullterm{N}{\tau}}}
  \and
  \Infer{}{ }{\judgeSinert{\fullterm{C}{\tau}}}
  \and
  \Infer{}{ }{\judgeSinert{E\,(\fullterm{N}{\sigma})\,\tau_2 \dots \tau_{\narg{E}}}}
  \and
  \Infer{EE-Inert}
  {\judgeSinert{\fullterm{E'}{\sigma}}}
  {\judgeSinert{E\,(\fullterm{E'}{\sigma})\,\tau_2 \dots \tau_{\narg{E}}}}
\end{mathpar}

As a heuristics, it is possible to extend the ``Safe Occurrence'' property by
injecting some of the redex contractions from \cref{def:redex-contr} into the
inference system. Notice that only non-substituting contractions are allowed
because the latter would violate the finiteness of the inference trees.

\begin{mathpar}
  \Infer{}
  {\judgeSok{x}{\tau}}
  {\judgeSok{x}{\force{\thunk{\tau}}}}
  \and
  \Infer{}
  {
    \judgeSok{x}{{@\, (@\, \sigma \, \tau_1)\, \tau_2}} \\
    \judgeSok{x}{\tau'} \\
  }
  {\judgeSok{x}{
      \recsigma{\pair{\tau_1}{\tau_2}}{\tau'}{\sigma}}
  }
  \and
  \Infer{}
  {
    \judgeSok{x}{\sigma} \\
    \judgeSok{x}{\tau} \\
  }
  {\judgeSok{x}{
      \receq{\refl}{\sigma}{\tau}}
  }
\end{mathpar}


\begin{lemma}[Conguence of the safe occurrence]
  \label{lemma:cong-safe-occurrence}
  \begin{mathpar}
  \Infer{}
  {
    \judgeSok{x}{\fullterm{F}{\sigma}}
  }
  {
    \judgeSok{x}{\sigma_1} \\
    \cdots \\
    \judgeSok{x}{\sigma_{\narg{F}}}
  }
  \end{mathpar}
\end{lemma}
\begin{proof}
  Trivial induction.
\end{proof}


\begin{lemma}[Reduction-Substitution Commutativity]
  \begin{mathpar}
    \Infer{}
    {
      \judgeSok{x}{\sigma}\\
      \judgeSnf{\tau}\\
      \reduces{\subst{\sigma}{x}{\tau}}{\sigma'}\\
    }
    {\exists \sigma^* \text{ s.t. } \reduces{\sigma}{\sigma^*} \text{ and } \subst{\sigma^*}{x}{\tau} = \sigma' }
  \end{mathpar}

  Or in the commutative diagram form: 
    if $\judgeSok{x}{\sigma}$ and $\judgeSnf{\tau}$ then
    \begin{tikzcd}
        \sigma & {\sigma^*} \\
        \bullet & {\sigma'}
        \arrow["{{x:=\tau}}"', from=1-1, to=2-1]
        \arrow["\rightarrow"', from=2-1, to=2-2]
        \arrow["\rightarrow", dashed, from=1-1, to=1-2]
        \arrow["{x := \tau}", dashed, from=1-2, to=2-2]
      \end{tikzcd}
\end{lemma}

\begin{proof}
  Let us destruct the substitution $\subst{\sigma}{x}{\tau}$. Notice that
  $\sigma \neq x$ because $\subst{x}{x}{\tau} = \tau \nrightarrow \spcdot$. It
  means that the substitution is performed by congruence: $\sigma =
  \fullterm{F}{\sigma}$ (for some $F \neq x$), and $\subst{\sigma}{x}{\tau} =
  F\, (\subst{\sigma_1}{x}{\tau}) \dots (\subst{\sigma_{\narg{F}}}{x}{\tau}) $.
  Notice that $\judgeSok{x}{\sigma_i}$ for $i = 1 \dots \narg F$ by
  \cref{lemma:cong-safe-occurrence}.

  Induction on $\reduces{\subst{\sigma}{x}{\tau}}{\sigma'}$.
  The reduction step can be justified either by the congruence or the redex contraction.
  \begin{itemize}
  \item If the reduction step is done by congruence, then the required
    $\sigma^*$ is of the form $\fullterm{F}{\sigma^*}$ where $\sigma^*_1 \dots
    \sigma^*_{\narg{F}}$ are constructed by the straightforward application of
    the induction hypothesis to $\sigma_1 \dots \sigma_{\narg{F}}$.

  \item If the reduction is the top-level redex contraction, then
    $\subst{\sigma}{x}{\tau}$ is a redex, i.e. $F$ is an eliminator $E$ and
    $\subst{\sigma_1}{x}{\tau}$ is formed by a constructor $C$.
    Notice that because
    $\judgeSok{x}{\fullterm{E}{\sigma}}$, $\sigma_1
    \neq x$. Therefore, the substitution $\subst{\sigma_1}{x}{\tau}$ is also done by
    congruence: $\sigma_1 = \fullterm{C}{\zeta}$ and thus,
    $\sigma = E \, (\fullterm{C}{\zeta}) \, \sigma_2 \dots \sigma_{\narg{E}}$.

    Let us destruct $\judgeSok{x}{\sigma}$. Since $\sigma$ is not inert, either
    \begin{enumerate*}
      \item[(i)] $x \notin \fv{\sigma}$, then the substitution is the identity, and we
        can take $\sigma^* = \sigma'$); or
      \item[(ii)] one of the ``additional'' rules is applied to get
        $\judgeSok{x}{\sigma}$. In all of these three cases, we can perform the
        same top-level redex contraction to acquire $\sigma^*$. This operation
        commutes with substitution because all it does is restructuring the
        top-level form of $\sigma$ without changing the subterms $\zeta_1,
        \dots, \zeta_{\narg{C}}, \sigma_2, \dots, \sigma_{\narg{E}}$, thus, the
        required property holds.

        \ilyam{to be fair, the beta-reduction also commutes with the
          substitution, but we still need the inertness so that OK is preserved
          under reduction.}
        
    \end{enumerate*}
  \end{itemize}
\end{proof}


\begin{lemma}[Inertness preservation]
  \label{lemma:inertness-pres}
  \begin{mathpar}
    \Infer{}{\judgeSinert{\tau} \\ \reduces{\tau}{\tau'}}{\judgeSinert{\tau'}}
  \end{mathpar}
\end{lemma}

\begin{proof}
  Induction on $\judgeSinert{\tau}$.
\end{proof}


\begin{lemma}[Safe occurrence preservation]
  \begin{mathpar}
    \Infer{}{\judgeSok{x}{\tau} \\ \reduces{\tau}{\tau'}}{\judgeSok{x}{\tau'}}
  \end{mathpar}
\end{lemma}

\begin{proof}
  Induction on $\judgeSok{x}{\tau}$.
  \begin{itemize}
    \item For C-Cong (N-Cong), we apply the induction hypothesis and C-Cong (N-Cong, resp.).
    \item For E-FV, notice that the reduction does not increase the set of free variables,
      and thus, E-FV is applicable after the reduction of one of the $\tau_i$.
    \item The E-Cong case is a little bit more complicated.
      Notice that $\tau_1 \nrightarrow x$. This is because if $\tau_1$ is an
      eliminator, it must be inert by EE-Inert.
      Then we can consider in which $\tau_i$ the reduction happened, 
      apply the induction hypothesis and \cref{lemma:inertness-pres}.
    \item For the additional rules, the reduction can be either by congruence
      (and then we apply the induction hypothesis,
      \cref{lemma:cong-safe-occurrence} and the same rule) or by the
      top-level redex contraction, and then the required property is exactly one
      of the premises.
  \end{itemize}

\end{proof}

\section{Equivalence and Unification}

\begin{definition}[Syntax of algorithmic terms]
  \label{def:alg-terms}
  Throughout the algorithm, we will use the auxiliary pre-cooked terms,
  containing some unassigned parts. For this purpose, we extend the syntax of
  terms (\cref{def:syntax}) by adding the ``hatted'' unification (existential)
  variables $\hat{x}$ to the set of values:
  $$\mbox{Values} \inc \hat{x}$$
  Similarly, we extend the syntax from \cref{def:comp-syntax} by adding
  $\hat{x}$ to the Neutral Formers:
  $$\mbox{Neutral Formers} \inc \hat{x}$$
\end{definition}

\begin{notation}
To denote that the term is algorithmic, i.e. potentially contains the
unification variables, we use $\pi$ and $\rho$. If the term does not contain the
unification variables it is called \emph{ground} and denoted as $\sigma$ and
$\tau$.
\end{notation}

\begin{definition}[Equivalence]
  We define equivalence on ground terms:

  \begin{itemize}

  \item[Reduction closure]
    \begin{mathpar}
      \Infer{}
      {
        \reduces{\tau_1}{\tau_1'}\\
        \judgeequivunt{\tau_1'}{\tau_2}
      }
      {
        \judgeequivunt{\tau_1}{\tau_2}
      }
      \and
      \Infer{}
      {
        \reduces{\tau_2}{\tau_2'}\\
        \judgeequivunt{\tau_1}{\tau_2'}\\
        \judgeSnf{\tau_1}
      }
      {
        \judgeequivunt{\tau_1}{\tau_2}
      }
    \end{mathpar}

  \item[Congruence]
    \begin{mathpar}

      \Infer{}
      {
        \judgeequivunt{\sigma_1}{\tau_1} \\
        \dots\\
        \judgeequivunt{\sigma_{\narg{F}}}{\tau_{\narg{F}}} \\
        \judgeSnf{\fullterm{F}{\sigma}} \\
        \judgeSnf{\fullterm{F}{\tau}}
      }
      {
        \judgeequivunt{\fullterm{F}{\sigma}}{\fullterm{F}{\tau}}
      }
    \end{mathpar}

  \end{itemize}

\end{definition}

The unification (or algorithmic equivalence) judgement is of the form
$\judgeunify{\varphi}{\rho}{\rho'}{\varphi'}$ where $\rho$ and $\rho'$ are
algorithmic terms (potentially with unassigned variables), $\varphi$ and
$\varphi'$ are contexts formed by the following grammar:
\begin{definition}[Unification Context] Unification context is a \emph{set} of
  pairs: 
$$\varphi, \psi ::= \emptyctx \bnfalt \varphi, \evarassign{\hat{v}}{\tau} $$
where $\tau$ is a ground term.
\end{definition}

% \begin{definition}[Instantiation of an algorithmic term]
%   We say that a context $\varphi$ instantiates algorithmic term $\rho$ if it
%   contains an assignment for every existential variable of $\rho$ :
%   \begin{mathpar}
%     \Infer{}
%     {
%     }
%     {
%       \judgeinst{\varphi, \evarassign{\hat{x}}{\spcdot}}{\hat{x}}
%     }
%     \and
%     \Infer{}
%     {
%       \judgeinst{\varphi}{\hat{x}}
%     }
%     {
%       \judgeinst{\varphi, \evarassign{\spcdot}{\spcdot}}{\hat{x}}
%     }
%     \and
%     \Infer{}
%     {
%       F \neq \hat{x}\\
%       \judgeinst{\varphi}{\rho_1}\\
%       \dots\\
%       \judgeinst{\varphi}{\rho_{\narg{F}}}\\
%     }
%     {
%       \judgeinst{\varphi}{\fullterm{F}{\rho}}
%     }

%   \end{mathpar}
% \end{definition}

\begin{definition}[Well-formed unification context]
  We say that a unification context $\varphi$ is well-formed if the mapping it
  represents is a partial function, whose image terms are normal and ground:
  \begin{mathpar}

    \Infer{}
    { }
    {
      \judgectx{ }{\emptyctx}
    }
    \and
    \Infer{}
    { 
    \judgectx{ }{\varphi} \\
    \evarassign{\hat{x}}{\spcdot} \notin \varphi \\
    \judgeSnf{\tau}
    }
    {
      \judgectx{ }{\varphi, \evarassign{\hat{x}}{\tau}}
    }
  \end{mathpar}
\end{definition}

\begin{definition}[Application of the well-formed context]
  If the unification context $\Omega$ is well-formed,
  We write $\ctxtapp{\Omega}{\tau}$ meaning the application of the partial
  (substitution) function represented by $\Omega$ to the term $\tau$:
  \begin{itemize}
  \item $\ctxtapp{\emptyctx}{\tau} = \tau$
  \item $\ctxtapp{\Omega, \evarassign{\hat{x}}{\sigma}}{\tau} = \subst{(\ctxtapp{\Omega}{\tau})}{\hat{x}}{\sigma}$
  \end{itemize}

\end{definition}

\begin{definition}[Unification]  The unification algorithm is defined
  as follows:

\begin{itemize}
    \item[Base rules]
      \begin{mathpar}
        \Infer{}
        { 
          \evarassign{\hat{v}}{\spcdot} \notin \varphi \\
          \judgeSnf{\tau}
        }
        {
          \judgeunify{\varphi}{\hat{v}}{\tau}{\varphi, \evarassign{\hat{v}}{\tau}}
        }
        \and
        \Infer{}
        { 
          \evarassign{\hat{v}}{\tau} \in \varphi
        }
        {
          \judgeunify{\varphi}{\hat{v}}{\tau}{\varphi}
        }
      \end{mathpar}

    \item[Reduction closure]
      \begin{mathpar}
        \Infer{}
        {
          \reduces{\rho_1}{\rho_1'}\\
          \judgeunify{\varphi}{\rho_1'}{\tau_2}{\varphi'}
        }
        {
          \judgeunify{\varphi}{\rho_1}{\tau_2}{\varphi'}
        }
        \and
        \Infer{}
        {
          \reduces{\tau_2}{\tau_2'}\\
          \judgeunify{\varphi}{\rho_1}{\tau_2'}{\varphi'}\\
          \judgeSnf{\rho_1}
        }
        {
          \judgeunify{\varphi}{\rho_1}{\tau_2}{\varphi'}
        }
      \end{mathpar}

    \item[Congruence]
   \begin{mathpar}

     \Infer{}
     {
       \judgeunify{\varphi_0}{\rho_1}{\tau_1}{\varphi_1} \\
       \dots\\
       \judgeunify{\varphi_{\narg{F}-1}}{\rho_{\narg{F}}}{\tau_{\narg{F}}}{\varphi_{\narg{F}}} \\
       \judgeSnf{\fullterm{F}{\rho}} \\
       \judgeSnf{\fullterm{F}{\tau}}
     }
     {
       \judgeunify{\varphi_0}{\fullterm{F}{\rho}}{\fullterm{F}{\tau}}{\varphi_{\narg{F}}}
     }
\end{mathpar}

\end{itemize}
\end{definition}


We prove the soundness and completeness of the unification w.r.t. the equality
defined above. Intuitively, soundness means that the output context produced by
the unification algorithm does not make the terms non-unifiable.

\begin{lemma} [Unification soundness]
  \begin{mathpar}
    \Infer{}
    { \judgectx{}{\varphi_1}\\
      \judgeunify{\varphi_1}{\rho}{\tau}{\varphi_2} \\
    }
    { \judgectx{}{\varphi_2}\\
      \judgeequivunt{\ctxtapp{\varphi_2}{\rho}}{\tau} \\
    }
  \end{mathpar}
\end{lemma}


\begin{definition}[Safe algorithmic term]
  We say that the algorithmic term $\rho$ is \emph{safe} iff 
  all the unification variables occur safely in it:
  \begin{mathpar}
    \Infer{}
    {\forall \hat{x},~ \judgeSok{\hat{x}}{\rho}}
    {\judgeSokterm{\rho}}
  \end{mathpar}

\end{definition}

\begin{lemma} [Unification completeness]
  \begin{mathpar}
    \Infer{}
    { \judgectx{}{\Omega}\\
      \judgeSokterm{\rho}\\
      \judgeequivunt{\ctxtapp{\Omega}{\rho}}{\tau}\\
    }
    {
      \forall \varphi \subseteq \Omega. ~ \exists \psi \subseteq \Omega. ~
      \judgeunify{\varphi}{\rho}{\tau}{\psi} \\
    }
  \end{mathpar}

\end{lemma}

% \begin{lemma} [Unification completeness]
%   If $\varphi(\rho)$ or $\varphi(\rho')$ is ground and 
%   $\judgeunify{\varphi}{\rho}{\rho'}{\varphi'}$ holds, then $\varphi'(\rho)$
%   and $\varphi'(\rho')$ are ground.
% \end{lemma}
% \ilyam{There might be some problems with the meaningless existential variables}




\section{Typing}
\label{sec:rules}


\begin{definition}[Typing declarative context]
\begin{mathpar}
  \begin{array}{llcl}

    \mbox{Contexts} & \Gamma & ::= & \emptyctx \bnfalt \Gamma, x:A \bnfalt \Gamma, \isvtype{B} \\[1em]
  \end{array}
\end{mathpar}
\end{definition}


To make the typing decidable, we restrict the system in several ways. In particular,
when we form $\foralltype{x:A}{X}$, we require $x$ to belong to $\fv{X}$ and occur
safely in $X$.

\subsection{Context Well-formedness}

\begin{mathpar}
  \Infer{Ctx0}
        { }
        { \judgectx{}{\emptyctx}}

        \and
 \Infer{CtxIT}
       { \judgectx{ }{\Gamma} }
       { \judgectx{ }{\Gamma,\isvtype{x}}}

       \and
 \Infer{CtxI}
       { \judgevtype{\Gamma}{A} \\
         \judgectx{ }{\Gamma} }
       { \judgectx{ }{\Gamma,x:A}}
\end{mathpar}

\subsection{Context Formation and Var}
Here, $j$ denotes the context entry: either $(x : A)$ or $(\isvtype{x})$.

\begin{mathpar}

\Infer{CtxExt}
      { \judgeInctx{j}{\Gamma} }
      { \judgeInctx{j}{(\Gamma, y:B)} }
\and

\Infer{CtxExtT}
      { \judgeInctx{j}{\Gamma} }
      { \judgeInctx{j}{(\Gamma, \isvtype{B})} }
\and

\Infer{CtxInit}
      {  }
      { \judgeInctx{j}{(\Gamma, j)} }
\and

\Infer{Var}
      { \judgeInctx{x:A}{\Gamma} }
      { \judgevInfer{\Gamma, x:A}{x}{A} }
\and

\Infer{VarT}
      { \judgeInctx{\isvtype{x}}{\Gamma} }
      { \judgevtype{\Gamma}{x} }
\and

\end{mathpar}
\subsection{Subsumption}

\begin{mathpar}
  
  \Infer{$\csubt$}
        { \judgecInfer{\Gamma}{t}{Y} \\
          \judgecsubt{\Gamma}{X}{Y} \\
          }
        { \judgecCheck{\Gamma}{t}{X} }
  \and

  \Infer{$\vsubt$}
        { \judgevInfer{\Gamma}{v}{B} \\
          \judgevsubt{\Gamma}{A}{B} \\
        }
        { \judgevCheck{\Gamma}{v}{A} }
\end{mathpar}

% \subsection{Subsumption}

% \begin{mathpar}
%   \Infer{$\csubt$}
%   { \judgecCheck{\Gamma}{t}{X} \\
%     \judgecsubt{\Gamma}{X}{Y}}
%   { \judgecCheck{\Gamma}{t}{Y} }
%   \and

%   \Infer{$\vsubt$}
%   { \judgevCheck{\Gamma}{v}{A} \\
%     \judgevsubt{\Gamma}{A}{B}}
%   { \judgevCheck{\Gamma}{v}{B} }
% \end{mathpar}  


\subsection{Universes}
\label{sec:rules:universes}

\begin{mathpar}
  \Infer{$\vtoc$}
        { \judgevtype{\Gamma}{A} }
        { \judgectype{\Gamma}{\valtocomp{A}} }
        \and

  \Infer{$\ctov$}
        { \judgectype{\Gamma}{X} }
        { \judgevtype{\Gamma}{\comptoval{X}} }
  \and

  \Infer{$\Pi$}
        { \judgevtype{\Gamma}     {A} \\
          \judgectype{\Gamma, x:A}{X} }
        { \judgectype{\Gamma}{\pitype{x:A}{X}} }
  \and

  \Infer{$\forall$}
        { \judgevtype{\Gamma}     {A} \\
          \judgectype{\Gamma, x:A}{X} \\
          x \in \fv{X} \\
          \judgeSok{x}{X}
        }
        { \judgectype{\Gamma}{\foralltype{x:A}{X}} }
        \and

  \Infer{$\Sigma$}
        { \judgevtype{\Gamma}     {A} \\
          \judgevtype{\Gamma, x:A}{B} }
        { \judgectype{\Gamma}{\sigmatype{x:A}{B}} }
  \and
  

  \Infer{$\mathsf{eq}$}
        { \judgevtype{\Gamma}{A} \\
          \judgevCheck{\Gamma}{v}{A} \\
          \judgevCheck{\Gamma}{w}{A} }
        { \judgevtype{\Gamma}{\eqtype{A}{v}{w}} }
  \and

  \Infer{Let-type}
        { \judgectype{\Gamma, x:A}{X} \\
          \judgecCheck{\Gamma}{e}{A} }
        { \judgectype{\Gamma}{(\letval{x:A}{e}{X})} }
  \and

\end{mathpar}

\subsection{$\vtoc$ and $\ctov$}
\begin{mathpar}

  \Infer{$\ctov$I$\checks$}
        { \judgecCheck{\Gamma}{t}{X} }
        { \judgevCheck{\Gamma}{\thunk{t}}{\comptoval{X}}}

  \and
  \Infer{$\ctov$I$\infers$}
        { \judgecInfer{\Gamma}{t}{X} }
        { \judgevInfer{\Gamma}{\thunk{t}}{\comptoval{X}}}

  \and

  \Infer{$\ctov$E$\checks$}
        { \judgevCheck{\Gamma}{v}{\comptoval{X}} }
        { \judgecCheck{\Gamma}{\force{v}}{X}}

  \and
  \Infer{$\vtoc$E$\infers$}
        { \judgevInfer{\Gamma}{v}{\comptoval{X}} }
        { \judgecInfer{\Gamma}{\force{v}}{X}}
  \and


  \Infer{$\vtoc$I$\checks$}
        { \judgevCheck{\Gamma}{v}{A} }
        { \judgecCheck{\Gamma}{\return{v}}{\valtocomp{A}}}
  \and

  \Infer{$\vtoc$I$\infers$}
        { \judgevInfer{\Gamma}{v}{A} }
        { \judgecInfer{\Gamma}{\return{v}}{\valtocomp{A}}}
  \and
\end{mathpar}

\subsection{Let and Dependent Let}

\begin{mathpar}

  \Infer{Let$\infers$}
        {
          \judgecInfer{\Gamma, x : A}{u}{X} \\
          \judgecCheck{\Gamma}{t}{\valtocomp{A}} \\
          \judgectype{\Gamma}{X} \\ 
          \judgevtype{\Gamma}{A} \\ 
        }
        { \judgecInfer{\Gamma}{\letval{x : A}{t}{u}}{X} }
  \and
  \Infer{Let$\checks$}
        { \judgecCheck{\Gamma}{t}{\valtocomp{A}} \\ 
          \judgectype{\Gamma}{X} \\ 
          \judgecCheck{\Gamma, x : A}{u}{X}}
        { \judgecCheck{\Gamma}{\letval{x : A}{t}{u}}{X} }
  \and

  \Infer{DLet$\infers$}
        {
          \judgecInfer{\Gamma, x:A}{u}{X} \\
          \judgecCheck{\Gamma}{t}{\valtocomp{A}} \\
          \judgectype{\Gamma, x:A}{X} \\ 
        }
        { \judgecInfer{\Gamma}{\dletval{x:A}{t}{u}}{(\letval{x:A}{t}{X})} }
  \and
  \Infer{DLet$\checks$}
        { \judgecCheck{\Gamma}{t}{\valtocomp{A}} \\ 
          \judgectype{\Gamma, x:A}{X} \\ 
          \judgecCheck{\Gamma, x:A}{u}{X}}
        { \judgecCheck{\Gamma}{\dletval{x:A}{t}{u}}{(\letval{x:A}{t}{X})} }
  \and

\end{mathpar}

\subsection{$\forall$, $\Pi$, and $\Sigma$}

\begin{mathpar}

  %% \Infer{$\Pi$I$\infers$}
  %%       { \judgecCheck{\Gamma, x:A}{X}{\unicomp} \\
  %%         \judgecInfer{\Gamma, x:A}{t}{X} }
  %%       { \judgecInfer{\Gamma}{\fun{x:A}{t}}{\pitype{x:A}{X}} }
  %% \and

  \Infer{$\forall$I$\checks$}
        { \judgectype{\Gamma, x:A}{X} \\
          \judgecCheck{\Gamma, x:A}{t}{X} }
        { \judgecCheck{\Gamma}{\fun{x:A}{t}}{\foralltype{x:A}{X}} }
  \and

  \Infer{$\Pi$I$\checks$}
        { \judgectype{\Gamma, x:A}{X} \\
          \judgecCheck{\Gamma, x:A}{t}{X} }
        { \judgecCheck{\Gamma}{\fun{x:A}{t}}{\pitype{x:A}{X}} }
  \and

  \Infer{$\Pi$E}
        { \judgecInfer{\Gamma}{t}{\pitype{x:A}{X}} \\
          \judgevCheck{\Gamma}{v}{A} }
        { \judgecInfer{\Gamma}{t\,v}{\subst{X}{x}{v}} }
  \and

  %% \Infer{$\Sigma$I$\infers$}
  %%       { \judgevInfer{\Gamma}{v}{A} \\
  %%         \judgevInfer{\Gamma}{w}{B} \\
  %%         \judgevCheck{\Gamma}{A}{\unival} \\
  %%         \judgevCheck{\Gamma}{B}{\unival} }
  %%       { \judgevInfer{\Gamma}{\pair{v}{w}}{A \times B}}
  %% \and

  \Infer{$\Sigma$I$\checks$}
        { \judgevCheck{\Gamma}{v}{A} \\
          \judgevCheck{\Gamma}{w}{\subst{B}{x}{v}} \\
          \judgevtype{\Gamma}{\sigmatype{x:A}{B}} }
        { \judgevCheck{\Gamma}{\pair{v}{w}}{\sigmatype{x:A}{B}} }
   \and


  \Infer{$\Sigma$E}
        {
          \judgectype{\Gamma, p : (\sigmatype{x:A}{B})}{X} \\
          \judgevCheck{\Gamma}{v}{\sigmatype{x:A}{B}} \\
          \judgecCheck{\Gamma}{t}{\pitype{(x:A)(y:B)}{\subst{X}{p}{\pair{x}{y}}}}}
        { \judgecInfer{\Gamma}{\recsigma{v}{X}{t}}{\subst{X}{p}{v}}}
  \and

\end{mathpar}

\subsection{Equality}

\begin{mathpar}

  \Infer{$\mathsf{eq}$I}
        { \judgevtype{\Gamma}{A} \\
          \judgevCheck{\Gamma}{v}{A}}
        { \judgevCheck{\Gamma}{\refl}{\eqtype{A}{v}{v}} }

  \and


  \Infer{$\mathsf{eq}$E$\checks$}
        { \judgevCheck{\Gamma}{v}{\eqtype{A}{w_1}{w_2}} \\
          \judgectype{\Gamma, x:A, p:\eqtype{A}{w_1}{x}}{X} \\
          \judgecCheck{\Gamma}{t}{X\,w_1\,\refl} }
        { \judgecCheck{\Gamma}{\receq{v}{X}{t}}{\subst{\subst{X}{x}{w_2}}{p}{v}}}

\end{mathpar}







\section{Declarative Subtyping}

\begin{mathpar}

  \Infer{$\subt \Sigma$}
        {
          \judgevsubt{\Gamma}{A_1}{B_1}\\
          \judgevsubt{\Gamma, x:A_1}{A_2}{B_2}\\
        }
        {\judgevsubt{\Gamma}{\sigmatype{x:A_1}{A_2}}{\sigmatype{x:B_1}{B_2}}}

 \Infer{$\subt \Pi$}
       {
         \judgevsubt{\Gamma}{A_2}{A_1}\\
         \judgecsubt{\Gamma, x:A_2}{X_1}{X_2}\\
       }
       {\judgecsubt{\Gamma}{\pitype{x:A_1}{X_1}}{\pitype{x:A_2}{X_2}}}

  \Infer{$\subt \ctov$}
        {
          \judgecsubt{\Gamma}{X_1}{X_2} \\
          \judgecsubt{\Gamma}{X_2}{X_1} \\
        }
        {\judgevsubt{\Gamma}{\comptoval{X_1}}{\comptoval{X_2}}}

  \Infer{$\subt \vtoc$}
        {
          \judgevsubt{\Gamma}{A_1}{A_2} \\
          \judgevsubt{\Gamma}{A_2}{A_1} \\
        }
        {\judgecsubt{\Gamma}{\valtocomp{A_1}}{\valtocomp{A_2}}}

  \Infer{$\subt$Eq}
        {
          \judgevsubt{\Gamma}{A}{B} \\
          \judgeequiv{\Gamma}{v_1}{v_2}{A} \\
          \judgeequiv{\Gamma}{w_1}{w_2}{A} \\
        }
        {\judgevsubt{\Gamma}{\eqtype{A}{v_1}{w_1}}{\eqtype{B}{v_2}{w_2}}}
      
  \Infer{$\forall \subt$}
        {
          X \text{ is }  x\text{-neutral}\\
          \judge{\Gamma}{v}{A}\\
          \judgecsubt{\Gamma}{\subst{X}{x}{v}}{Y}
        }
        {\judgecsubt{\Gamma}{(\foralltype{x:A}{X})}{Y}}
        
  \Infer{$\subt \forall$}
        {
          \judgecsubt{\Gamma, y : A}{X}{Y}\\
        }
        {\judgecsubt{\Gamma}{X}{(\foralltype{y:A}{Y})}}

  \Infer{let$\subt$}
        {
          \judgeequiv{\Gamma}{e}{\return{v}}{A}\\
          \judgecsubt{\Gamma}{\subst{X}{x}{v}}{Y}\\
        }
        { \judgecsubt{\Gamma}{(\letval{x:A}{e}{X})}{Y}}

        
  \Infer{$\subt$let}
        {
          \judgeequiv{\Gamma}{e}{\return{v}}{A}\\
          \judgecsubt{\Gamma}{X}{\subst{Y}{y}{v}}\\
        }
        { \judgecsubt{\Gamma}{X}{(\letval{y:A}{e}{Y})}}

  \Infer{let$\subt$let}
        {
          \judgevsubt{\Gamma}{A}{B}\\
          \judgevsubt{\Gamma}{B}{A}\\
          \judgeequiv{\Gamma}{e_1}{e_2}{A}\\
          \judgecsubt{\Gamma, x:A}{X}{Y}\\
         }
        {
          \judgecsubt{\Gamma}{\letval{x:A}{e_1}{X}}{\letval{x:B}{e_2}{Y}}
        }


\end{mathpar}


\section{Algorithmic Subtyping}

\begin{mathpar}

  \Infer{$\subt \Sigma$}
        {
          \judgeavsubt{\varphi}{A_1}{B_1}{\varphi'}\\
          \judgeavsubt{\varphi', x:A_1}{A_2}{B_2}{\varphi''}\\
        }
        {\judgeavsubt{\varphi}{\sigmatype{x:A_1}{A_2}}{\sigmatype{x:B_1}{B_2}}{\varphi''}}

  \Infer{$\subt \Pi$}
        {
          \judgeavsubt{\varphi}{A_2}{A_1}{\varphi'}\\
          \judgeacsubt{\varphi', x:A_2}{\ctxtapp{\varphi'}{X_1}}{X_2}{\varphi''}\\
        }
        {\judgeacsubt{\varphi}{\pitype{x:A_1}{X_1}}{\pitype{x:A_2}{X_2}}{\varphi''}}

  \Infer{$\subt \ctov$}
        {
          \judgeacsubt{\varphi}{X_2}{X_1}{\varphi'} \\
          \judgeacsubt{\varphi'}{X_1}{\ctxtapp{\varphi'}{X_2}}{\varphi''} \\
        }
        {\judgeavsubt{\varphi}{\comptoval{X_1}}{\comptoval{X_2}}{\varphi''}}

  \Infer{$\subt \vtoc$}
        {
          \judgeavsubt{\varphi}{A_2}{A_1}{\varphi'} \\
          \judgeavsubt{\varphi'}{\ctxtapp{\varphi'}{A_1}}{A_2}{\varphi''} \\
        }
        {\judgeacsubt{\varphi}{\valtocomp{A_1}}{\valtocomp{A_2}}{\varphi''}}
  
  \Infer{$\subt$Eq}
        {
          \judgeavsubt{\varphi}{A}{B}{\varphi'} \\
          \judgeunify{\varphi'}{v_1}{\ctxtapp{\varphi'}{v_2}}{\varphi''} \\
          \judgeunify{\varphi''}{w_1}{\ctxtapp{\varphi''}{w_2}}{\varphi'''} \\
        }
        {\judgevsubt{\Gamma}{\eqtype{A}{v_1}{w_1}}{\eqtype{B}{v_2}{w_2}}}

   \Infer{$\forall \subt$}
         {
           \judgeacsubt{\varphi,\hat{v}}
                       {\subst{X}{x}{\hat{v}}}
                       {Y}
                       {\varphi'}
         }
         {\judgeacsubt{\varphi}{(\foralltype{x:A}{X})}{Y}{\varphi'}}

   \Infer{$\subt \forall$}
         {
           \judgeacsubt{\varphi, y : A}{X}{Y}{\varphi'}\\
         }
         {\judgeacsubt{\varphi}{X}{(\foralltype{y:A}{Y})}{\varphi'}}

   \Infer{let$\subt$}
         {
           e \text{ and } A \text{ are ground}\\
           \judgeunify{\varphi, \hat{v}}
                       {e}
                       {\return{\hat{v}}}
                       {\varphi', \evarassign{\hat{v}}{v}}\\
           \judgeacsubt{\varphi'}
                       {\subst{\ctxtapp{\varphi'}{X}}{x}{v}}{Y}{\varphi', \evarassign{\hat{v}}{v}}\\
         }
         { \judgeacsubt{\varphi}{(\letval{x:A}{e}{X})}{Y}{\varphi''}}

   \Infer{$\subt$let}
         {
           \judgeunify{\varphi, \hat{v}}
                       {e}
                       {\return{\hat{v}}}
                       {\varphi', \evarassign{\hat{v}}{v}}\\
           \judgeacsubt{\varphi'}
                       {\ctxtapp{\varphi'}{X}}
                       {\subst{Y}{y}{v}}
                       {\varphi''}\\
         }
         { \judgeacsubt{\varphi}{X}{(\letval{y:A}{e}{Y})}{\varphi''} }

   \Infer{let$\subt$let}
         {
           \judgeavsubt{\varphi}{B}{A}{\varphi_1}\\
           \judgeavsubt{\varphi_1}{\ctxtapp{\varphi_1}{A}}{B}{\varphi_2}\\
           \judgeunify{\varphi_2}{\ctxtapp{\varphi_1}{e_2}}{e_1}{\varphi_3}\\
           \judgeacsubt{\varphi_3, x:{\ctxtapp{\varphi_1}{A}}}{\ctxtapp{\varphi_3}{X}}{Y}{\varphi_4}\\
         }
         {
           \judgeacsubt{\varphi}{\letval{x:A}{e_1}{X}}{\letval{x:B}{e_2}{Y}}{\varphi_4}
         }

\end{mathpar}


\ilyam{In (let$\subt$), type $A$ can have unresolved variables, hence, the first
  unification in the premises can instantiate them, and thus, must be
  algorithmic.}

\ilyam{In (let$\subt$), we require $e$ to be ground, which makes the algorithmic
  system incomplete w.r.t. the declarative system.\\
  E.g. $(\foralltype{x:1}{\letval{y:1}{\return{x}}{\valtocomp{\eqtype{\comptoval{\valtocomp{1}}}{\thunk{y}}{\thunk{y}}}}}) \leqslant \eqtype{\comptoval{\valtocomp{1}}}{\thunk{\return{()}}}{\thunk{\return{()}}}$
  holds for the declarative system but not for the algorithmic.}

\subsection{Natural Numbers and Undecidability}

The type system can be easily extended with natural numbers. To this purpose, we
must add $\nattype$, $\natzero$, and $\natsucc{v}$ to the values, and
$\recnat{v}{X}{base}{step}$ to the computations with obvious typing inference
rules.
We also add $\reduces{\recnat{\natzero}{X}{b}{s}}{b}$ and
$\reduces{\recnat{\natsucc{v}}{X}{b}{s}}{s \, v \, \recnat{v}{X}{b}{s}}$ to the reduction rules.

Notice that we do not unify under the induction operators. For example,
$\judgeunify{\varphi}{\recnat{\hat{v}}{X}{\natzero}{\fun{x\,y}{\natzero}}}{\natzero}{\varphi, \evarassign{\hat{v}}{\natzero}}$
is not admissible.
Moreover, the general unification is undecidable in this case.

Roughly, this is because we can easily define integers,
arithmetic operations, and hence, any arbitrary polynomial
$P(\hat{x_1}, \dots, \hat{x_n})$.
The unification of this polynomial with $\natzero$
corresponds to solving a diophantine equation, which is undecidable.

\subsection{Invariants}

We should be able to infer
$\judgeacsubt{\varphi}{(\letval{x:\valtocomp{\eqtype{A}{\hat{u}}{\hat{v}}}}{\hat{w}}{\valtocomp{Int}})}{\valtocomp{Int}}{\varphi}$.
As you can see, the unused existential variables $\hat{u}$ and $\hat{v}$ stay uninitialized.
It breaks the invariant that the subtyping algorithm `makes' both sides of $\leqslant$ ground (i.e. all existential variables are initialized in the output context).
As such, we weaken the notion of `ground` terms in such a way that they might have existential variables as long as they are not used in the outcome.

\ilyam{I've just realized that what I would like to mean by the usage of the variables depends on the evaluation. So maybe it's worth trying another approach,
  e.g. instantiate existential variables with `?' and promise that it won't cause any problem in the unification. }


\section{Properties}
\ilyam{Outdated}

%% \subsection{Mode-correctness}
%% \subsection{Regularity}

\begin{lemma}[Mode-correctness]
  Each rule in \cref{sec:rules} is mode-correct. Specifically, as defined in \cite{dunfield2021:bidirectional},
  \begin{enumerate}
    \item The premises are mode-correct: for each premise, every input meta-variable is known from the input of the rule's conclusion and the outputs of the earlier premises.
    \item The conclusion is mode-correct: if all premises have been derived, the outputs of the conclusion are known.
  \end{enumerate}
\end{lemma}
\begin{proof}
  First, we prove the mode-correctness of \emph{conclusion} for each rule.
  Note that it is only relevant for the \emph{synthesizing} rules, because for the \emph{checking} rules, the resulting type is given as an input.

  \begin{multicols}{2}
  \begin{itemize}
  \item[(Var)]
    $A$ is known from the input of the conclusion.
  \item[(Universes)]
    For rules in \cref{sec:rules:universes} ($\ctov$, $\vtoc$, $\Pi$,
    $\Sigma$, $\mathsf{eq}$), the resulting type (a universe) is the only
    possible option.

  \item[($\ctov$I$\infers$)]
    $X$ is known from the output of $\judgecInfer{\Gamma}{t}{X}$.

  \item[($\vtoc$E$\infers$)]
    $X$ is known from the output of $\judgevInfer{\Gamma}{v}{\comptoval{X}}$.

  \item[($\vtoc$I$\infers$)]
    $A$ is known from the output of $\judgevInfer{\Gamma}{v}{\comptoval{X}}$.

  \item[(Let$\infers$)]
    $X$ is known from the output of $\judgecInfer{\Gamma, x : A}{u}{X}$.

  \item[(DLet$\infers$)]
    $x$, $A$, and $t$ are given in the input of the conclusion; $X$ is known
    from the output of $\judgecInfer{\Gamma, x:A}{u}{X}$.

  \item[($\Pi$E)]
    $v$ is given in the input of the conclusion; $x$ and $X$ are known from the
    output of $\judgecInfer{\Gamma}{t}{\pitype{x:A}{X}}$.

  \item[($\Sigma$E)]
    $X$ and $v$ are given in the input of the conclusion.

  \item[($\mathsf{eq}$E$\infers$)]
    $X$ and $v$ are given in the input of the conclusion;
    $w_2$ is known from the output of $\judgevInfer{\Gamma}{v}{\eqtype{A}{w_1}{w_2}}$.
  \end{itemize}
  \end{multicols}

  Second, we let us show the mode-correctness of \emph{premises}.
  
  \newcommand{\fromconcl}{given in the input of the conclusion}

  \begin{multicols}{2}
  \begin{itemize}
      \item[(Ctx0)]
        There are no premises.

      \item[(CtxI)]
        $\Gamma$ and $A$ are \fromconcl.

      \item[(CtxExt)]
        $X$, $A$, and $\Gamma$ are \fromconcl.

      \item[(CtxInit)]
        There are no premises. 

      \item[(Var)]
        $x$, $A$, and $\Gamma$ are \fromconcl.

      \item[(EqivC)]
        $\Gamma$, $t$, and $X$ are \fromconcl;
        $Y$ is known from the output of $\judgecInfer{\Gamma}{t}{Y}$.

      \item[(EqivV)]
        $\Gamma$, $v$, and $A$ are \fromconcl;
        $B$ is known from the output of $\judgevInfer{\Gamma}{v}{B}$.

      \item[($\vtoc$)]
        $\Gamma$ and $A$ are \fromconcl.

      \item[($\ctov$)]
        $\Gamma$ and $X$ are \fromconcl.

      \item[($\Pi$)]
        $\Gamma$, $A$, $x$, and $X$ are \fromconcl.

      \item[($\Sigma$)]
        $\Gamma$, $A$, $x$, and $B$ are \fromconcl.

      \item[($\mathsf{eq}$)]
        $\Gamma$, $A$, $v$, and $w$ are \fromconcl.

      \item[($\unival$ and $\unicomp$)]
        There are no premises.

      \item[($\ctov$I$\checks$)]
        $\Gamma$, $t$, and $X$ are \fromconcl.

      \item[($\ctov$I$\infers$)]
        $\Gamma$ and $t$ are \fromconcl.

      \item[($\ctov$E$\checks$)]
        $\Gamma$, $v$, and $X$ are \fromconcl.

      \item[($\vtoc$E$\infers$)]
        $\Gamma$ and $v$ are \fromconcl.

      \item[($\vtoc$I$\checks$)]
        $\Gamma$, $v$, and $A$ are \fromconcl.

      \item[($\vtoc$I$\infers$)]
        $\Gamma$ and $v$ are \fromconcl.

      \item[(Let$\infers$)]
        $\Gamma$, $x$, $A$, $u$, and $t$ are \fromconcl;
        $X$ is known from the output of $\judgecInfer{\Gamma, x : A}{u}{X}$.
        
      \item[(Let$\checks$)]
        $\Gamma$, $t$, $A$, $X$, $x$, and $u$ are \fromconcl.

      \item[(DLet$\infers$)]
        $\Gamma$, $x$, $A$, $u$, and $t$ are \fromconcl.
        $X$ is known from the output of $\judgecInfer{\Gamma, x:A}{u}{X}$.

      \item[(DLet$\checks$)]
        $\Gamma$, $t$, $A$, $x$, $X$, and $u$ are \fromconcl.

      \item[($\Pi$I$\checks$)]
        $\Gamma$, $x$, $A$, $X$, and $t$ are \fromconcl.

      \item[($\Pi$E)]
        $\Gamma$, $t$, and $v$ are \fromconcl;
        $A$ is known from the output of $\judgecInfer{\Gamma}{t}{\pitype{x:A}{X}}$

      \item[($\Sigma$I$\checks$)]
        $\Gamma$, $v$, $A$, $w$, $B$, $x$ are \fromconcl.

      \item[($\Sigma$E)]
        $\Gamma$, $X$, and $v$, are \fromconcl;
        $x$, $A$, and $B$ are known from the output of
        $\judgecInfer{\Gamma}{X}{\sigmatype{x:A}{B} \to \unicomp}$;
        $y$ is an arbitrary fresh variable.
        
      \item[($\mathsf{eq}$I)]
        $\Gamma$, $A$, and $v$ are \fromconcl.

      \item[($\mathsf{eq}$E$\infers$)]
        $\Gamma$, $v$, $X$, and $t$ are \fromconcl;
        $A$ and $w_1$ are known from the output of $\judgevInfer{\Gamma}{v}{\eqtype{A}{w_1}{w_2}}$.
  \end{itemize}
  \end{multicols}


\end{proof}

\begin{lemma}[Context Soundness]
  \label{lemma:ctx-soundness}
  If $\judgeInctx{x:A}{\Gamma}$ and $\judgectx{}{\Gamma}$ then $\judgevCheck{\Gamma}{A}{\unival}$
\end{lemma}
\begin{proof}
  \ilyam{By trivial induction on $\judgeInctx{x:A}{\Gamma}$}
\end{proof}

\begin{lemma}[Regularity]
  The types synthesized by $\infers$ are well-formed. Specifically, the following properties hold
  \begin{enumerate}
  \item if $\judgectx{}{\Gamma}$ and $\judgevInfer{\Gamma}{v}{A}$ then $\judgevCheck{\Gamma}{A}{\unival}$
  \item if $\judgectx{}{\Gamma}$ and $\judgecInfer{\Gamma}{t}{X}$ then $\judgevCheck{\Gamma}{X}{\unicomp}$
  \end{enumerate}
\end{lemma}

\begin{proof}
  We prove this property by mutual structural induction on
  $\judgevInfer{\Gamma}{v}{A}$ and 
  $\judgecInfer{\Gamma}{t}{X}$.
  Let us consider the synthesizing rules.
  \begin{itemize}
  \item[(Var)]
    Since $(x : A)$ belongs to a \emph{well-formed} context $\Gamma$, 
    the property we need
    ($\judgevCheck{\Gamma}{A}{\unival}$) holds by \cref{lemma:ctx-soundness}.
  \item[(Universes)]
    Each rule in \cref{sec:rules:universes} synthesizes either $\unival$ or $\unicomp$.
    The desired properties hold by the following derivation trees:
    \begin{mathpar}
      \Infer{EqivV}
            {\Infer{$\unival$}
                    { }
                    { \judgevInfer{\Gamma}{\unival}{\unival} }\\
              \unival \equiv \unival \\
            }
            { \judgevCheck{\Gamma}{\unival}{\unival} }
      \and
      \Infer{EqivC}
            {\Infer{$\unicomp$}
              { }
              { \judgecInfer{\Gamma}{\unicomp}{\unicomp} }\\
              \unicomp \equiv \unicomp \\
            }
            { \judgecCheck{\Gamma}{\unicomp}{\unicomp} }

     \end{mathpar}
  \item[($\ctov$I$\infers$ and $\vtoc$I$\infers$)]
    The following derivation trees prove the required properties,
    where $\dag$ and $\ddag$ are derived from the inductive hypotheses.
    \begin{mathpar}
      \Infer{EqivC}
            {\Infer{$\ctov$}
              { \Infer{}{\dag}{\judgecCheck{\Gamma}{X}{\unicomp}} }
              { \judgevInfer{\Gamma}{\comptoval{X}}{\unival} } \\
              \comptoval{X} \equiv \comptoval{X} \\
            }
            { \judgevCheck{\Gamma}{\comptoval{X}}{\unival} }
      \and

      \Infer{EqivV}
            {\Infer{$\vtoc$}
              { \Infer{}{\ddag}{\judgevCheck{\Gamma}{A}{\unival}} }
              { \judgecInfer{\Gamma}{\valtocomp{A}}{\unicomp} } \\
              \valtocomp{A} \equiv \valtocomp{A} \\
            }
            { \judgecCheck{\Gamma}{\valtocomp{A}}{\unicomp} }

    \end{mathpar}
     
  \item[($\vtoc$E$\infers$)]
    \ilyam{Depends on $\unival \equiv \spcdot$ }
  \item[(Let$\infers$)]
    The desired property is in the premises.
  \item[(DLet$\infers$)]
    The following derivation tree proves the required property.
    $\judgecCheck{\Gamma}{t}{\valtocomp{A}}$ and 
    $\judgecInfer{\Gamma, x : A}{u}{\unicomp}$ are given as premises.
  \begin{mathpar}
    \Infer{Let$\checks$}
          { \judgecCheck{\Gamma}{t}{\valtocomp{A}} \\ 
            \Infer{ }{\Infer{$\unicomp$}{ }{\judgecInfer{\Gamma}{\unicomp}{\unicomp}}}
                     {\judgecCheck{\Gamma}{\unicomp}{\unicomp}} \\ 
            \Infer{ }{\judgecInfer{\Gamma, x : A}{u}{\unicomp}}
                     {\judgecCheck{\Gamma, x : A}{u}{\unicomp}}}
          { \judgecCheck{\Gamma}{\letval{x : A}{t}{u}}{\unicomp} }
          \and
  \end{mathpar}

\item[($\Pi$E)]
  \ilyam{Depends on $\equiv$ and requires the substitution lemma}
\item[($\Sigma$E)]
  By applying ($\Pi$E) to the first two premises. 

\item[($\mathsf{eq}$E$\infers$)]
  \ilyam{The same trick as in ($\Sigma$E) doesn't work...}

\end{itemize}


\end{proof}

\printbibliography

\end{document}
