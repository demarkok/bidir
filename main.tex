\documentclass[a4,natbib=false]{article}
\usepackage{fullpage}
\usepackage{amssymb}
\usepackage{amsmath,amsfonts,amsthm}
\usepackage{xcolor}
\usepackage{mathpartir}
\usepackage{cleveref}
\usepackage{multicol}
\usepackage{quiver}
\usepackage{wrapfig}
\usepackage{esvect}
\usepackage[inline, shortlabels]{enumitem}
\usepackage{array}

\usepackage[colorinlistoftodos]{todonotes} 

\setlength{\columnsep}{1cm}
\let\citename\relax
\usepackage[natbib=true, abbreviate=false, dateabbrev=true, isbn=true, doi=false, urldate=comp, url=true, maxbibnames=9, maxcitenames=2, backref=false, backend=biber, style=alphabetic, language=american]{biblatex}
\addbibresource{biblio.bib}

\newcounter{daggerfootnote}
\newcommand*{\daggerfootnote}[1]{%
  \setcounter{daggerfootnote}{\value{footnote}}%
  \renewcommand*{\thefootnote}{\fnsymbol{footnote}}%
  \footnote[2]{#1}%
  \setcounter{footnote}{\value{daggerfootnote}}%
  \renewcommand*{\thefootnote}{\arabic{footnote}}%
}


\newtheorem{lemma}{Lemma}
\newtheorem{definition}{Definition}
\newtheorem{notation}{Notation}
\newtheorem{corollary}{Corollary}
\newtheorem{proposition}{Proposition}

%% \newcommand{\ilyam}[2][]{\todo[linecolor=red,backgroundcolor=red!25,bordercolor=red,#1]{I: #2}}
\newcommand{\ilya}[2][]{\todo[linecolor=red,backgroundcolor=red!25,bordercolor=red,inline,#1]{Ilya: #2}}
\newcommand{\ilyam}[1]{{\color{red} \texttt{Ilya:  #1}}}

%%
\newcommand{\bnfalt}{\;\;|\;\;}



% Now we give some commands to define the syntax of the language. 

\newcommand{\fun}[2]{\lambda {#1}.\,{#2}}


\newcommand{\letname}{\mathsf{let}}
\newcommand{\dletname}{\mathsf{dlet}}

\newcommand{\letval}[3]{\letname\; {#1} \,:=\, {#2} \;\mathsf{in}\; {#3}}
\newcommand{\dletval}[3]{\dletname\; {#1} \,:=\, {#2} \;\mathsf{in}\; {#3}}

\newcommand{\pair}[2]{\left\langle{#1}, {#2}\right\rangle}
\newcommand{\fst}[1]{\mathsf{fst}\,{#1}}
\newcommand{\snd}[1]{\mathsf{snd}\,{#1}}

\newcommand{\unit}{\langle\rangle}

\newcommand{\ctov}{\mathcal{U}}
\newcommand{\vtoc}{\mathcal{F}}

\newcommand{\unival}{\square^{v}}
\newcommand{\unicomp}{\square^{c}}

\newcommand{\vtype}{\mathsf{vtype}}
\newcommand{\ctype}{\mathsf{ctype}}

\newcommand{\comptoval}[1]{\downarrow \hspace{-2pt} #1}
\newcommand{\valtocomp}[1]{\uparrow \hspace{-2pt} #1}
\newcommand{\sigmatype}[2]{\Sigma {#1}.\,#2}
\newcommand{\pitype}[2]{\Pi {#1}.\,#2}
\newcommand{\foralltype}[2]{\forall {#1}.\,#2}
\newcommand{\eqtype}[3]{\mathsf{eq}{#1}\,{#2}\,{#3}}
\newcommand{\refl}{\mathsf{refl}}
\newcommand{\force}[1]{\mathsf{force}\,{#1}}
\newcommand{\return}[1]{\mathsf{return}\,{#1}}
\newcommand{\thunk}[1]{\{{#1}\}}

\newcommand{\recsigmaname}{\mathsf{rec}_{\Sigma}}
\newcommand{\recsigma}[3]{\recsigmaname^{#2}({#1},{#3})}
\newcommand{\receqname}{\mathsf{rec}_{\mathsf{eq}}}
\newcommand{\receq}[3]{\receqname^{#2}({#1},{#3})}

\newcommand{\subst}[3]{{#1}\{{#2}\,:=\,{#3}\}}
\newcommand{\rename}[3]{{#1}\{{#2}\rightsquigarrow{#3}\}}

\newcommand{\subt}{\leqslant}
\newcommand{\vsubt}{\leqslant^v}
\newcommand{\csubt}{\leqslant^c}

\newcommand{\isvtype}[1]{{#1} \, \mathsf{vtype}}
\newcommand{\isctype}[1]{{#1} \, \mathsf{ctype}}

\newcommand{\ctxtapp}[2]{[{#1}] {#2}}
\newcommand{\evarassign}[2]{({#1} \mathsf{:=} {#2})}
\newcommand{\spcdot}{\mkern 2mu\cdot\mkern 2mu}
\newcommand{\emptyctx}{\spcdot}
\newcommand{\mapentry}[2]{{#1} \mapsto {#2}}

\newcommand{\fventry}[2]{{#1}^{#2}}

\newcommand{\reduces}[2]{{#1} \rightarrow {#2}}
\newcommand{\contracts}[2]{{#1} \rightharpoonup {#2}}

\newcommand{\nattype}{\mathbb{N}}
\newcommand{\natzero}{\mathsf{0}}
\newcommand{\natsucc}[1]{\mathsf{succ}({#1})}
\newcommand{\recnat}[4]{\mathsf{rec}_{\nattype}^{#2}({#1},{#3},{#4})}

\newcommand{\narg}[1]{|{#1}|}
\newcommand{\arity}[1]{\mathsf{ar}{#1}}


% This is a command to define a judgement -- we'll one command per judgement
% for delta-CBPV

\newcommand{\judge}[3]{{#1} \vdash {#2} : {#3}}
\newcommand{\judgectx}[2]{{#1} \vdash {#2}}
\newcommand{\judgesafeinenv}[2]{{#1}  \vdash {#2}}
\newcommand{\judgesafeinenvv}[3]{{#1}[{#2}]  \vdash {#3}}


\newcommand{\checks}{{\color{blue} \Leftarrow}}
\newcommand{\infers}{{\color{brown} \Rightarrow}}

\newcommand{\judgec}[3]{{#1} \vdash_{c} {#2} : {#3}}
\newcommand{\judgecCheck}[3]{{#1} \vdash_{c} {#2} \, \checks \,  {#3}}
\newcommand{\judgecInfer}[3]{{#1} \vdash_{c} {#2} \, \infers \, {#3}}

\newcommand{\judgev}[3]{{#1} \vdash_{v} {#2} : {#3}}
\newcommand{\judgevCheck}[3]{{#1} \vdash_{v} {#2} \, \checks \, {#3}}
\newcommand{\judgevInfer}[3]{{#1} \vdash_{v} {#2} \, \infers \, {#3}}

\newcommand{\judgeInctx}[2]{{#1} \in {#2}}

\newcommand{\judgevtype}[2]{{#1} \vdash \isvtype{#2}}
\newcommand{\judgectype}[2]{{#1} \vdash \isctype{#2}}


\newcommand{\judgevsubt}[3]{{#1} \vdash {#2} \vsubt {#3}}
\newcommand{\judgecsubt}[3]{{#1} \vdash {#2} \csubt {#3}}

\newcommand{\judgeequiv}[4]{{#1} \vdash {#2} \equiv {#3} : {#4}}
\newcommand{\judgeequivunt}[2]{{#1} \equiv {#2}}
\newcommand{\judgeequivuntg}[3]{{#1} \vdash {#2} \equiv {#3}}

\newcommand{\judgealpha}[2]{{#1} \sim_{\alpha} {#2}}

\newcommand{\judgeavsubt}[4]{{#1}\,{\color{purple}\vdash} {#2} \vsubt {#3} {\color{purple}\dashv}\,{#4}}
\newcommand{\judgeacsubt}[4]{{#1}\,{\color{purple}\vdash} {#2} \csubt {#3} {\color{purple}\dashv}\,{#4}}

\newcommand{\judgeunify}[4]{{#1}\,{\color{purple}\vdash} {#2} \equiv {#3} {\color{purple}\dashv}\,{#4}}

\newcommand{\judgeSnf}[1]{{#1}\,\mathsf{NF}}
\newcommand{\judgeSatom}[1]{{#1}\,\mathsf{ATOM}}
\newcommand{\judgeSinert}[1]{{#1}\,\mathsf{INERT}}
\newcommand{\judgeSok}[2]{{#1} \in {#2}\,\mathsf{OK}}
\newcommand{\judgeSokterm}[1]{{#1} \,\mathsf{OK}}

\newcommand{\judgeinst}[2]{{#1} \vdash {#2}}

\newcommand{\ctxtexdends}[2]{{#1} \subseteq {#2}}


\newcommand{\fv}[1]{\mathsf{FV}(#1)}
\newcommand{\codom}[1]{\mathsf{im}(#1)}

\newcommand{\absclose}[2]{\vv{x}^{#1} #2}

\newcommand{\vars}[1]{\mathsf{vars}(#1)}


\newcommand{\fullterm}[2]{{#1}\,#2_1 \dots #2_{\narg{#1}}}
\newcommand{\fulltermm}[2]{{#1}\,(\absclose{\arity{#1}_1}{#2_1}) \dots (\absclose{\arity{#1}_{\narg{#1}}}{#2_{\narg{#1}})}}
\newcommand{\fulltermmm}[1]{{#1}\,P^{\arity{#1}} \dots P^{\arity{#1}_{\narg{#1}}}}

% This is a command to define an inference rule. The optional argument to
% \inferrule* is the label for the rule. 
% 
\newcommand{\Infer}[3]{\inferrule*[right={#1}]{#2}{#3}}

\newcommand\declareop[3]{%
  \newcommand#1{%
    \mskip\muexpr\medmuskip*#2\relax
    {#3}%
    \mskip\muexpr\medmuskip*#2\relax
  }}

\declareop\inc{3}{\mathrel{+}=}

\newcolumntype{L}{>{$}l<{$}} % math-mode version of "l" column type

\begin{document}
\section{Syntax}
\begin{definition}[Syntax of terms]
  \label{def:syntax}

  We write \emph{term} meaning a computation or a value, denoting it $\sigma$ or $\tau$.

\begin{mathpar}
  \begin{array}{llcl}
    \mbox{Computations} & X, Y, t, u & ::= & t v \bnfalt
    \valtocomp{A} \bnfalt \pitype{x:A}{X} \bnfalt \foralltype{x:A}{X} \bnfalt \force {v} \bnfalt \return{v}
    \bnfalt \fun{x:A}{t} \bnfalt \\ & & & \letval{x : A}{t}{u} \bnfalt
    \dletval{x : A}{t}{u} \bnfalt \recsigma{v}{x.X}{t} \bnfalt \receq{v}{x.y.X}{t}
    \\[1em]

    \mbox{Values} & A, B, v, w & ::= & x \bnfalt \comptoval{X}
    \bnfalt \sigmatype{x:A}{B} \bnfalt \refl \bnfalt \eqtype{A}{v}{w} \bnfalt
    \thunk{t} \bnfalt \pair{v}{w} \\[1em]

    % \mbox{Contexts} & \Gamma & ::= & \emptyctx \bnfalt \Gamma, x:A \bnfalt \Gamma, \isvtype{B} \\[1em]
  \end{array}
\end{mathpar}

\end{definition}

We use different non-terminal symbols to emphasize the distinction between type-level terms
and term-level terms, which manifests properly in \cref{sec:rules}.
The upper-case literals represent type-terms, and the lower-case
represent term-terms (which can be typed with some type-terms)
with one exception: in $\letval{x : A}{t}{u}$,
$u$ can represent a type-term.

\section{Computational form of the terms}

Let us consider the term syntax from a different perspective:

\begin{definition}[Computational syntax of terms]
  \label{def:comp-syntax}


\begin{mathpar}
  \begin{array}{llcl}
    \mbox{Constructors} & C & ::= & \lambda \bnfalt (,) \bnfalt \refl \bnfalt \return{} \bnfalt \thunk{} 
    \\[1em]
    \mbox{Eliminators} & E & ::= & @ \bnfalt \recsigma{}{}{} \bnfalt \receq{}{}{}
                                   \bnfalt \letname \bnfalt \dletname
                                   \bnfalt \force{}
    \\[1em]

    \mbox{Neutral Formers} & N & ::= & \comptoval \bnfalt \Pi \bnfalt \forall \bnfalt
                                       \valtocomp{} \bnfalt \Sigma \bnfalt x
    \\[1em]

    \mbox{Formers} & F & ::= & C \bnfalt E \bnfalt N
    \\[1em]

    \mbox{Abstractor Heads} & \vv{x}^0 & ::= & .\\
                        & \vv{x}^{n + 1} & ::= & x\,.\, \vv{x}^n \\
                       & \vv{x}          & ::= & \vv{x}^0 \bnfalt \vv{x}^1
                                                 \bnfalt \dots
    \\[1em]

    \mbox{Abstractors} & P^n, Q^n & ::= & \vv{x}^n \tau\\
                       & P, Q    &  ::= & P^1 \bnfalt P^2 \bnfalt \dots
    \\[1em]

    % \mbox{Terms} & \sigma, \tau, \nu & ::= & \fullterm{F}{\tau}
    \mbox{Terms} & \sigma, \tau, \nu & ::= & \fulltermm{F}{\tau}
  \end{array}
\end{mathpar}

\end{definition}

\begin{definition} [Arity]
  For every term former $F$ we define its arity $\arity{F}$ as the array of integers desctibing its
  arguments. Integer denotes the number of new binding variables ``created'' by
  $F$ that can be used in the corresponding subterm. For brevity, we denote
  length of $\arity{F}$ as $\narg{F}$.
   
  \begin{table}[h]
    \setlength\tabcolsep{5pt}
    \begin{tabular}{L|LLLLLLLLLLLLLLLLL}
      F         & \lambda & (,)   & \refl & \return{} & \thunk{} & @     & \recsigmaname & \receqname & \letname & \dletname & \force{} & \comptoval & \Pi   & \forall & \valtocomp{} & \Sigma & x  \\
      \hline
      \arity{F} & [1, 0]  & [0,0] & []    & [0]       & [0]      & [0,0] & [0,1,0]         & [0,2,0]       & [1,0,0]  & [1,0,0]   & [0]      & [0]        & [0,1] & [0,1]   & [0]          & [0,1]  & [] \\
      \narg{F}  & 2       & 2     & 0     & 1         & 1        & 2     & 3               & 3             & 3        & 3         & 1        & 1          & 2     & 2       & 1            & 2      & 0 
    \end{tabular}
  \end{table}

\end{definition}

\ilyam{Notice that we rearrange the arguments in $\lambda$ and let-bindings so
  that any redex is always an eliminator whose \emph{first} argument is a constructor}

It is easy to see that the syntax of \emph{terms} from \cref{def:syntax} defines
the \emph{subset} of terms defined by \cref{def:comp-syntax}. In fact, any
\emph{well-typed} term must have a form defined by \cref{def:syntax}. We will
use these two representation interchangeably.

\section{Alpha-equivalence}

\begin{definition}[Variable Renaming]
  \begin{mathpar}
    \Infer{}{ }{\rename{x}{x}{z} = z} \and
    \Infer{}{x \neq y}{\rename{x}{y}{z} = x} \and
    \Infer{}{F \neq x}{\rename{\fullterm{F}{P}}{y}{z} = F\, (\rename{P_1}{y}{z}) \dots (\rename{P_{\narg{F}}}{y}{z})} \and
    \Infer{}{ }{\rename{.\tau}{y}{z} = .(\rename{\tau}{y}{z})} \and
    \Infer{}{x' \text{ is fresh} }{\rename{x.P}{y}{z} = x'.(\rename{(\rename{P}{x}{x'})}{y}{z})}
  \end{mathpar}
\end{definition}

\begin{definition}[Alpha-equivalence]
  \begin{mathpar}
    \Infer{}
    {\forall i, \judgealpha{P_i}{Q_i}}
    {\judgealpha{\fullterm{F}{P}}{\fullterm{F}{Q}}}
    \and
    \Infer{}
    {\judgealpha{\sigma}{\tau}}
    {\judgealpha{.\sigma}{.\tau}}
    \and
    \Infer{}
    { y \text{ is fresh}\\
      \judgealpha{\rename{\sigma}{x}{y}}{\rename{\tau}{x}{y}}}
    {\judgealpha{x.\sigma}{x.\tau}}
    \and
  \end{mathpar}

\end{definition}

\begin{lemma}
  Alpha-equivalence is an equivalence relation on terms and abstractors.
\end{lemma}
\ilyam{Admitted.}

\begin{lemma}[Functionality of Variable Renaming]
  Variable Renaming is a functional on the classes of alpha-equivalence.
\end{lemma}
\ilyam{Admitted.}

Hereafter, we assume every statement about terms and abstractors defined on the
equivalence classes. Whenever we use the ``concrete term syntax'', we mean the
alpha-equivalence class of this term if the term is in the covariant position of
the statement or definition (e.g. we are constructing a function returning an
equivalence class as an output); and \emph{any term of this form from this
  class} if the term is in the contravariant position (e.g. we are constructing
a function taking an equivalence class as an input).


\section{Susbtititution}
\begin{definition}[Substitution]
  \ilyam{todo}
\end{definition}

\begin{lemma}[Functionality of Substituion]
  Substitution is a functional on the classes of alpha-equivalence.
\end{lemma}
\ilyam{Admitted.}


\section{Reduction}

First, we define the \emph{redex contraction}.
\begin{definition}[Redex Contraction]
  \label{def:redex-contr}
  We define the top-level redex contraction in the following way:
  \begin{multicols}{2}
    \begin{itemize}

    \item $\contracts{(\fun{x:\nu}{\sigma})\tau}{\subst{\sigma}{x}{\tau}}$
      
    \item $\contracts{\letval{x:\nu}{\return{\sigma}}{\tau}}{\subst{\tau}{x}{\sigma}}$

    \item $\contracts{\dletval{x:\nu}{\return{\sigma}}{\tau}}{\subst{\tau}{x}{\sigma}}$

    \item $\contracts{\force{\thunk{\tau}}}{\tau}$

    \item $\contracts{\recsigma{\pair{\tau_1}{\tau_2}}{\nu}{\sigma}}{\sigma \,
        \tau_1 \, \tau_2}$

    \item $\contracts{\receq{\refl}{\nu}{\tau}}{\tau}$

    \end{itemize}
  \end{multicols}

  The terms on the left hand side of $\contracts{\spcdot}{\spcdot}$ are called \emph{redexes}.
  
\end{definition}

Notice that any redex from \cref{def:redex-contr} is an elimination of a
constructor, i.e. a term of the form $E\,(\fullterm{C}{P})\, Q_2 \dots
Q_{\narg{E}}$ where $E$ and $C$ are ``matched''.
Vice versa, if a term of the form
$E\,(\fullterm{C}{P})\, Q_2 \dots Q_{\narg{E}}$ is
\emph{well-typed}, it is a redex. 


Informally, reduction of a term $\tau$ is a redex contraction happening in some
\emph{subterm} of $\tau$.

\begin{definition}[Reduction]
  \begin{mathpar}
    \Infer{Redex}{\contracts{\tau}{\tau'}}{\reduces{\tau}{\tau'}}
    \and
    \Infer{Cong$^F_i$}{\reduces{\tau}{\tau'}}
    {\reduces
      {F\,P_1\dots (\absclose{\arity{F}_i}{\tau}) \dots P_{\narg{F}}}
      {F\,P_1\dots (\absclose{\arity{F}_i}{\tau'}) \dots P_{\narg{F}}}}
  \end{mathpar}

\end{definition}

\begin{lemma}[Substitution preserves reduction]
  \label{lemma:subst-res}

  \begin{mathpar}
    \Infer{}
    {\reduces{\tau}{\tau'}}
    {\reduces{\subst{\tau}{x}{\sigma}}
      {\subst{\tau'}{x}{\sigma}}}
  \end{mathpar}
\end{lemma}
\begin{proof}
  Induction on $\reduces{\tau}{\tau'}$. Substitution is congruent, therefore,
  the induction goes down to the redexes.

  \begin{itemize}
    \item
  Suppose that
  $\reduces{(\fun{x:\nu}{\sigma})\sigma'}{\subst{\sigma}{x}{\sigma'}}$.
  We need to prove that
  $\reduces{\subst{(\fun{x:\nu}{\sigma})\sigma'}{y}{\tau}}{\subst{\subst{\sigma}{x}{\sigma'}}{y}{\tau}}$.
  We know that $\subst{(\fun{x:\nu}{\sigma})\sigma'}{y}{\tau} =
  (\fun{x:\nu}{\subst{\sigma}{y}{\tau}})(\subst{\sigma'}{y}{\tau})$,
  which reduces to
  $\subst{\subst{\sigma}{y}{\tau}}{x}{\subst{\sigma'}{y}{\tau}}$. But
  $$\subst{\subst{\sigma}{y}{\tau}}{x}{\subst{\sigma'}{y}{\tau}} =
  \subst{\subst{\sigma}{x}{\sigma'}}{y}{\tau},$$
  assuming that $x \notin \fv{\tau}$, which is guaranteed because the
  substitution is capture-avoiding. 

  \item
    The other cases are similar or straightforward
  \end{itemize}
\end{proof}

\section{Normal Form}

Using the syntax from \cref{def:comp-syntax}, it is convenient to express
computational properties of the term, e.g. being in the normal form
($\mathsf{NF}$).

\begin{definition}[Normal Form]
\begin{mathpar}
  \Infer{}{\judgeSatom{\tau}}{\judgeSnf{\tau}}
  \and
  \Infer{}{\judgeSnf{\tau_{1}}~\dots~\judgeSnf{\tau_{\narg{C}}}}{\judgeSnf{\fullterm{C}{\vv{x}\tau}}}
  \and
  \Infer{}{\judgeSnf{\tau_{1}}~\dots~\judgeSnf{\tau_{\narg{N}}}}{\judgeSatom{\fullterm{N}{\vv{x}\tau}}}
  \and
  \Infer{}{\judgeSatom{\tau_1}\\\judgeSnf{\tau_2}~\dots~\judgeSnf{\tau_{\narg{E}}}}{\judgeSatom{\fullterm{E}{\vv{x}\tau}}
  }
\end{mathpar}
\end{definition}

The intuition is that
\begin{enumerate*}
\item[(i)] normal terms are not reducible;
\item[(ii)] atomic terms are not reducible and, in addition, do not cause
  reduction when the eliminators are applied to them.
\end{enumerate*}

Although it is easy to see that the terms in normal form are not reducible,
the opposite is only true for the well-typed terms:

\begin{proposition}[Normal form and irreducibility]
  \label{prop:nf-irred}
  \begin{mathpar}
    \Infer{}{\judgeSnf{\tau}}{\nexists \tau', \reduces{\tau}{\tau'}}
    \and
    \Infer{}{\tau \text{ is well-typed } \\ \nexists \tau', \reduces{\tau}{\tau'}}{\judgeSnf{\tau}}
  \end{mathpar}
\end{proposition}

Hereafter, we assume all the terms are well typed.
\ilyam{Well-typedness is required for the unification and equivalence to be
  well-founded (otherwise induction is not possible). TODO: normalization (halting)!}

% \begin{definition}[Syntactic normal form]
%   We say that the term $\tau$ is in the syntactic
%   normal form if and only if it is formed by the following grammar:

%   \begin{mathpar}
%     \begin{array}{llcl}
%       \mbox{Normal Computations} & t_n, X_n & ::= &
%       \fun{x:A_n}{t_n} \bnfalt
%       \return{v_n} \bnfalt
%       t_a
%       \\[1em]

%       \mbox{Atomic Computations} & t_a & ::= &
%                                                \force{v_a} \bnfalt
%       t_a v_n \bnfalt
%       \recsigma{v_a}{X_n}{t_n} \bnfalt
%       \receq{v_a}{X_n}{t_n} \bnfalt \\ &&& 
%       \letval{x : A_n}{t_a}{t_n} \bnfalt
%       \dletval{x : A_n}{t_a}{t_n} \\ &&&
%       \valtocomp{A_n} \bnfalt
%       \pitype{x:A_n}{X_n} \bnfalt
%       \foralltype{x:A_n}{X_n}
%       \\[1em]

%       \mbox{Normal Values} & v_n, A_n & ::= &
%       \pair{v_n}{v_n} \bnfalt
%       \thunk{t_n} \bnfalt
%       \refl \bnfalt
%       v_a
%       \\[1em]

%       \mbox{Atomic Values} & v_a & ::= & x \bnfalt \\ &&& \comptoval{X_n} \bnfalt
%                                          \sigmatype{x:A_n}{A_n} \bnfalt \eqtype{A_n}{v_n}{v_n}
%       \\[1em]

%     \end{array}
%   \end{mathpar}
% \end{definition}


\section{Safe Occurrence}

Another important property that we express in this syntax is \emph{safe
  occurrence of the variable}. The judgement $\judgeSok{x}{\tau}$ means $x$
occurs safely in $\tau$.

Ideally, we would like to forbid the situations when \emph{in some normal form}
of $\tau$, some instantiation of $x$ generates a new redex. In other words, we
would like to ensure that
\emph{all normal forms} of $\tau$ do not contain $E \, x \, \tau_2 \dots
\tau_{\narg{E}}$ as a subterm.

However, this property is undecidable by Rice's theorem: notice that
\begin{enumerate*}

\item[(i)] we do not require terms to have types at this stage, thus, the
  system is Turing complete;

\item[(ii)] the property is non-trivial;

\item[(iii)] the property judges about the normal forms and thus, is invariant
  under ``algorithmic equivalence''.
\end{enumerate*}
As it is undecidable, it is impossible to express this judgement using
well-founded inference rules (i.e. unambiguously generating finite trees).

Since precise syntactic representation of this property is impossible, we
under-approximate this property in the following way:

\ilyam{TODO: add safe occurrence in abstractors}

\begin{mathpar}
  \Infer{C-Cong}{\judgeSok{x}{\tau_{1}}~\dots~\judgeSok{x}{\tau_{\narg{C}}}}{\judgeSok{x}{\fullterm{C}{\vv{x}\tau}}}
  \and
  \Infer{N-Cong}{\judgeSok{x}{\tau_{1}}~\dots~\judgeSok{x}{\tau_{\narg{N}}}}{\judgeSok{x}{\fullterm{N}{\vv{x}\tau}}}
  \and
  \Infer{E-FV}{x \notin \fv{\fullterm{E}{\tau}}}{\judgeSok{x}{\fullterm{E}{\vv{x}\tau}}}
  \and
  \Infer{E-Cong}
  {\judgeSok{x}{\tau_{1}}~\dots~\judgeSok{x}{\tau_{\narg{E}}}
    \\ 
    \tau_1 \neq x
    \\ 
    \judgeSinert{\fullterm{E}{\vv{x}\tau}}
  }
  {\judgeSok{x}{\fullterm{E}{\vv{x}\tau}}
   \\ \ilyam{(implicit $\alpha$-rename!)}
  }
\end{mathpar}
In the last rule, ``$\tau_1 \neq x$'' means literal syntactic inequality.
Intuitively, ``$\judgeSinert{\tau}$'' means that $\tau$ preserves its
top-level structure under the reduction, i.e. the reduction always happens in
the subterms of $\tau$ but never on the top-level. In fact, the relation we
define is a little bit stronger, as it also forbids changing of the structure 
of the eliminator's first argument. Formally, it is defined as follows:

\begin{mathpar}
  \Infer{}{ }{\judgeSinert{\fullterm{N}{\vv{x}\tau}}}
  \and
  \Infer{}{ }{\judgeSinert{\fullterm{C}{\tau}}}
  \and
  \Infer{}{ }{\judgeSinert{E\,(\fullterm{N}{\vv{x}\sigma})\,\vv{x}\tau_2 \dots \vv{x}\tau_{\narg{E}}}}
  \and
  \Infer{EE-Inert}
  {\judgeSinert{\fullterm{E'}{\vv{x}\sigma}}}
  {\judgeSinert{E\,(\fullterm{E'}{\vv{x}\sigma})\,\vv{x}\tau_2 \dots \vv{x}\tau_{\narg{E}}}}
\end{mathpar}

As a heuristics, it is possible to extend the ``Safe Occurrence'' property by
injecting some of the redex contractions from \cref{def:redex-contr} into the
inference system. Notice that only non-substituting contractions are allowed
because the latter would violate the finiteness of the inference trees.

\begin{mathpar}
  \Infer{}
  {\judgeSok{x}{\tau}}
  {\judgeSok{x}{\force{\thunk{\tau}}}}
  \and
  \Infer{}
  {
    \judgeSok{x}{{@\, (@\, \sigma \, \tau_1)\, \tau_2}} \\
    \judgeSok{x}{\tau'} \\
  }
  {\judgeSok{x}{
      \recsigma{\pair{\tau_1}{\tau_2}}{\tau'}{\sigma}}
  }
  \and
  \Infer{}
  {
    \judgeSok{x}{\sigma} \\
    \judgeSok{x}{\tau} \\
  }
  {\judgeSok{x}{
      \receq{\refl}{\sigma}{\tau}}
  }
\end{mathpar}

% \begin{lemma}[Correctness of the definition]
%   Safe occurrence is defined up to alpha-equivalence. 
% \end{lemma}
% \begin{proof}
% \ilyam{todo}
% \end{proof}

\begin{lemma}[Conguence of the safe occurrence]
  \label{lemma:cong-safe-occurrence}
  \begin{mathpar}
  \Infer{}
  {
    \judgeSok{x}{\fullterm{F}{P}}
    % \ilyam{x is not captured by the abstractors}
  }
  {
    \judgeSok{x}{P_1} \\
    \cdots \\
    \judgeSok{x}{P_{\narg{F}}}
  }
  \end{mathpar}
\end{lemma}
\begin{proof}
  Trivial induction.
\end{proof}


\begin{lemma}[Reduction-Substitution Commutativity]
  \label{lemma:red-subst-commute}
  \begin{mathpar}
    \Infer{}
    {
      \judgeSok{x}{\sigma}\\
      \judgeSnf{\tau}\\
      \reduces{\subst{\sigma}{x}{\tau}}{\sigma'}\\
    }
    {\exists \sigma^* \text{ s.t. } \reduces{\sigma}{\sigma^*} \text{ and } \subst{\sigma^*}{x}{\tau} = \sigma' }
  \end{mathpar}

  Or in the commutative diagram form: 
    if $\judgeSok{x}{\sigma}$ and $\judgeSnf{\tau}$ then
    \begin{tikzcd}
        \sigma & {\sigma^*} \\
        \bullet & {\sigma'}
        \arrow["{{x:=\tau}}"', from=1-1, to=2-1]
        \arrow["\rightarrow"', from=2-1, to=2-2]
        \arrow["\rightarrow", dashed, from=1-1, to=1-2]
        \arrow["{x := \tau}", dashed, from=1-2, to=2-2]
      \end{tikzcd}
\end{lemma}

\begin{proof}
  Let us destruct the substitution $\subst{\sigma}{x}{\tau}$. Notice that
  $\sigma \neq x$ because $\subst{x}{x}{\tau} = \tau \nrightarrow \spcdot$. It
  means that the substitution is performed by congruence: $\sigma =
  \fullterm{F}{\sigma}$ (for some $F \neq x$), and $\subst{\sigma}{x}{\tau} =
  F\, (\subst{\sigma_1}{x}{\tau}) \dots (\subst{\sigma_{\narg{F}}}{x}{\tau}) $.
  Notice that $\judgeSok{x}{\sigma_i}$ for $i = 1 \dots \narg F$ by
  \cref{lemma:cong-safe-occurrence}.

  Induction on $\reduces{\subst{\sigma}{x}{\tau}}{\sigma'}$.
  The reduction step can be justified either by the congruence or the redex contraction.
  \begin{itemize}
  \item If the reduction step is done by congruence, then the required
    $\sigma^*$ is of the form $\fullterm{F}{\sigma^*}$ where $\sigma^*_1 \dots
    \sigma^*_{\narg{F}}$ are constructed by the straightforward application of
    the induction hypothesis to $\sigma_1 \dots \sigma_{\narg{F}}$.

  \item If the reduction is the top-level redex contraction, then
    $\subst{\sigma}{x}{\tau}$ is a redex, i.e. $F$ is an eliminator $E$ and
    $\subst{\sigma_1}{x}{\tau}$ is formed by a constructor $C$.
    Notice that because
    $\judgeSok{x}{\fullterm{E}{\sigma}}$, $\sigma_1
    \neq x$. Therefore, the substitution $\subst{\sigma_1}{x}{\tau}$ is also done by
    congruence: $\sigma_1 = \fullterm{C}{\zeta}$ and thus,
    $\sigma = E \, (\fullterm{C}{\zeta}) \, \sigma_2 \dots \sigma_{\narg{E}}$.

    Let us destruct $\judgeSok{x}{\sigma}$. Since $\sigma$ is not inert, either
    \begin{enumerate*}
      \item[(i)] $x \notin \fv{\sigma}$, then the substitution is the identity, and we
        can take $\sigma^* = \sigma'$); or
      \item[(ii)] one of the ``additional'' rules is applied to get
        $\judgeSok{x}{\sigma}$. In all of these three cases, we can perform the
        same top-level redex contraction to acquire $\sigma^*$. This operation
        commutes with substitution because all it does is restructuring the
        top-level form of $\sigma$ without changing the subterms $\zeta_1,
        \dots, \zeta_{\narg{C}}, \sigma_2, \dots, \sigma_{\narg{E}}$, thus, the
        required property holds.

        \ilyam{to be fair, the beta-reduction also commutes with the
          substitution, but we still need the inertness so that OK is preserved
          under reduction.}
        
    \end{enumerate*}
  \end{itemize}
\end{proof}


\begin{lemma}[Inertness preservation]
  \label{lemma:inertness-pres}
  \begin{mathpar}
    \Infer{}{\judgeSinert{\tau} \\ \reduces{\tau}{\tau'}}{\judgeSinert{\tau'}}
  \end{mathpar}
\end{lemma}

\begin{proof}
  Induction on $\judgeSinert{\tau}$.
\end{proof}


\begin{lemma}[Reduction preserves safe occurrence]
  \label{lemma:safe-occur-pres}
  \begin{mathpar}
    \Infer{}{\judgeSok{x}{\tau} \\ \reduces{\tau}{\tau'}}{\judgeSok{x}{\tau'}}
  \end{mathpar}
\end{lemma}

\begin{proof}
  Induction on $\judgeSok{x}{\tau}$.
  \begin{itemize}
    \item For C-Cong (N-Cong), we apply the induction hypothesis and C-Cong (N-Cong, resp.).
    \item For E-FV, notice that the reduction does not increase the set of free variables,
      and thus, E-FV is applicable after the reduction of one of the $\tau_i$.
    \item The E-Cong case is a little bit more complicated.
      Notice that $\tau_1 \nrightarrow x$. This is because if $\tau_1$ is an
      eliminator, it must be inert by EE-Inert.
      Then we can consider in which $\tau_i$ the reduction happened, 
      apply the induction hypothesis and \cref{lemma:inertness-pres}.
    \item For the additional rules, the reduction can be either by congruence
      (and then we apply the induction hypothesis,
      \cref{lemma:cong-safe-occurrence} and the same rule) or by the
      top-level redex contraction, and then the required property is exactly one
      of the premises.
  \end{itemize}

\end{proof}

\section{Equivalence and Unification}

\begin{definition}[Syntax of algorithmic terms]
  \label{def:alg-terms}
  Throughout the algorithm, we will use the auxiliary pre-cooked terms,
  containing some unassigned parts. For this purpose, we extend the syntax of
  terms (\cref{def:syntax}) by adding the ``hatted'' unification (existential)
  variables $\hat{x}$ to the set of values:
  $$\mbox{Values} \inc \hat{x}$$
  Similarly, we extend the syntax from \cref{def:comp-syntax} by adding
  $\hat{x}$ to the Neutral Formers:
  $$\mbox{Neutral Formers} \inc \hat{x}$$
\end{definition}

\begin{notation}
To denote that the term is algorithmic, i.e. potentially contains the
unification variables, we use $\pi$ and $\rho$. If the term does not contain the
unification variables it is called \emph{ground} and denoted as $\sigma$ and
$\tau$.
\end{notation}

\begin{definition}[Safe algorithmic term]
  We say that the algorithmic term $\rho$ is \emph{safe} iff 
  all the unification variables occur safely in it:
  \begin{mathpar}
    \Infer{}
    {\forall \hat{x},~ \judgeSok{\hat{x}}{\rho}}
    {\judgeSokterm{\rho}}
  \end{mathpar}
\end{definition}


\begin{definition}[Binding Context]
  \begin{mathpar}
    \Gamma ::= \emptyctx \bnfalt \Gamma, ~ x
  \end{mathpar}
\end{definition}


\begin{definition}[Equivalence]
  We define equivalence on ground terms:

  \begin{itemize}

  \item[Reduction closure]
    \begin{mathpar}
      \Infer{Red-L}
      {
        \reduces{\tau_1}{\tau_1'}\\
        \judgeequivuntg{\Gamma}{\tau_1'}{\tau_2}
      }
      {
        \judgeequivuntg{\Gamma}{\tau_1}{\tau_2}
      }
      \and
      \Infer{}
      {
        \reduces{\tau_2}{\tau_2'}\\
        \judgeequivuntg{\Gamma}{\tau_1}{\tau_2'}\\
        \judgeSnf{\tau_1}
      }
      {
        \judgeequivuntg{\Gamma}{\tau_1}{\tau_2}
      }
    \end{mathpar}

  \item[Congruence]
    \begin{mathpar}

      \Infer{}
      {
        \judgeequivuntg{\Gamma}{P_1}{Q_1} \\
        \dots\\
        \judgeequivuntg{\Gamma}{P_{\narg{F}}}{Q_{\narg{F}}} \\
        \judgeSnf{\fullterm{F}{P}} \\
        \judgeSnf{\fullterm{F}{Q}}
      }
      {
        \judgeequivuntg{\Gamma}{\fullterm{F}{P}}{\fullterm{F}{Q}}
      }
      \and
      % \Infer{}
      % {
      %   z \text{ is fresh}\\
      %   \judgeequivunt
      %   {\rename{\absclose{n}{\sigma}}{x}{z}}
      %   {\rename{\absclose{n}{\tau}}{y}{z}}
      % }
      % {
      %   \judgeequivunt{x.\absclose{n}{\sigma}}{y.\absclose{n}{\tau}}
      % }
      % \and

      \Infer{}
      {
        \judgeequivuntg{\Gamma, x}
      {\absclose{n}{\sigma}}
      {\absclose{n}{\tau}}
      }
        {
          \judgeequivuntg{\Gamma}{x.\absclose{n}{\sigma}}{x.\absclose{n}{\tau}}
      }
        \and


      \Infer{}
      {
        \judgeequivuntg{\Gamma}{\sigma}{\tau}
      }
      {
        \judgeequivuntg{\Gamma}{.\sigma}{.\tau}
      }
    \end{mathpar}

  \end{itemize}

\end{definition}

\begin{definition}[Free Variable Environment] Free variable environment $E$ is a
  (partial) \emph{mapping} from unification variables to sets of regular
  variables. $E[\hat{v}]$ is a set $\Gamma$ of variables associated with $\hat{v}$
  that are allowed to be used in the initialization. Morally, $\Gamma$ is a
  binding context at the moment when $\hat{v}$ was introduced.
  \begin{mathpar}
    E ::= \emptyctx \bnfalt E, ~ \mapentry{\hat{v}}{\Gamma}
  \end{mathpar}
\end{definition}

\begin{definition}[Admissible term]
  \begin{mathpar}
    \Infer{}
    {\fv{\tau} \subseteq \Gamma}
    {\judgesafeinenv{\Gamma}{\tau}}
  \end{mathpar}
\end{definition}

\begin{definition}[Unification Context] Unification context represents a
  (partial) solution of the unification problem. Syntactically, it is a \emph{set} of
  pairs. Each pair represent an initialization of a unification variable: 
  $$\varphi, \psi ::= \emptyctx \bnfalt \varphi, \evarassign{\hat{v}}{\tau} $$
  where $\tau$ is a ground term.
\end{definition}

The unification (or algorithmic equivalence) judgement is of the form
$\judgeunify{E; \varphi}{\rho}{\rho'}{\varphi'}$ where $\rho$ and $\rho'$ are
algorithmic terms (potentially with unassigned variables), $\varphi$ and
$\varphi'$ are unification contexts, E is a free variable environment.


\begin{definition}[Admissible unification context] The unification context $\varphi$ is
  admissible by the environment $E$ if the term $\tau$ it assigns to the unification
  variable $\hat{v}$ is admissible by the set of variables $E[\hat{v}]$
  (in particular, $E$ is defined on $\hat{v}$).
  \begin{mathpar}
    \Infer{}
    { }
    {\judgesafeinenv{E}{\emptyctx}}

    \and
    \Infer{}
    {\judgesafeinenvv{E}{\hat{v}}{\tau}}
    {\judgesafeinenv{E}{\varphi, \evarassign{\hat{v}}{\tau}}}
  \end{mathpar}
\end{definition}


\begin{definition}[Well-formed unification context]
  We say that a unification context $\varphi$ is well-formed if the mapping it
  represents is a partial function, whose image terms are normal and ground:
  \begin{mathpar}

    \Infer{}
    { }
    {
      \judgectx{ }{\emptyctx}
    }
    \and
    \Infer{}
    { 
    \judgectx{ }{\varphi} \\
    \evarassign{\hat{x}}{\spcdot} \notin \varphi \\
    \judgeSnf{\tau}
    }
    {
      \judgectx{ }{\varphi, \evarassign{\hat{x}}{\tau}}
    }
  \end{mathpar}
\end{definition}

% \begin{definition}[Safe unification context]
%   We say that a unification context $\varphi$ is safe under the binding context $B$
%   ($\judgesafeinenv{B}{\varphi}$)
%   if the free variables of $\varphi$ do not intersect with $B$.
% \end{definition}

\begin{definition}[Application of the well-formed context]
  If the unification context $\varphi$ is well-formed,
  We write $\ctxtapp{\varphi}{\tau}$ meaning the application of the partial
  (substitution) function represented by $\varphi$ to the term $\tau$:
  \begin{itemize}
  \item $\ctxtapp{\emptyctx}{\tau} = \tau$
  \item $\ctxtapp{\varphi, \evarassign{\hat{x}}{\sigma}}{\tau} = \subst{(\ctxtapp{\varphi}{\tau})}{\hat{x}}{\sigma}$
  \end{itemize}

\end{definition}

Intuitively, when a context is applied to a term, the components of
the context are applied to the term one-by-one. This way, the properties holding
for a single substitution, can be lifted up to the context application.
\begin{corollary}[Context application commutes with the reduction]
  \label{corollary:red-app-commute}
    \begin{mathpar}
      \Infer{}
      {
        \judgectx{}{\Omega}\\
        \judgeSokterm{\rho}\\
        \reduces{\ctxtapp{\Omega}{\rho}}{\rho'}\\
      }
      {\exists \rho^* \text{ s.t. } \reduces{\rho}{\rho^*} \text{ and } \ctxtapp{\Omega}{\rho^*} = \rho'}
    \end{mathpar}
  \end{corollary}

  \begin{figure}[h]
    \centering
    \begin{tikzcd}
      \rho & {\rho^*} \\
      \bullet & {\rho^*_2} \\
      \bullet & {\rho^*_n} \\
      {[\Omega]\rho} & {\rho'}
      \arrow["{\hat{x}_1:=\tau_1}"', from=1-1, to=2-1]
      \arrow["{\hat{x}_1:=\tau_1}", dashed, from=1-2, to=2-2]
      \arrow["\rightarrow", dashed, from=1-1, to=1-2]
      \arrow["\rightarrow", dashed, from=2-1, to=2-2]
      \arrow[dotted, no head, from=2-1, to=3-1]
      \arrow[dotted, no head, from=2-2, to=3-2]
      \arrow["{\hat{x}_n := \tau_n}"', from=3-1, to=4-1]
      \arrow["\rightarrow", from=4-1, to=4-2]
      \arrow["\rightarrow", dashed, from=3-1, to=3-2]
      \arrow["{\hat{x}_n:=\tau_n}", dashed, from=3-2, to=4-2]
    \end{tikzcd}
    \caption{Proof scheme}
    \label{fig:red-app-commute-scheme}
  \end{figure}

  \begin{proof}
    Induction on $\ctxtapp{\Omega}{\rho}$ using \cref{lemma:red-subst-commute}.
    See \cref{fig:red-app-commute-scheme} for the details: we acquire $\rho^*$
    by consequently applying \cref{lemma:red-subst-commute} bottom-to-top to
    construct $\rho^*_n, \dots, \rho^*_2, \rho^*$.
    The premises required for \cref{lemma:red-subst-commute} hold because 
    $\judgectx{}{\Omega}$ and $\judgeSokterm{\rho}$.
  \end{proof}

  \begin{corollary} [Context application preserves reduction]
    \label{corollary:ctx-app-pres-red}
    \begin{mathpar}
      \Infer{}{\judgectx{}{\Omega} \\ \reduces{\rho}{\rho'}}
      {\reduces{\ctxtapp{\Omega}{\rho}}{\ctxtapp{\Omega}{\rho'}}}
    \end{mathpar}
  \end{corollary}
  \begin{proof}
    Induction on $\Omega$ using  \cref{lemma:subst-res}.
  \end{proof}
 
  \begin{corollary} [Reduction preserves safety]
    \label{corollary:safety-pres}
    \begin{mathpar}
      \Infer{}{\judgeSokterm{\rho} \\ \reduces{\rho}{\rho'}}{\judgeSokterm{\rho'}}
    \end{mathpar}
  \end{corollary}
  \begin{proof}
    Follows from \cref{lemma:safe-occur-pres}.
  \end{proof}


\begin{definition}[Unification]  The unification algorithm is defined
  as follows:

\begin{itemize}
    \item[Base rules]
      \begin{mathpar}
        \Infer{U-Add}
        { 
          \evarassign{\hat{v}}{\spcdot} \notin \varphi \\
          \judgeSnf{\tau} \\
          \judgesafeinenvv{E}{\hat{v}}{\tau} \\
        }
        {
          \judgeunify{\Gamma; E; \varphi}{\hat{v}}{\tau}{\varphi, \evarassign{\hat{v}}{\tau}}
        }
        \and
        \Infer{U-Keep}
        { 
          \evarassign{\hat{v}}{\tau} \in \varphi \\
          \ilyam{up-to-alpha-equivalence!}
        }
        {
          \judgeunify{\Gamma; E;\varphi}{\hat{v}}{\tau}{\varphi}
        }
      \end{mathpar}

    \item[Reduction closure]
      \begin{mathpar}
        \Infer{Red-L}
        {
          \reduces{\rho_1}{\rho_1'}\\
          \judgeunify{\Gamma; \varphi}{\rho_1'}{\tau_2}{\varphi'}
        }
        {
          \judgeunify{\Gamma; E; \varphi}{\rho_1}{\tau_2}{\varphi'}
        }
        \and
        \Infer{Red-R}
        {
          \reduces{\tau_2}{\tau_2'}\\
          \judgeunify{\Gamma; \varphi}{\rho_1}{\tau_2'}{\varphi'}\\
          \judgeSnf{\rho_1}
        }
        {
          \judgeunify{\Gamma; E; \varphi}{\rho_1}{\tau_2}{\varphi'}
        }
      \end{mathpar}

    \item[Congruence]
   \begin{mathpar}
     \Infer{}
     {
       \judgeunify{\Gamma; E;\varphi_0}{P_1}{Q_1}{\varphi_1} ~
       \dots ~
       \judgeunify{\Gamma; E;\varphi_{\narg{F}-1}}{P_{\narg{F}}}{Q_{\narg{F}}}{\varphi_{\narg{F}}} \\
       \judgeSnf{\fullterm{F}{P}} \\
       \judgeSnf{\fullterm{F}{Q}}
     }
     {
       \judgeunify{\Gamma; E; \varphi_0}{\fullterm{F}{P}}{\fullterm{F}{Q}}{\varphi_{\narg{F}}}
     } \and
     % \Infer{}
     % {
     %   z \text{ is fresh} \\
     %   \judgeunify{B,z; \varphi}
     %   {\rename{\absclose{n}{\rho}}{x}{z}}
     %   {\rename{\absclose{n}{\tau}}{y}{z}}
     %   {\psi}
     % }
     % {
     %   \judgeunify{B; \varphi}
     %   {x.\absclose{n}{\rho}}
     %   {y.\absclose{n}{\tau}}
     %   {\psi}
     % } \and

     \Infer{}
     {
       \judgeunify{\Gamma, x; E; \varphi}
       {\absclose{n}{\rho}}
       {\absclose{n}{\tau}}
       {\psi}
     }
     {
       \judgeunify{\Gamma; E; \varphi}
       {x.\absclose{n}{\rho}}
       {x.\absclose{n}{\tau}}
       {\psi}
     }
     \and

     \Infer{}
     {
       \judgeunify{\Gamma; E; \varphi}
       {\rho}
       {\tau}
       {\psi}
     }
     {
       \judgeunify{\Gamma; E; \varphi}
       {.\rho}
       {.\tau}
       {\psi}
     } \and


\end{mathpar}

\end{itemize}
\end{definition}


We prove the soundness and completeness of the unification w.r.t. the equality
defined above. Intuitively, soundness means that the output context produced by
the unification algorithm does not make the terms non-unifiable.

\begin{lemma} [Unification soundness]
  \begin{mathpar}
    \Infer{}
    { \judgectx{}{\varphi_1}\\
      \judgeunify{\Gamma; E; \varphi_1}{\rho}{\tau}{\varphi_2} \\
      \judgesafeinenv{E}{\varphi_1} \\
      \codom{E} \subseteq \Gamma
    }
    { \judgectx{}{\varphi_2}\\
      \judgeequivuntg{\Gamma}{\ctxtapp{\varphi_2}{\rho}}{\tau} \\
      \varphi_1 \subseteq \varphi_2 \\
      \judgesafeinenv{E}{\varphi_2} \\
    }
  \end{mathpar}
\end{lemma}

\begin{proof}
  Induction on $\judgeunify{\Gamma; E; \varphi_1}{\rho}{\tau}{\varphi_2}$.
  \begin{itemize}
    \item
      $
      \Infer{}
      { 
        \evarassign{\hat{v}}{\spcdot} \notin \varphi_1 \\
        \judgeSnf{\tau} \\
        \judgesafeinenvv{E}{\hat{v}}{\tau}
      }
      {
        \judgeunify{\Gamma; E; \varphi_1}{\hat{v}}{\tau}{\varphi_1, \evarassign{\hat{v}}{\tau}}
      }
      $
      Then $\rho = \hat{v}$ and $\varphi_2 = \varphi_1, \evarassign{\hat{v}}{\tau}$.
      \begin{itemize}
        \item It is easy to see that $\judgectx{}{\varphi_2}$ because
          $\judgectx{}{\varphi_1, \evarassign{\hat{v}}{\tau}}$  by definition of the
          well-formed context (all the required premises are given);
        \item $\ctxtapp{\varphi_2}{\rho} = \ctxtapp{\varphi_1,
            \evarassign{\hat{v}}{\tau}}{\hat{v}} = \tau$.
          $\judgeequivuntg{\Gamma}{\tau}{\tau}$;
        \item $\varphi_1 \subseteq \varphi_1, \evarassign{\hat{v}}{\tau}$ by definition;

        \item $\judgesafeinenv{E}{\varphi_1, \evarassign{\hat{v}}{\tau}}$
          because $\judgesafeinenv{E}{\varphi_1}$ and $\judgesafeinenvv{E}{\hat{v}}{\tau}$.
     \end{itemize}
   \item 
      $
      \Infer{}
      { 
        \evarassign{\hat{v}}{\tau} \in \varphi
      }
      {
        \judgeunify{\Gamma; E; \varphi}{\hat{v}}{\tau}{\varphi}
      }
      $
      Then $\rho = \hat{v}$ and $\varphi_1 = \varphi_2 = \varphi$.
      \begin{itemize}
      \item $\judgectx{}{\varphi_2}$ because $\varphi_2 = \varphi_1$ and
        $\judgectx{}{\varphi_1}$ is in the premises;
      \item $\judgeequivuntg{\Gamma}{\ctxtapp{\varphi_2}{\hat{v}}}{\tau}$ because
        $\judgectx{}{\varphi_2}$ and $\evarassign{\hat{v}}{\tau} \in \varphi_2$.
      \item $\varphi \subseteq \varphi$ trivially.
      \item $\judgesafeinenv{E}{\varphi_2}$ because $\varphi_2 = \varphi_1$ and
        $\judgesafeinenv{E}{\varphi_1}$ is in the lemma premises.
      \end{itemize}
    \item
      $
      \Infer{}
      {
        \reduces{\rho}{\rho'}\\
        \judgeunify{\Gamma; E; \varphi_1}{\rho'}{\tau}{\varphi_2}
      }
      {
        \judgeunify{\Gamma; E; \varphi_1}{\rho}{\tau}{\varphi_2}
      }
      $
      Then by the induction hypothesis:
      $\varphi_1 \subseteq \varphi_2$,
      $\judgectx{}{\varphi_2}$,
      $\judgesafeinenv{E}{\varphi_2}$,
      and $\judgeequivuntg{\Gamma}{\ctxtapp{\varphi_2}{\rho'}}{\tau}$.
      To prove that $\judgeequivuntg{\Gamma}{\ctxtapp{\varphi_2}{\rho}}{\tau}$ we apply Red-L:
      $$
      \Infer{Red-L}
      {
        \reduces{\ctxtapp{\varphi_2}{\rho}}{\ctxtapp{\varphi_2}{\rho'}}\\
        \judgeequivuntg{\Gamma}{\ctxtapp{\varphi_2}{\rho'}}{\tau}
      }
      {
        \judgeequivuntg{\Gamma}{\ctxtapp{\varphi_2}{\rho}}{\tau}
      }
      $$
      Here $\reduces{\ctxtapp{\varphi_2}{\rho}}{\ctxtapp{\varphi_2}{\rho'}}$
      holds by \cref{corollary:ctx-app-pres-red}.
    \item
      $
      \Infer{}
      {
        \reduces{\tau}{\tau'}\\
        \judgeunify{\Gamma; E; \varphi_1}{\rho}{\tau'}{\varphi_2}\\
        \judgeSnf{\rho}
      }
      {
        \judgeunify{\Gamma; E; \varphi_1}{\rho}{\tau}{\varphi_2}
      }
      $
      Analogously to the previous case.

    \item
      $
      \Infer{}
      {
        \judgeunify{\Gamma; E;\psi_0}{P_1}{Q_1}{\psi_1} \\
        \dots\\
        \judgeunify{\Gamma; E;\psi_{\narg{F}-1}}{P_{\narg{F}}}{Q_{\narg{F}}}{\psi_{\narg{F}}} \\
        \judgeSnf{\fullterm{F}{P}} \\
        \judgeSnf{\fullterm{F}{Q}}
      }
      {
        \judgeunify{\Gamma; E; \psi_0}{\fullterm{F}{\rho}}{\fullterm{F}{\tau}}{\psi_{\narg{F}}}
      }
      $

      Then $\varphi_1 = \psi_0$, $\varphi_2 = \psi_{\narg{F}}$, $\rho =
      \fullterm{F}{P}$, $\tau = \fullterm{F}{Q}$. 

      We can apply the induction hypothesis to the first unification judgement
      in the premise (i.e. to $\judgeunify{\Gamma; E; \psi_0}{P_1}{Q_1}{\psi_1}$) acquiring:
      $\judgectx{}{\psi_1}$,
      $\judgectx{E}{\psi_1}$,
      and
      $\judgeequivuntg{\Gamma}{\ctxtapp{\psi_1}{P_1}}{Q_1}$. Then, because
      $\judgectx{}{\psi_1}$, we can apply the induction hypothesis to the second
      premise. Continuing this process, we acquire:
      \begin{itemize}
        \item
          $\varphi_1 = \psi_0 \subseteq \cdots \subseteq \psi_{\narg{F}} = \varphi_2$;
        \item
          $\judgectx{}{\varphi_2}$
        \item
          $\judgectx{E}{\varphi_2}$
        \item $\judgeequivuntg{\Gamma}{\ctxtapp{\psi_i}{P_i}}{Q_i}$ for $i =
          1\dots\narg{F}$. Hence, because $\psi_i \subseteq \varphi_2$,
          $\judgeequivuntg{\Gamma}{\ctxtapp{\varphi_2}{P_i}}{Q_i}$, which implies
          that $\judgeequivuntg{\Gamma}{\ctxtapp{\varphi_2}{\fullterm{F}{P}}}{\fullterm{F}{Q}}$
      \end{itemize}

      \item
        $
        \Infer{}
        {
          \judgeunify{\Gamma, x; E; \varphi_1}
          {\absclose{n}{\rho}}
          {\absclose{n}{\tau}}
          {\varphi_2}
        }
        {
          \judgeunify{\Gamma; E; \varphi_1}
          {x.\absclose{n}{\rho}}
          {x.\absclose{n}{\tau}}
          {\varphi_2}
        }
      $

      Then we apply the induction hypothesis to
      $ \judgeunify{\Gamma, x; E; \varphi_1} {\absclose{n}{\rho}} {\absclose{n}{\tau}} {\varphi_2} $
      and acquire 
      \begin{itemize}
        \item $\judgectx{}{\varphi_2}$
        \item $\varphi_1 \subseteq \varphi_2$
        \item $\judgectx{E}{\varphi_2}$
        \item
          $\judgeequivunt{\ctxtapp{\varphi_2}{\absclose{n}{\rho}}}{\absclose{n}{\tau}}$.
          By the Barendrecht's convention, $x \notin \Gamma$, hence, 
          $x \notin \codom{E}$. Since $\judgectx{E}{\varphi_2}$, $x \notin \fv{\varphi_2}$.
          Therefore, $x.\ctxtapp{\varphi_2}{\absclose{n}{\rho}} =
          \ctxtapp{\varphi_2}{x.\absclose{n}{\rho}}$, which gives us the
          required equivalence. 
          \ilyam{extract a lemma}
      \end{itemize}

    \item
      $
      \Infer{}
      {
        \judgeunify{\Gamma; E; \varphi}
        {\rho}
        {\tau}
        {\psi}
      }
      {
        \judgeunify{\Gamma; E; \varphi}
        {.\rho}
        {.\tau}
        {\psi}
      }
      $ 
      Trivially by the induction hypothesis. 




  \end{itemize}

\end{proof}


% \begin{lemma}[Reflexivity of unification]
%   $\judgeunify{\Gamma; E;\varphi}{\tau}{\tau}{\varphi}$
% \end{lemma}
% \begin{proof}
%   Straightforward induction.
% \end{proof}

% \begin{lemma} [Unification invariance under substitution]
%   \label{lemma:unif-inv-under-subst}
%   \begin{mathpar}
%     \Infer{}
%     {\judgeunify{\Gamma; E;\varphi}{\rho}{\tau}{\psi} \\
%      x \notin \fv{\psi}
%     }
%     {\judgeunify{\Gamma; E;\varphi}{\subst{\rho}{x}{\sigma}}{\subst{\tau}{x}{\sigma}}{\psi}}
%   \end{mathpar}
% \end{lemma}
% \begin{proof}
%   Induction on 
%   $\judgeunify{E;\varphi}{\rho}{\tau}{\psi}$.
%   \ilyam{seems straightforward}
% \end{proof}


\begin{lemma} [Unification completeness]
  \begin{mathpar}
    \Infer{}
    {
      \judgectx{E}{\Omega}\\
      \judgectx{}{\Omega}\\
      \judgeSokterm{\rho}\\
      \judgeequivuntg{\Gamma}{\ctxtapp{\Omega}{\rho}}{\tau}\\
    }
    {
      \forall \varphi \subseteq \Omega. ~ \exists \psi \subseteq \Omega. ~
      \judgeunify{\Gamma; E; \varphi}{\rho}{\tau}{\psi} \\
    }
  \end{mathpar}

\end{lemma}

\begin{proof}
  Induction on $\judgeequivunt{\ctxtapp{\Omega}{\rho}}{\tau}$.
  
  \begin{itemize}
  \item
    $
    \Infer{}
      {
        \reduces{\ctxtapp{\Omega}{\rho}}{\rho'}\\
        \judgeequivuntg{\Gamma}{\rho'}{\tau}
      }
      {
        \judgeequivuntg{\Gamma}{\ctxtapp{\Omega}{\rho}}{\tau}
      }
      $ By \cref{corollary:red-app-commute}, there exists $\rho^*$ s.t.
      $\reduces{\rho}{\rho^*}$ and $\ctxtapp{\Omega}{\rho^*} = \rho'$.


      By \cref{lemma:safe-occur-pres}, $\judgeSokterm{\rho^*}$.
      Then we apply the induction hypothesis to $E$, $\Omega$, $\rho^*$, and $\tau$.
      To acquire $\forall \varphi \subseteq \Omega. ~ \exists \psi \subseteq \Omega. ~
      \judgeunify{\Gamma; E; \varphi}{\rho^*}{\tau}{\psi}$,
      where we can replace $\rho^*$ with $\rho$ by Red-L.

  \item
    $
    \Infer{}
    {
      \reduces{\tau}{\tau'}\\
      \judgeequivuntg{\Gamma}{\ctxtapp{\Omega}{\rho}}{\tau'}\\
      \judgeSnf{\ctxtapp{\Omega}{\rho}}
    }
    {
      \judgeequivuntg{\Gamma}{\ctxtapp{\Omega}{\rho}}{\tau}
    }
    $
    We can apply the induction hypothesis to $E, \Omega$, $\rho$, $\Gamma$, and $\tau'$ right
    away to acquire $\forall \varphi \subseteq \Omega. ~ \exists \psi \subseteq
    \Omega. ~ \judgeunify{\Gamma; E;\varphi}{\rho}{\tau'}{\psi}$, where we replace $\tau'$
    with $\tau$ by Red-R.

  \item
    $
    \Infer{}
    {
      \judgeequivuntg{\Gamma}{Q_1}{Q'_1} \\
      \dots\\
      \judgeequivuntg{\Gamma}{Q_{\narg{F}}}{Q'_{\narg{F}}} \\
      \judgeSnf{\fullterm{F}{Q}} \\
      \judgeSnf{\fullterm{F}{Q'}}
    }
    {
      \judgeequivuntg{\Gamma}{\fullterm{F}{Q}}{\fullterm{F}{Q'}}
    }
    $
    Then $\ctxtapp{\Omega}{\rho} = \fullterm{F}{Q}$ and $\tau =
    \fullterm{F}{Q'}$.
    Let us destruct $\ctxtapp{\Omega}{\rho}$. \ilyam{we need a lemma to destruct
    it this way}
    \begin{itemize}
      \item $\rho = \hat{x}$ and $\evarassign{\hat{x}}{\fullterm{F}{Q}} \in
        \Omega$. Let us consider an arbitrary $\varphi \subseteq \Omega$.
        $\varphi$ is well-formed, then either $\evarassign{\hat{x}}{\fullterm{F}{Q}} \in
        \varphi$ or $\evarassign{\hat{x}}{\spcdot} \notin \varphi$.
        \begin{itemize}
        \item $\evarassign{\hat{x}}{\fullterm{F}{Q}} \in \varphi$ then we
          take $\psi = \varphi$ and apply U-Keep. 
        \item $\evarassign{\hat{x}}{\spcdot} \notin \varphi$ then we
          take $\psi = \varphi, \evarassign{\hat{x}}{\fullterm{F}{Q}}$
          and apply U-Add. The term $\fullterm{F}{Q}$
          is in the normal form by one
          of the premises. $\judgectx{E[\hat{x}]}{\fullterm{F}{Q}}$ because
          $\judgectx{E}{\Omega} \ni \evarassign{\hat{x}}{\fullterm{F}{Q}}$.

        \end{itemize}
      \item $\rho = \fullterm{F}{P}$, $F \neq \hat{x}$, 
        $\ctxtapp{\Omega}{P_i} = Q_i$ and $\judgeequivuntg{\Gamma}{Q_i}{Q'_i}$ for $i = 1\dots\narg{F}$.

        By the corollary of \cref{lemma:cong-safe-occurrence},
        $\judgeSokterm{P_i}$. So we can apply the induction hypothesis to all
        the components to acquire $\narg{F}$ facts: $\forall \varphi \subseteq \Omega.
        ~ \exists \psi \subseteq \Omega. ~ \judgeunify{\Gamma; E; \varphi}{P_i}{Q'_i}{\psi}$.

        Let us apply the first fact to an arbitrary $\varphi = \psi_0 \subseteq
        \Omega$ to acquire $\psi_1 \subseteq \Omega$. Then we apply the second
        fact to $\psi_1 $, acquiring $\psi_2 \subseteq \Omega$. Repeating the process, we have:
        $\judgeunify{\Gamma; E; \psi_0}{P_1}{Q'_1}{\psi_1}, ~ \dots, ~
        \judgeunify{\Gamma; E; \psi_{\narg{F}-1}}{P_{\narg{F}}}{Q'_{\narg{F}}}{\psi_{\narg{F}}}$.

        Notice that by \cref{lemma:subst-res,prop:nf-irred},
        $\judgeSnf{\fullterm{F}{P}}$. Then we apply the congruence
        unification rule and get
        $\judgeunify{\Gamma; E;\varphi}{\fullterm{F}{P}}{\fullterm{F}{Q'}}{\psi_{\narg{F}}}$,
        i.e. $\judgeunify{\Gamma; E;\varphi}{\rho}{\tau}{\psi_{\narg{F}}}$, so we take
        $\psi_{\narg{F}}$ as $\psi$.

    \end{itemize}
    
  \item
    $
    \Infer{}
    {\judgeequivuntg{\Gamma, x}{\absclose{n}{\sigma}} {\absclose{n}{\tau}} }
    {\judgeequivuntg{\Gamma}{x.\absclose{n}{\sigma}}{x.\absclose{n}{\tau}}}
    $

    Then
    $\ctxtapp{\Omega}{\rho} = x.\absclose{n}{\sigma}$, which means that $\rho =
    x.\absclose{n}{\rho'}$, and  $\ctxtapp{\Omega}{\absclose{n}{\rho'}} =
    \absclose{n}{\sigma}$. Notice that
    $\judgeSokterm{\absclose{n}{\rho'}}$, which means the induction hypothesis
    is applicable and gives us $\forall \varphi \subseteq \Omega. ~ \exists \psi
    \subseteq \Omega. ~
    \judgeunify{\Gamma,x;E;\varphi}{\absclose{n}{\rho'}}{\absclose{n}{\tau}}{\psi}$.
    % We choose a fresh variable $y$. By \cref{lemma:unif-inv-under-subst},
    % $\forall \varphi \subseteq \Omega. ~ \exists \psi \subseteq \Omega. ~
    % \judgeunify{E;\varphi}{\rename{(\absclose{n}{\rho'})}{x}{y}}{\rename{(\absclose{n}{\sigma})}{x}{y}}{\psi}$.
    Then we can apply the corresponding
    unification rule to get the required unification judgement: 
    $\judgeunify{\Gamma; E; \varphi}{x.\absclose{n}{\rho'}}{x.\absclose{n}{\tau}}{\psi}$.

  \item
    $
    \Infer{}
    {
      \judgeequivunt{\sigma}{\tau}
    }
    {
      \judgeequivunt{.\sigma}{.\tau}
    }
    $
    Trivially by the induction hypothesis.
    
  \end{itemize}

\end{proof}



% \begin{lemma} [Unification completeness]
%   If $\varphi(\rho)$ or $\varphi(\rho')$ is ground and 
%   $\judgeunify{\varphi}{\rho}{\rho'}{\varphi'}$ holds, then $\varphi'(\rho)$
%   and $\varphi'(\rho')$ are ground.
% \end{lemma}
% \ilyam{There might be some problems with the meaningless existential variables}




\section{Typing}
\label{sec:rules}


\begin{definition}[Typing declarative context]
\begin{mathpar}
  \begin{array}{llcl}

    \mbox{Contexts} & \Gamma & ::= & \emptyctx \bnfalt \Gamma, x:A \bnfalt \Gamma, \isvtype{B} \\[1em]
  \end{array}
\end{mathpar}
\end{definition}


To make the typing decidable, we restrict the system in several ways. In particular,
when we form $\foralltype{x:A}{X}$, we require $x$ to belong to $\fv{X}$ and occur
safely in $X$.

\subsection{Context Well-formedness}

\begin{mathpar}
  \Infer{Ctx0}
        { }
        { \judgectx{}{\emptyctx}}

        \and
 \Infer{CtxIT}
       { \judgectx{ }{\Gamma} }
       { \judgectx{ }{\Gamma,\isvtype{x}}}

       \and
 \Infer{CtxI}
       { \judgevtype{\Gamma}{A} \\
         \judgectx{ }{\Gamma} }
       { \judgectx{ }{\Gamma,x:A}}
\end{mathpar}

\subsection{Context Formation and Var}
Here, $j$ denotes the context entry: either $(x : A)$ or $(\isvtype{x})$.

\begin{mathpar}

\Infer{CtxExt}
      { \judgeInctx{j}{\Gamma} }
      { \judgeInctx{j}{(\Gamma, y:B)} }
\and

\Infer{CtxExtT}
      { \judgeInctx{j}{\Gamma} }
      { \judgeInctx{j}{(\Gamma, \isvtype{B})} }
\and

\Infer{CtxInit}
      {  }
      { \judgeInctx{j}{(\Gamma, j)} }
\and

\Infer{Var}
      { \judgeInctx{x:A}{\Gamma} }
      { \judgevInfer{\Gamma}{x}{A} }
\and

\Infer{VarT}
      { \judgeInctx{\isvtype{x}}{\Gamma} }
      { \judgevtype{\Gamma}{x} }
\and

\end{mathpar}
\subsection{Subsumption}

\begin{mathpar}
  
  \Infer{$\csubt$}
        { \judgecInfer{\Gamma}{t}{Y} \\
          \judgecsubt{\Gamma}{X}{Y} \\
          }
        { \judgecCheck{\Gamma}{t}{X} }
  \and

  \Infer{$\vsubt$}
        { \judgevInfer{\Gamma}{v}{B} \\
          \judgevsubt{\Gamma}{A}{B} \\
        }
        { \judgevCheck{\Gamma}{v}{A} }
\end{mathpar}

% \subsection{Subsumption}

% \begin{mathpar}
%   \Infer{$\csubt$}
%   { \judgecCheck{\Gamma}{t}{X} \\
%     \judgecsubt{\Gamma}{X}{Y}}
%   { \judgecCheck{\Gamma}{t}{Y} }
%   \and

%   \Infer{$\vsubt$}
%   { \judgevCheck{\Gamma}{v}{A} \\
%     \judgevsubt{\Gamma}{A}{B}}
%   { \judgevCheck{\Gamma}{v}{B} }
% \end{mathpar}  


\subsection{Universes}
\label{sec:rules:universes}

\begin{mathpar}
  \Infer{$\vtoc$}
        { \judgevtype{\Gamma}{A} }
        { \judgectype{\Gamma}{\valtocomp{A}} }
        \and

  \Infer{$\ctov$}
        { \judgectype{\Gamma}{X} }
        { \judgevtype{\Gamma}{\comptoval{X}} }
  \and

  \Infer{$\Pi$}
        { \judgevtype{\Gamma}     {A} \\
          \judgectype{\Gamma, x:A}{X} }
        { \judgectype{\Gamma}{\pitype{x:A}{X}} }
  \and

  \Infer{$\forall$}
        { \judgevtype{\Gamma}     {A} \\
          \judgectype{\Gamma, x:A}{X} \\
          x \in \fv{X} \\
          \judgeSok{x}{X}
        }
        { \judgectype{\Gamma}{\foralltype{x:A}{X}} }
        \and

  \Infer{$\Sigma$}
        { \judgevtype{\Gamma}     {A} \\
          \judgevtype{\Gamma, x:A}{B} }
        { \judgevtype{\Gamma}{\sigmatype{x:A}{B}} }
  \and
  

  \Infer{$\mathsf{eq}$}
        { \judgevtype{\Gamma}{A} \\
          \judgevCheck{\Gamma}{v}{A} \\
          \judgevCheck{\Gamma}{w}{A} }
        { \judgevtype{\Gamma}{\eqtype{A}{v}{w}} }
  \and

  \Infer{Let-type}
        { \judgectype{\Gamma, x:A}{X} \\
          \judgecCheck{\Gamma}{e}{A} }
        { \judgectype{\Gamma}{(\letval{x:A}{e}{X})} }
  \and

\end{mathpar}

\subsection{$\vtoc$ and $\ctov$}
\begin{mathpar}

  \Infer{$\ctov$I$\checks$}
        { \judgecCheck{\Gamma}{t}{X} }
        { \judgevCheck{\Gamma}{\thunk{t}}{\comptoval{X}}}

  \and
  \Infer{$\ctov$I$\infers$}
        { \judgecInfer{\Gamma}{t}{X} }
        { \judgevInfer{\Gamma}{\thunk{t}}{\comptoval{X}}}

  \and

  \Infer{$\ctov$E$\checks$}
        { \judgevCheck{\Gamma}{v}{\comptoval{X}} }
        { \judgecCheck{\Gamma}{\force{v}}{X}}

  \and
  \Infer{$\vtoc$E$\infers$}
        { \judgevInfer{\Gamma}{v}{\comptoval{X}} }
        { \judgecInfer{\Gamma}{\force{v}}{X}}
  \and


  \Infer{$\vtoc$I$\checks$}
        { \judgevCheck{\Gamma}{v}{A} }
        { \judgecCheck{\Gamma}{\return{v}}{\valtocomp{A}}}
  \and

  \Infer{$\vtoc$I$\infers$}
        { \judgevInfer{\Gamma}{v}{A} }
        { \judgecInfer{\Gamma}{\return{v}}{\valtocomp{A}}}
  \and
\end{mathpar}

\subsection{Let and Dependent Let}

\begin{mathpar}

  \Infer{Let$\infers$}
        {
          \judgecInfer{\Gamma, x : A}{u}{X} \\
          \judgecCheck{\Gamma}{t}{\valtocomp{A}} \\
          \judgectype{\Gamma}{X} \\ 
          \judgevtype{\Gamma}{A} \\ 
        }
        { \judgecInfer{\Gamma}{\letval{x : A}{t}{u}}{X} }
  \and
  \Infer{Let$\checks$}
        { \judgecCheck{\Gamma}{t}{\valtocomp{A}} \\ 
          \judgectype{\Gamma}{X} \\ 
          \judgecCheck{\Gamma, x : A}{u}{X}}
        { \judgecCheck{\Gamma}{\letval{x : A}{t}{u}}{X} }
  \and

  \Infer{DLet$\infers$}
        {
          \judgecInfer{\Gamma, x:A}{u}{X} \\
          \judgecCheck{\Gamma}{t}{\valtocomp{A}} \\
          \judgectype{\Gamma, x:A}{X} \\ 
        }
        { \judgecInfer{\Gamma}{\dletval{x:A}{t}{u}}{(\letval{x:A}{t}{X})} }
  \and
  \Infer{DLet$\checks$}
        { \judgecCheck{\Gamma}{t}{\valtocomp{A}} \\ 
          \judgectype{\Gamma, x:A}{X} \\ 
          \judgecCheck{\Gamma, x:A}{u}{X}}
        { \judgecCheck{\Gamma}{\dletval{x:A}{t}{u}}{(\letval{x:A}{t}{X})} }
  \and

\end{mathpar}

\subsection{$\forall$, $\Pi$, and $\Sigma$}

\begin{mathpar}

  %% \Infer{$\Pi$I$\infers$}
  %%       { \judgecCheck{\Gamma, x:A}{X}{\unicomp} \\
  %%         \judgecInfer{\Gamma, x:A}{t}{X} }
  %%       { \judgecInfer{\Gamma}{\fun{x:A}{t}}{\pitype{x:A}{X}} }
  %% \and

  \Infer{$\forall$I$\checks$}
        { \judgectype{\Gamma, x:A}{X} \\
          \judgecCheck{\Gamma, x:A}{t}{X} }
        { \judgecCheck{\Gamma}{\fun{x:A}{t}}{\foralltype{x:A}{X}} }
  \and

  \Infer{$\Pi$I$\checks$}
        { \judgectype{\Gamma, x:A}{X} \\
          \judgecCheck{\Gamma, x:A}{t}{X} }
        { \judgecCheck{\Gamma}{\fun{x:A}{t}}{\pitype{x:A}{X}} }
  \and

  \Infer{$\Pi$E}
        { \judgecInfer{\Gamma}{t}{\pitype{x:A}{X}} \\
          \judgevCheck{\Gamma}{v}{A} }
        { \judgecInfer{\Gamma}{t\,v}{\subst{X}{x}{v}} }
  \and

  %% \Infer{$\Sigma$I$\infers$}
  %%       { \judgevInfer{\Gamma}{v}{A} \\
  %%         \judgevInfer{\Gamma}{w}{B} \\
  %%         \judgevCheck{\Gamma}{A}{\unival} \\
  %%         \judgevCheck{\Gamma}{B}{\unival} }
  %%       { \judgevInfer{\Gamma}{\pair{v}{w}}{A \times B}}
  %% \and

  \Infer{$\Sigma$I$\checks$}
        { \judgevCheck{\Gamma}{v}{A} \\
          \judgevCheck{\Gamma}{w}{\subst{B}{x}{v}} \\
          \judgevtype{\Gamma}{\sigmatype{x:A}{B}} }
        { \judgevCheck{\Gamma}{\pair{v}{w}}{\sigmatype{x:A}{B}} }
   \and


  \Infer{$\Sigma$E}
        {
          \judgevInfer{\Gamma}{v}{\sigmatype{x:A}{B}} \\
          \judgectype{\Gamma, p : (\sigmatype{x:A}{B})}{X} \\
          \judgecCheck{\Gamma}{t}{\pitype{(x:A)(y:B)}{\subst{X}{p}{\pair{x}{y}}}}}
        { \judgecInfer{\Gamma}{\recsigma{v}{p.X}{t}}{\subst{X}{p}{v}}}
  \and

\end{mathpar}

\subsection{Equality}

\begin{mathpar}

  \Infer{$\mathsf{eq}$I}
        { \judgevtype{\Gamma}{A} \\
          \judgevCheck{\Gamma}{v}{A}}
        { \judgevCheck{\Gamma}{\refl}{\eqtype{A}{v}{v}} }

  \and

  \Infer{$\mathsf{eq}$E$\checks$}
        { \judgevInfer{\Gamma}{v}{\eqtype{A}{w_1}{w_2}} \\
          \judgectype{\Gamma, x:A, p:\eqtype{A}{w_1}{x}}{X} \\
          \judgecCheck{\Gamma}{t}{\subst{\subst{X}{x}{w_1}}{p}{\refl}}}
        { \judgecInfer{\Gamma}{\receq{v}{x.p.X}{t}}{\subst{\subst{X}{x}{w_2}}{p}{v}}}

\end{mathpar}







\section{Declarative Subtyping}

\begin{mathpar}

  \Infer{$\subt \Sigma$}
        {
          \judgevsubt{\Gamma}{A_1}{B_1}\\
          \judgevsubt{\Gamma, x:A_1}{A_2}{B_2}\\
        }
        {\judgevsubt{\Gamma}{\sigmatype{x:A_1}{A_2}}{\sigmatype{x:B_1}{B_2}}}

 \Infer{$\subt \Pi$}
       {
         \judgevsubt{\Gamma}{A_2}{A_1}\\
         \judgecsubt{\Gamma, x:A_2}{X_1}{X_2}\\
       }
       {\judgecsubt{\Gamma}{\pitype{x:A_1}{X_1}}{\pitype{x:A_2}{X_2}}}

  \Infer{$\subt \ctov$}
        {
          \judgecsubt{\Gamma}{X_1}{X_2} \\
          \judgecsubt{\Gamma}{X_2}{X_1} \\
        }
        {\judgevsubt{\Gamma}{\comptoval{X_1}}{\comptoval{X_2}}}

  \Infer{$\subt \vtoc$}
        {
          \judgevsubt{\Gamma}{A_1}{A_2} \\
          \judgevsubt{\Gamma}{A_2}{A_1} \\
        }
        {\judgecsubt{\Gamma}{\valtocomp{A_1}}{\valtocomp{A_2}}}

  \Infer{$\subt$Eq}
        {
          \judgevsubt{\Gamma}{A}{B} \\
          \judgeequivuntg{\vars{\Gamma}}{v_1}{v_2} \\
          \judgeequivuntg{\vars{\Gamma}}{w_1}{w_2} \\
        }
        {\judgevsubt{\Gamma}{\eqtype{A}{v_1}{w_1}}{\eqtype{B}{v_2}{w_2}}}
      
  \Infer{$\forall \subt$}
        {
          \judge{\Gamma}{v}{A}\\
          \judgecsubt{\Gamma}{\subst{X}{x}{v}}{Y}
        }
        {\judgecsubt{\Gamma}{(\foralltype{x:A}{X})}{Y}}
        
  \Infer{$\subt \forall$}
        {
          \judgecsubt{\Gamma, y : A}{X}{Y}\\
        }
        {\judgecsubt{\Gamma}{X}{(\foralltype{y:A}{Y})}}

  \Infer{let$\subt$}
        {
          \judgeequivuntg{\vars{\Gamma}}{e}{\return{v}}\\
          \judgecsubt{\Gamma}{\subst{X}{x}{v}}{Y}\\
        }
        { \judgecsubt{\Gamma}{(\letval{x:A}{e}{X})}{Y}}

        
  \Infer{$\subt$let}
        {
          \judgeequivuntg{\vars{\Gamma}}{e}{\return{v}}\\
          \judgecsubt{\Gamma}{X}{\subst{Y}{y}{v}}\\
        }
        { \judgecsubt{\Gamma}{X}{(\letval{y:A}{e}{Y})}}

  \Infer{let$\subt$let}
        {
          \judgevsubt{\Gamma}{A}{B}\\
          \judgevsubt{\Gamma}{B}{A}\\
          \judgeequivuntg{\vars{\Gamma}}{e_1}{e_2}\\
          \judgecsubt{\Gamma, x:A}{X}{Y}\\
         }
        {
          \judgecsubt{\Gamma}{\letval{x:A}{e_1}{X}}{\letval{x:B}{e_2}{Y}}
        }


\end{mathpar}


\section{Algorithmic Subtyping}

\begin{mathpar}

  \Infer{$\subt \Sigma$}
        {
          \judgeavsubt{\Gamma; E; \varphi}{A_1}{B_1}{\varphi'}\\
          \judgeavsubt{\Gamma, x:A_1; E; \varphi'}{A_2}{B_2}{\varphi''}\\
        }
        {\judgeavsubt{\Gamma; E; \varphi}{\sigmatype{x:A_1}{A_2}}{\sigmatype{x:B_1}{B_2}}{\varphi''}}

  \Infer{$\subt \Pi$}
        {
          \judgeavsubt{\Gamma; E; \varphi}{A_2}{A_1}{\varphi'}\\
          \judgeacsubt{\Gamma, x:A_2; E; \varphi'}{X_1}{X_2}{\varphi''}\\
        }
        {\judgeacsubt{\Gamma; E; \varphi}{\pitype{x:A_1}{X_1}}{\pitype{x:A_2}{X_2}}{\varphi''}}

  \Infer{$\subt \ctov$}
        {
          \judgeacsubt{\Gamma; E; \varphi}{X_2}{X_1}{\varphi'} \\
          \judgeacsubt{\Gamma; E; \varphi'}{X_1}{\ctxtapp{\varphi'}{X_2}}{\varphi''} \\
        }
        {\judgeavsubt{\Gamma; E; \varphi}{\comptoval{X_1}}{\comptoval{X_2}}{\varphi''}}

  \Infer{$\subt \vtoc$}
        {
          \judgeavsubt{\Gamma; E; \varphi}{A_2}{A_1}{\varphi'} \\
          \judgeavsubt{\Gamma; E; \varphi'}{\ctxtapp{\varphi'}{A_1}}{A_2}{\varphi''} \\
        }
        {\judgeacsubt{\Gamma; E; \varphi}{\valtocomp{A_1}}{\valtocomp{A_2}}{\varphi''}}
  
  \Infer{$\subt$Eq}
        {
          \judgeavsubt{\Gamma; E; \varphi}{A}{B}{\varphi'} \\
          \judgeunify{\vars{\Gamma}; E; \varphi'}{v_2}{v_1}{\varphi''} \\
          \judgeunify{\vars{\Gamma}; E; \varphi''}{w_2}{w_1}{\varphi'''} \\
        }
        {\judgevsubt{\Gamma}{\eqtype{A}{v_1}{w_1}}{\eqtype{B}{v_2}{w_2}}}

   \Infer{$\forall \subt$}
         {
           \judgeacsubt{\Gamma; E, (\mapentry{\hat{v}}{\vars{\Gamma}}); \varphi}
                       {\rename{X}{x}{\hat{v}}}
                       {Y}
                       {\varphi'}
         }
         {\judgeacsubt{\Gamma; E; \varphi}{(\foralltype{x:A}{X})}{Y}{\varphi'}}

   \Infer{$\subt \forall$}
         {
           \judgeacsubt{\Gamma, y : A; E; \varphi}{X}{Y}{\varphi'}\\
         }
         {\judgeacsubt{\Gamma; E; \varphi}{X}{(\foralltype{y:A}{Y})}{\varphi'}}

   \Infer{let$\subt$}
         {
           {\color{blue} e \text{ and } A \text{ are ground}}\\
           \judgeequivuntg{\vars{\Gamma}}{e}{\return{v}}\\
           \judgeacsubt{\Gamma; E; \varphi}
                       {\subst{X}{x}{v}}{Y}{\varphi'}\\
         }
         { \judgeacsubt{\Gamma; E; \varphi}{(\letval{x:A}{e}{X})}{Y}{\varphi'}}

   \Infer{$\subt$let}
         {
           \judgeequivuntg{\vars{\Gamma}}{e}{\return{v}}\\
           \judgeacsubt{\Gamma; E; \varphi}
                       {X}
                       {\subst{Y}{y}{v}}
                       {\varphi'}\\
         }
         { \judgeacsubt{\Gamma; E; \varphi}{X}{(\letval{y:A}{e}{Y})}{\varphi'} }

   \Infer{let$\subt$let}
         {
           \judgeavsubt{\Gamma; E; \varphi}{B}{A}{\varphi_1}\\
           \judgeavsubt{\Gamma; E; \varphi_1}{\ctxtapp{\varphi_1}{A}}{B}{\varphi_2}\\
           \judgeunify{\vars{\Gamma};  E; \varphi_2}{e_1}{e_2}{\varphi_3}\\
           \judgeacsubt{\Gamma, x:{\color{blue} \ctxtapp{\varphi_1}{A}}; E; \varphi_3}{X}{Y}{\varphi_4}\\
         }
         {
           \judgeacsubt{\Gamma; E; \varphi}{\letval{x:A}{e_1}{X}}{\letval{x:B}{e_2}{Y}}{\varphi_4}
         }

\end{mathpar}

\ilyam{I removed the context application everywhere except where it is needed to
preserve the ground invariance. The necessary assignments are kept in the unification
context.}

\ilyam{In (let$\subt$), type $A$ can have unresolved variables, hence, the first
  unification in the premises can instantiate them, and thus, must be
  algorithmic.}

\ilyam{In (let$\subt$), we require $e$ to be ground, which makes the algorithmic
  system incomplete w.r.t. the declarative system.\\
  E.g. $(\foralltype{x:1}{\letval{y:1}{\return{x}}{\valtocomp{\eqtype{\comptoval{\valtocomp{1}}}{\thunk{y}}{\thunk{y}}}}}) \leqslant \eqtype{\comptoval{\valtocomp{1}}}{\thunk{\return{()}}}{\thunk{\return{()}}}$
  holds for the declarative system but not for the algorithmic.}

\subsection{Natural Numbers and Undecidability}

The type system can be easily extended with natural numbers. To this purpose, we
must add $\nattype$, $\natzero$, and $\natsucc{v}$ to the values, and
$\recnat{v}{X}{base}{step}$ to the computations with obvious typing inference
rules.
We also add $\reduces{\recnat{\natzero}{X}{b}{s}}{b}$ and
$\reduces{\recnat{\natsucc{v}}{X}{b}{s}}{s \, v \, \recnat{v}{X}{b}{s}}$ to the reduction rules.

Notice that we do not unify under the induction operators. For example,
$\judgeunify{\varphi}{\recnat{\hat{v}}{X}{\natzero}{\fun{x\,y}{\natzero}}}{\natzero}{\varphi, \evarassign{\hat{v}}{\natzero}}$
is not admissible.
Moreover, the general unification is undecidable in this case.

Roughly, this is because we can easily define integers,
arithmetic operations, and hence, any arbitrary polynomial
$P(\hat{x_1}, \dots, \hat{x_n})$.
The unification of this polynomial with $\natzero$
corresponds to solving a diophantine equation, which is undecidable.

\subsection{Invariants}

We should be able to infer
$\judgeacsubt{\varphi}{(\letval{x:\valtocomp{\eqtype{A}{\hat{u}}{\hat{v}}}}{\hat{w}}{\valtocomp{Int}})}{\valtocomp{Int}}{\varphi}$.
As you can see, the unused existential variables $\hat{u}$ and $\hat{v}$ stay uninitialized.
It breaks the invariant that the subtyping algorithm `makes' both sides of $\leqslant$ ground (i.e. all existential variables are initialized in the output context).
As such, we weaken the notion of `ground` terms in such a way that they might have existential variables as long as they are not used in the outcome.

\ilyam{I've just realized that what I would like to mean by the usage of the variables depends on the evaluation. So maybe it's worth trying another approach,
  e.g. instantiate existential variables with `?' and promise that it won't cause any problem in the unification. }


\section{Properties}
\ilyam{Outdated}

%% \subsection{Mode-correctness}
%% \subsection{Regularity}

\begin{lemma}[Mode-correctness]
  Each rule in \cref{sec:rules} is mode-correct. Specifically, as defined in \cite{dunfield2021:bidirectional},
  \begin{enumerate}
    \item The premises are mode-correct: for each premise, every input meta-variable is known from the input of the rule's conclusion and the outputs of the earlier premises.
    \item The conclusion is mode-correct: if all premises have been derived, the outputs of the conclusion are known.
  \end{enumerate}
\end{lemma}
\begin{proof}
  First, we prove the mode-correctness of \emph{conclusion} for each rule.
  Note that it is only relevant for the \emph{synthesizing} rules, because for the \emph{checking} rules, the resulting type is given as an input.

  \begin{multicols}{2}
  \begin{itemize}
  \item[(Var)]
    $A$ is known from the input of the conclusion.
  \item[(Universes)]
    For rules in \cref{sec:rules:universes} ($\ctov$, $\vtoc$, $\Pi$,
    $\Sigma$, $\mathsf{eq}$), the resulting type (a universe) is the only
    possible option.

  \item[($\ctov$I$\infers$)]
    $X$ is known from the output of $\judgecInfer{\Gamma}{t}{X}$.

  \item[($\vtoc$E$\infers$)]
    $X$ is known from the output of $\judgevInfer{\Gamma}{v}{\comptoval{X}}$.

  \item[($\vtoc$I$\infers$)]
    $A$ is known from the output of $\judgevInfer{\Gamma}{v}{\comptoval{X}}$.

  \item[(Let$\infers$)]
    $X$ is known from the output of $\judgecInfer{\Gamma, x : A}{u}{X}$.

  \item[(DLet$\infers$)]
    $x$, $A$, and $t$ are given in the input of the conclusion; $X$ is known
    from the output of $\judgecInfer{\Gamma, x:A}{u}{X}$.

  \item[($\Pi$E)]
    $v$ is given in the input of the conclusion; $x$ and $X$ are known from the
    output of $\judgecInfer{\Gamma}{t}{\pitype{x:A}{X}}$.

  \item[($\Sigma$E)]
    $X$ and $v$ are given in the input of the conclusion.

  \item[($\mathsf{eq}$E$\infers$)]
    $X$ and $v$ are given in the input of the conclusion;
    $w_2$ is known from the output of $\judgevInfer{\Gamma}{v}{\eqtype{A}{w_1}{w_2}}$.
  \end{itemize}
  \end{multicols}

  Second, we let us show the mode-correctness of \emph{premises}.
  
  \newcommand{\fromconcl}{given in the input of the conclusion}

  \begin{multicols}{2}
  \begin{itemize}
      \item[(Ctx0)]
        There are no premises.

      \item[(CtxI)]
        $\Gamma$ and $A$ are \fromconcl.

      \item[(CtxExt)]
        $X$, $A$, and $\Gamma$ are \fromconcl.

      \item[(CtxInit)]
        There are no premises. 

      \item[(Var)]
        $x$, $A$, and $\Gamma$ are \fromconcl.

      \item[(EqivC)]
        $\Gamma$, $t$, and $X$ are \fromconcl;
        $Y$ is known from the output of $\judgecInfer{\Gamma}{t}{Y}$.

      \item[(EqivV)]
        $\Gamma$, $v$, and $A$ are \fromconcl;
        $B$ is known from the output of $\judgevInfer{\Gamma}{v}{B}$.

      \item[($\vtoc$)]
        $\Gamma$ and $A$ are \fromconcl.

      \item[($\ctov$)]
        $\Gamma$ and $X$ are \fromconcl.

      \item[($\Pi$)]
        $\Gamma$, $A$, $x$, and $X$ are \fromconcl.

      \item[($\Sigma$)]
        $\Gamma$, $A$, $x$, and $B$ are \fromconcl.

      \item[($\mathsf{eq}$)]
        $\Gamma$, $A$, $v$, and $w$ are \fromconcl.

      \item[($\unival$ and $\unicomp$)]
        There are no premises.

      \item[($\ctov$I$\checks$)]
        $\Gamma$, $t$, and $X$ are \fromconcl.

      \item[($\ctov$I$\infers$)]
        $\Gamma$ and $t$ are \fromconcl.

      \item[($\ctov$E$\checks$)]
        $\Gamma$, $v$, and $X$ are \fromconcl.

      \item[($\vtoc$E$\infers$)]
        $\Gamma$ and $v$ are \fromconcl.

      \item[($\vtoc$I$\checks$)]
        $\Gamma$, $v$, and $A$ are \fromconcl.

      \item[($\vtoc$I$\infers$)]
        $\Gamma$ and $v$ are \fromconcl.

      \item[(Let$\infers$)]
        $\Gamma$, $x$, $A$, $u$, and $t$ are \fromconcl;
        $X$ is known from the output of $\judgecInfer{\Gamma, x : A}{u}{X}$.
        
      \item[(Let$\checks$)]
        $\Gamma$, $t$, $A$, $X$, $x$, and $u$ are \fromconcl.

      \item[(DLet$\infers$)]
        $\Gamma$, $x$, $A$, $u$, and $t$ are \fromconcl.
        $X$ is known from the output of $\judgecInfer{\Gamma, x:A}{u}{X}$.

      \item[(DLet$\checks$)]
        $\Gamma$, $t$, $A$, $x$, $X$, and $u$ are \fromconcl.

      \item[($\Pi$I$\checks$)]
        $\Gamma$, $x$, $A$, $X$, and $t$ are \fromconcl.

      \item[($\Pi$E)]
        $\Gamma$, $t$, and $v$ are \fromconcl;
        $A$ is known from the output of $\judgecInfer{\Gamma}{t}{\pitype{x:A}{X}}$

      \item[($\Sigma$I$\checks$)]
        $\Gamma$, $v$, $A$, $w$, $B$, $x$ are \fromconcl.

      \item[($\Sigma$E)]
        $\Gamma$, $X$, and $v$, are \fromconcl;
        $x$, $A$, and $B$ are known from the output of
        $\judgecInfer{\Gamma}{X}{\sigmatype{x:A}{B} \to \unicomp}$;
        $y$ is an arbitrary fresh variable.
        
      \item[($\mathsf{eq}$I)]
        $\Gamma$, $A$, and $v$ are \fromconcl.

      \item[($\mathsf{eq}$E$\infers$)]
        $\Gamma$, $v$, $X$, and $t$ are \fromconcl;
        $A$ and $w_1$ are known from the output of $\judgevInfer{\Gamma}{v}{\eqtype{A}{w_1}{w_2}}$.
  \end{itemize}
  \end{multicols}


\end{proof}

\begin{lemma}[Context Soundness]
  \label{lemma:ctx-soundness}
  If $\judgeInctx{x:A}{\Gamma}$ and $\judgectx{}{\Gamma}$ then $\judgevCheck{\Gamma}{A}{\unival}$
\end{lemma}
\begin{proof}
  \ilyam{By trivial induction on $\judgeInctx{x:A}{\Gamma}$}
\end{proof}

\begin{lemma}[Regularity]
  The types synthesized by $\infers$ are well-formed. Specifically, the following properties hold
  \begin{enumerate}
  \item if $\judgectx{}{\Gamma}$ and $\judgevInfer{\Gamma}{v}{A}$ then $\judgevCheck{\Gamma}{A}{\unival}$
  \item if $\judgectx{}{\Gamma}$ and $\judgecInfer{\Gamma}{t}{X}$ then $\judgevCheck{\Gamma}{X}{\unicomp}$
  \end{enumerate}
\end{lemma}

\begin{proof}
  We prove this property by mutual structural induction on
  $\judgevInfer{\Gamma}{v}{A}$ and 
  $\judgecInfer{\Gamma}{t}{X}$.
  Let us consider the synthesizing rules.
  \begin{itemize}
  \item[(Var)]
    Since $(x : A)$ belongs to a \emph{well-formed} context $\Gamma$, 
    the property we need
    ($\judgevCheck{\Gamma}{A}{\unival}$) holds by \cref{lemma:ctx-soundness}.
  \item[(Universes)]
    Each rule in \cref{sec:rules:universes} synthesizes either $\unival$ or $\unicomp$.
    The desired properties hold by the following derivation trees:
    \begin{mathpar}
      \Infer{EqivV}
            {\Infer{$\unival$}
                    { }
                    { \judgevInfer{\Gamma}{\unival}{\unival} }\\
              \unival \equiv \unival \\
            }
            { \judgevCheck{\Gamma}{\unival}{\unival} }
      \and
      \Infer{EqivC}
            {\Infer{$\unicomp$}
              { }
              { \judgecInfer{\Gamma}{\unicomp}{\unicomp} }\\
              \unicomp \equiv \unicomp \\
            }
            { \judgecCheck{\Gamma}{\unicomp}{\unicomp} }

     \end{mathpar}
  \item[($\ctov$I$\infers$ and $\vtoc$I$\infers$)]
    The following derivation trees prove the required properties,
    where $\dag$ and $\ddag$ are derived from the inductive hypotheses.
    \begin{mathpar}
      \Infer{EqivC}
            {\Infer{$\ctov$}
              { \Infer{}{\dag}{\judgecCheck{\Gamma}{X}{\unicomp}} }
              { \judgevInfer{\Gamma}{\comptoval{X}}{\unival} } \\
              \comptoval{X} \equiv \comptoval{X} \\
            }
            { \judgevCheck{\Gamma}{\comptoval{X}}{\unival} }
      \and

      \Infer{EqivV}
            {\Infer{$\vtoc$}
              { \Infer{}{\ddag}{\judgevCheck{\Gamma}{A}{\unival}} }
              { \judgecInfer{\Gamma}{\valtocomp{A}}{\unicomp} } \\
              \valtocomp{A} \equiv \valtocomp{A} \\
            }
            { \judgecCheck{\Gamma}{\valtocomp{A}}{\unicomp} }

    \end{mathpar}
     
  \item[($\vtoc$E$\infers$)]
    \ilyam{Depends on $\unival \equiv \spcdot$ }
  \item[(Let$\infers$)]
    The desired property is in the premises.
  \item[(DLet$\infers$)]
    The following derivation tree proves the required property.
    $\judgecCheck{\Gamma}{t}{\valtocomp{A}}$ and 
    $\judgecInfer{\Gamma, x : A}{u}{\unicomp}$ are given as premises.
  \begin{mathpar}
    \Infer{Let$\checks$}
          { \judgecCheck{\Gamma}{t}{\valtocomp{A}} \\ 
            \Infer{ }{\Infer{$\unicomp$}{ }{\judgecInfer{\Gamma}{\unicomp}{\unicomp}}}
                     {\judgecCheck{\Gamma}{\unicomp}{\unicomp}} \\ 
            \Infer{ }{\judgecInfer{\Gamma, x : A}{u}{\unicomp}}
                     {\judgecCheck{\Gamma, x : A}{u}{\unicomp}}}
          { \judgecCheck{\Gamma}{\letval{x : A}{t}{u}}{\unicomp} }
          \and
  \end{mathpar}

\item[($\Pi$E)]
  \ilyam{Depends on $\equiv$ and requires the substitution lemma}
\item[($\Sigma$E)]
  By applying ($\Pi$E) to the first two premises. 

\item[($\mathsf{eq}$E$\infers$)]
  \ilyam{The same trick as in ($\Sigma$E) doesn't work...}

\end{itemize}


\end{proof}

\printbibliography

\end{document}


% (\x.x^, x^) = (\y.y, y)  |- x^:=y

% (\x.y, y) != (\y.y, y)



%  \forall x. n

