\documentclass[a4,natbib=false]{article}
\usepackage{fullpage}
\usepackage{amssymb}
\usepackage{amsmath,amsfonts,amsthm}
\usepackage{xcolor}
\usepackage{mathpartir}
\usepackage{cleveref}
\usepackage{multicol}

\usepackage[colorinlistoftodos]{todonotes} 

\setlength{\columnsep}{1cm}
\let\citename\relax
\usepackage[natbib=true, abbreviate=false, dateabbrev=true, isbn=true, doi=false, urldate=comp, url=true, maxbibnames=9, maxcitenames=2, backref=false, backend=biber, style=alphabetic, language=american]{biblatex}
\addbibresource{biblio.bib}


\newtheorem{lemma}{Lemma}
\newtheorem{definition}{Definition}

%% \newcommand{\ilyam}[2][]{\todo[linecolor=red,backgroundcolor=red!25,bordercolor=red,#1]{I: #2}}
\newcommand{\ilya}[2][]{\todo[linecolor=red,backgroundcolor=red!25,bordercolor=red,inline,#1]{Ilya: #2}}
\newcommand{\ilyam}[1]{{\color{red} \texttt{Ilya:  #1}}}

%%
\newcommand{\bnfalt}{\;\;|\;\;}



% Now we give some commands to define the syntax of the language. 

\newcommand{\fun}[2]{\lambda {#1}.\,{#2}}

\newcommand{\letval}[3]{\mathsf{let}\; {#1} \,:=\, {#2} \;\mathsf{in}\; {#3}}
\newcommand{\dletval}[3]{\mathsf{dlet}\; {#1} \,:=\, {#2} \;\mathsf{in}\; {#3}}

\newcommand{\pair}[2]{\left\langle{#1}, {#2}\right\rangle}
\newcommand{\fst}[1]{\mathsf{fst}\,{#1}}
\newcommand{\snd}[1]{\mathsf{snd}\,{#1}}

\newcommand{\unit}{\langle\rangle}

\newcommand{\ctov}{\mathcal{U}}
\newcommand{\vtoc}{\mathcal{F}}

\newcommand{\unival}{\square^{v}}
\newcommand{\unicomp}{\square^{c}}

\newcommand{\vtype}{\mathsf{vtype}}
\newcommand{\ctype}{\mathsf{ctype}}

\newcommand{\comptoval}[1]{\downarrow \hspace{-2pt} #1}
\newcommand{\valtocomp}[1]{\uparrow \hspace{-2pt} #1}
\newcommand{\sigmatype}[2]{\Sigma {#1}.\,#2}
\newcommand{\pitype}[2]{\Pi {#1}.\,#2}
\newcommand{\foralltype}[2]{\forall {#1}.\,#2}
\newcommand{\eqtype}[3]{\mathsf{eq}{#1}\,{#2}\,{#3}}
\newcommand{\refl}{\mathsf{refl}}
\newcommand{\force}[1]{\mathsf{force}\,{#1}}
\newcommand{\return}[1]{\mathsf{return}\,{#1}}
\newcommand{\thunk}[1]{\{{#1}\}}

\newcommand{\recsigma}[3]{\mathsf{rec}_{\Sigma}^{#2}({#1},{#3})}
\newcommand{\receq}[3]{\mathsf{rec}_{\mathsf{eq}}^{#2}({#1},{#3})}

\newcommand{\subst}[3]{{#1}\{{#2}\,:=\,{#3}\}}

\newcommand{\subt}{\leqslant}
\newcommand{\vsubt}{\leqslant^v}
\newcommand{\csubt}{\leqslant^c}

\newcommand{\isvtype}[1]{{#1} \, \mathsf{vtype}}
\newcommand{\isctype}[1]{{#1} \, \mathsf{ctype}}

\newcommand{\ctxtapp}[2]{[{#1}] {#2}}
\newcommand{\evarassign}[2]{{#1} \mathsf{:=} {#2}}



\newcommand{\reduces}[2]{{#1} \rightarrow {#2}}


\newcommand{\nattype}{\mathbb{N}}
\newcommand{\natzero}{\mathsf{0}}
\newcommand{\natsucc}[1]{\mathsf{succ}({#1})}
\newcommand{\recnat}[4]{\mathsf{rec}_{\nattype}^{#2}({#1},{#3},{#4})}

% This is a command to define a judgement -- we'll one command per judgement
% for delta-CBPV

\newcommand{\judge}[3]{{#1} \vdash {#2} : {#3}}
\newcommand{\judgectx}[2]{{#1} \vdash {#2}}


\newcommand{\checks}{{\color{blue} \Leftarrow}}
\newcommand{\infers}{{\color{brown} \Rightarrow}}

\newcommand{\judgec}[3]{{#1} \vdash_{c} {#2} : {#3}}
\newcommand{\judgecCheck}[3]{{#1} \vdash_{c} {#2} \, \checks \,  {#3}}
\newcommand{\judgecInfer}[3]{{#1} \vdash_{c} {#2} \, \infers \, {#3}}

\newcommand{\judgev}[3]{{#1} \vdash_{v} {#2} : {#3}}
\newcommand{\judgevCheck}[3]{{#1} \vdash_{v} {#2} \, \checks \, {#3}}
\newcommand{\judgevInfer}[3]{{#1} \vdash_{v} {#2} \, \infers \, {#3}}

\newcommand{\judgeInctx}[2]{{#1} \in {#2}}

\newcommand{\judgevtype}[2]{{#1} \vdash \isvtype{#2}}
\newcommand{\judgectype}[2]{{#1} \vdash \isctype{#2}}


\newcommand{\judgevsubt}[3]{{#1} \vdash {#2} \vsubt {#3}}
\newcommand{\judgecsubt}[3]{{#1} \vdash {#2} \csubt {#3}}

\newcommand{\judgeequiv}[4]{{#1} \vdash {#2} \equiv {#3} : {#4}}

\newcommand{\judgeavsubt}[4]{{#1}\,{\color{purple}\vdash} {#2} \vsubt {#3} {\color{purple}\dashv}\,{#4}}
\newcommand{\judgeacsubt}[4]{{#1}\,{\color{purple}\vdash} {#2} \csubt {#3} {\color{purple}\dashv}\,{#4}}

\newcommand{\judgeaequiv}[5]{{#1}\,{\color{purple}\vdash} {#2} \equiv {#3} : {#4}{\color{purple}\dashv}\,{#5}}

% This is a command to define an inference rule. The optional argument to
% \inferrule* is the label for the rule. 
% 
\newcommand{\Infer}[3]{\inferrule*[right={#1}]{#2}{#3}}

\begin{document}

\section{Syntax}

\begin{mathpar}
  \begin{array}{llcl}
    \mbox{Computations} & X, Y, t, u & ::= & t v \bnfalt
    \valtocomp{A} \bnfalt \pitype{x:A}{X} \bnfalt \foralltype{x:A}{X} \bnfalt \force {v} \bnfalt \return{v}
    \bnfalt \fun{x:A}{t} \bnfalt \\ & & & \letval{x : A}{t}{u} \bnfalt
    \dletval{x : A}{t}{u} \bnfalt \recsigma{v}{X}{t} \bnfalt \receq{v}{X}{t}
    \\[1em]

    \mbox{Values} & A, B, v, w & ::= & x \bnfalt \comptoval{X}
    \bnfalt \sigmatype{x:A}{B} \bnfalt \refl \bnfalt \eqtype{A}{v}{w} \bnfalt
    \thunk{t} \bnfalt \pair{v}{w} \\[1em]

    \mbox{Contexts} & \Gamma & ::= & \cdot \bnfalt \Gamma, x:A \\[1em]
  \end{array}
\end{mathpar}

\section{Rules}
\label{sec:rules}

\ilyam{How to make clickable references to the inference rule names?}



\subsection{Context Well-formedness}

\begin{mathpar}
  \Infer{Ctx0}
        { }
        { \judgectx{}{\cdot}}

        \and
 \Infer{CtxIT}
       { \judgectx{ }{\Gamma} }
       { \judgectx{ }{\Gamma,\isvtype{x}}}

       \and
 \Infer{CtxI}
       { \judgevtype{\Gamma}{A} \\
         \judgectx{ }{\Gamma} }
       { \judgectx{ }{\Gamma,x:A}}
\end{mathpar}

\subsection{Context Formation and Var}
Here $J$ means context judgement: either $(x : A)$ or $(\isvtype{x})$.

\begin{mathpar}

\Infer{CtxExt}
      { \judgeInctx{J}{\Gamma} }
      { \judgeInctx{J}{(\Gamma, y:B)} }
\and

\Infer{CtxExtT}
      { \judgeInctx{J}{\Gamma} }
      { \judgeInctx{J}{(\Gamma, \isvtype{B})} }
\and

\Infer{CtxInit}
      {  }
      { \judgeInctx{J}{(\Gamma, J)} }
\and

\Infer{Var}
      { \judgeInctx{x:A}{\Gamma} }
      { \judgevInfer{\Gamma, x:A}{x}{A} }
\and

\Infer{VarT}
      { \judgeInctx{\isvtype{x}}{\Gamma} }
      { \judgevtype{\Gamma}{x} }
\and

\end{mathpar}
\subsection{Equivalence}

\begin{mathpar}
  
  \Infer{EqivC}
        { \judgecInfer{\Gamma}{t}{Y} \\
          X \equiv Y \\
          }
        { \judgecCheck{\Gamma}{t}{X} }
  \and

  \Infer{EqivV}
        { \judgevInfer{\Gamma}{v}{B} \\
          A \equiv B \\
        }
        { \judgevCheck{\Gamma}{v}{A} }
  \and

\end{mathpar}

\subsection{Universes}
\label{sec:rules:universes}

\begin{mathpar}
  \Infer{$\vtoc$}
        { \judgevtype{\Gamma}{A} }
        { \judgectype{\Gamma}{\valtocomp{A}} }
        \and

  \Infer{$\ctov$}
        { \judgectype{\Gamma}{X} }
        { \judgevtype{\Gamma}{\comptoval{X}} }
  \and

  \Infer{$\Pi$}
        { \judgevtype{\Gamma}     {A} \\
          \judgectype{\Gamma, x:A}{X} }
        { \judgectype{\Gamma}{\pitype{x:A}{X}} }
  \and

  \Infer{$\forall$}
        { \judgevtype{\Gamma}     {A} \\
          \judgectype{\Gamma, x:A}{X} }
        { \judgectype{\Gamma}{\foralltype{x:A}{X}} }
        \and

  \Infer{$\Sigma$}
        { \judgevtype{\Gamma}     {A} \\
          \judgevtype{\Gamma, x:A}{B} }
        { \judgectype{\Gamma}{\sigmatype{x:A}{B}} }
  \and
  

  \Infer{$\mathsf{eq}$}
        { \judgevtype{\Gamma}{A} \\
          \judgevCheck{\Gamma}{v}{A} \\
          \judgevCheck{\Gamma}{w}{A} }
        { \judgevtype{\Gamma}{\eqtype{A}{v}{w}} }
  \and

  \Infer{Let-type}
        { \judgectype{\Gamma, x:A}{X} \\
          \judgecCheck{\Gamma}{e}{A} }
        { \judgectype{\Gamma}{(\letval{x:A}{e}{X})} }
  \and

\end{mathpar}

\subsection{$\vtoc$ and $\ctov$}
\begin{mathpar}

  \Infer{$\ctov$I$\checks$}
        { \judgecCheck{\Gamma}{t}{X} }
        { \judgevCheck{\Gamma}{\thunk{t}}{\comptoval{X}}}

  \and
  \Infer{$\ctov$I$\infers$}
        { \judgecInfer{\Gamma}{t}{X} }
        { \judgevInfer{\Gamma}{\thunk{t}}{\comptoval{X}}}

  \and

  \Infer{$\ctov$E$\checks$}
        { \judgevCheck{\Gamma}{v}{\comptoval{X}} }
        { \judgecCheck{\Gamma}{\force{v}}{X}}

  \and
  \Infer{$\vtoc$E$\infers$}
        { \judgevInfer{\Gamma}{v}{\comptoval{X}} }
        { \judgecInfer{\Gamma}{\force{v}}{X}}
  \and


  \Infer{$\vtoc$I$\checks$}
        { \judgevCheck{\Gamma}{v}{A} }
        { \judgecCheck{\Gamma}{\return{v}}{\valtocomp{A}}}
  \and

  \Infer{$\vtoc$I$\infers$}
        { \judgevInfer{\Gamma}{v}{A} }
        { \judgecInfer{\Gamma}{\return{v}}{\valtocomp{A}}}
  \and
\end{mathpar}

\subsection{Let and Dependent Let}

\begin{mathpar}

  \Infer{Let$\infers$}
        {
          \judgecInfer{\Gamma, x : A}{u}{X} \\
          \judgecCheck{\Gamma}{t}{\valtocomp{A}} \\
          \judgectype{\Gamma}{X} \\ 
          \judgevtype{\Gamma}{A} \\ 
        }
        { \judgecInfer{\Gamma}{\letval{x : A}{t}{u}}{X} }
  \and
  \Infer{Let$\checks$}
        { \judgecCheck{\Gamma}{t}{\valtocomp{A}} \\ 
          \judgectype{\Gamma}{X} \\ 
          \judgecCheck{\Gamma, x : A}{u}{X}}
        { \judgecCheck{\Gamma}{\letval{x : A}{t}{u}}{X} }
  \and

  \Infer{DLet$\infers$}
        {
          \judgecInfer{\Gamma, x:A}{u}{X} \\
          \judgecCheck{\Gamma}{t}{\valtocomp{A}} \\
          \judgectype{\Gamma, x:A}{X} \\ 
        }
        { \judgecInfer{\Gamma}{\dletval{x:A}{t}{u}}{(\letval{x:A}{t}{X})} }
  \and
  \Infer{DLet$\checks$}
        { \judgecCheck{\Gamma}{t}{\valtocomp{A}} \\ 
          \judgectype{\Gamma, x:A}{X} \\ 
          \judgecCheck{\Gamma, x:A}{u}{X}}
        { \judgecCheck{\Gamma}{\dletval{x:A}{t}{u}}{(\letval{x:A}{t}{X})} }
  \and

\end{mathpar}

\subsection{$\forall$, $\Pi$, and $\Sigma$}

\begin{mathpar}

  %% \Infer{$\Pi$I$\infers$}
  %%       { \judgecCheck{\Gamma, x:A}{X}{\unicomp} \\
  %%         \judgecInfer{\Gamma, x:A}{t}{X} }
  %%       { \judgecInfer{\Gamma}{\fun{x:A}{t}}{\pitype{x:A}{X}} }
  %% \and

  \Infer{$\forall$I$\checks$}
        { \judgectype{\Gamma, x:A}{X} \\
          \judgecCheck{\Gamma, x:A}{t}{X} }
        { \judgecCheck{\Gamma}{\fun{x:A}{t}}{\foralltype{x:A}{X}} }
  \and

  \Infer{$\Pi$I$\checks$}
        { \judgectype{\Gamma, x:A}{X} \\
          \judgecCheck{\Gamma, x:A}{t}{X} }
        { \judgecCheck{\Gamma}{\fun{x:A}{t}}{\pitype{x:A}{X}} }
  \and

  \Infer{$\Pi$E}
        { \judgecInfer{\Gamma}{t}{\pitype{x:A}{X}} \\
          \judgevCheck{\Gamma}{v}{A} }
        { \judgecInfer{\Gamma}{t\,v}{\subst{X}{x}{v}} }
  \and

  %% \Infer{$\Sigma$I$\infers$}
  %%       { \judgevInfer{\Gamma}{v}{A} \\
  %%         \judgevInfer{\Gamma}{w}{B} \\
  %%         \judgevCheck{\Gamma}{A}{\unival} \\
  %%         \judgevCheck{\Gamma}{B}{\unival} }
  %%       { \judgevInfer{\Gamma}{\pair{v}{w}}{A \times B}}
  %% \and

  \Infer{$\Sigma$I$\checks$}
        { \judgevCheck{\Gamma}{v}{A} \\
          \judgevCheck{\Gamma}{w}{\subst{B}{x}{v}} \\
          \judgevtype{\Gamma}{\sigmatype{x:A}{B}} }
        { \judgevCheck{\Gamma}{\pair{v}{w}}{\sigmatype{x:A}{B}} }
   \and


  \Infer{$\Sigma$E}
        {
          \judgectype{\Gamma, p : (\sigmatype{x:A}{B})}{X} \\
          \judgevCheck{\Gamma}{v}{\sigmatype{x:A}{B}} \\
          \judgecCheck{\Gamma}{t}{\pitype{(x:A)(y:B)}{\subst{X}{p}{\pair{x}{y}}}}}
        { \judgecInfer{\Gamma}{\recsigma{v}{X}{t}}{\subst{X}{p}{v}}}
  \and

\end{mathpar}

\subsection{Equality}

\begin{mathpar}

  \Infer{$\mathsf{eq}$I}
        { \judgevtype{\Gamma}{A} \\
          \judgevCheck{\Gamma}{v}{A}}
        { \judgevCheck{\Gamma}{\refl}{\eqtype{A}{v}{v}} }

  \and


  \Infer{$\mathsf{eq}$E$\checks$}
        { \judgevCheck{\Gamma}{v}{\eqtype{A}{w_1}{w_2}} \\
          \judgectype{\Gamma, x:A, p:\eqtype{A}{w_1}{x}}{X} \\
          \judgecCheck{\Gamma}{t}{X\,w_1\,\refl} }
        { \judgecCheck{\Gamma}{\receq{v}{X}{t}}{\subst{\subst{X}{x}{w_2}}{p}{v}}}

\end{mathpar}

\section{Equality}

\label{sec:equality}

\begin{definition}[Reduction]
Reduction is a minimal congruent
relation $R$ on terms (we write $\reduces{v}{v'}$ meaning $(v,v') \in R$), such that

\begin{multicols}{2}
\begin{itemize}
  \item $\reduces{(\fun{x:A}{t})v}{\subst{t}{x}{v}}$

  \item $\reduces{\letval{x:A}{\return{v}}{t}}{\subst{t}{x}{v}}$

  \item $\reduces{\dletval{x:A}{\return{v}}{t}}{\subst{t}{x}{v}}$

  \item $\reduces{\force{\thunk{t}}}{t}$

  \item $\reduces{\recsigma{\pair{u}{w}}{X}{u}}{u v w}$

  \item $\reduces{\receq{\refl}{X}{u}}{u}$

\end{itemize}

\end{multicols}
\end{definition}

We treat existential variables $\hat{v}$ as non-reducible values.

\begin{definition}[Equivalence]

\begin{mathpar}
  \Infer{}
        {
          \reduces{e_1}{e_1'}\\
          \judgeaequiv{\varphi}{e_1'}{e_2}{A}{\varphi'}
        }
        {
          \judgeaequiv{\varphi}{e_1}{e_2}{A}{\varphi'}
        }
  \and
  \Infer{}
        {
          \reduces{e_2}{e_2'}\\
          \judgeaequiv{\varphi}{e_1}{e_2'}{A}{\varphi'}
        }
        {
          \judgeaequiv{\varphi}{e_1}{e_2}{A}{\varphi'}
        }
   \and
   \Infer{}
        {
          \reduces{A}{A'}\\
          \judgeaequiv{\varphi}{e_1}{e_2}{A'}{\varphi'}
        }
        {
          \judgeaequiv{\varphi}{e_1}{e_2}{A}{\varphi'}
        }

   \and
   \Infer{}
         { }
         {
           \judgeaequiv{\varphi}{e}{e}{A}{\varphi}
         }
   \and
   \Infer{}
         { }
         {
           \judgeaequiv{\varphi}{v}{\hat{v}}{A}{\varphi, \evarassign{\hat{v}}{v}}
         }
   \and

\end{mathpar}

\end{definition}

\section{Declarative Subtyping}

\begin{mathpar}

  \Infer{$\subt \Sigma$}
        {
          \judgevsubt{\Gamma}{A_1}{B_1}\\
          \judgevsubt{\Gamma, x:A_1}{A_2}{B_2}\\
        }
        {\judgevsubt{\Gamma}{\sigmatype{x:A_1}{A_2}}{\sigmatype{x:B_1}{B_2}}}

 \Infer{$\subt \Pi$}
       {
         \judgevsubt{\Gamma}{A_2}{A_1}\\
         \judgecsubt{\Gamma, x:A_2}{X_1}{X_2}\\
       }
       {\judgecsubt{\Gamma}{\pitype{x:A_1}{X_1}}{\pitype{x:A_2}{X_2}}}

  \Infer{$\subt \ctov$}
        {
          \judgecsubt{\Gamma}{X_1}{X_2} \\
          \judgecsubt{\Gamma}{X_2}{X_1} \\
        }
        {\judgevsubt{\Gamma}{\comptoval{X_1}}{\comptoval{X_2}}}

  \Infer{$\subt \vtoc$}
        {
          \judgevsubt{\Gamma}{A_1}{A_2} \\
          \judgevsubt{\Gamma}{A_2}{A_1} \\
        }
        {\judgecsubt{\Gamma}{\valtocomp{A_1}}{\valtocomp{A_2}}}

  \Infer{$\subt$Eq}
        {
          \judgevsubt{\Gamma}{A}{B} \\
          \judgeequiv{\Gamma}{v_1}{v_2}{A} \\
          \judgeequiv{\Gamma}{w_1}{w_2}{A} \\
        }
        {\judgevsubt{\Gamma}{\eqtype{A}{v_1}{w_1}}{\eqtype{B}{v_2}{w_2}}}
      
  \Infer{$\forall \subt$}
        {
          \judge{\Gamma}{v}{A}\\
          \judgecsubt{\Gamma}{\subst{X}{x}{v}}{Y}\\
          \text{for any } v' \text{with the same properties, }
          \judgeequiv{\Gamma}{v}{v'}{A}
        }
        {\judgecsubt{\Gamma}{(\foralltype{x:A}{X})}{Y}}
        
  \Infer{$\subt \forall$}
        {
          \judgecsubt{\Gamma, y : A}{X}{Y}\\
        }
        {\judgecsubt{\Gamma}{X}{(\foralltype{y:A}{Y})}}

  \Infer{let$\subt$}
        {
          \judgeequiv{\Gamma}{e}{\return{v}}{A}\\
          \judgecsubt{\Gamma}{\subst{X}{x}{v}}{Y}\\
        }
        { \judgecsubt{\Gamma}{(\letval{x:A}{e}{X})}{Y}}

        
  \Infer{$\subt$let}
        {
          \judgeequiv{\Gamma}{e}{\return{v}}{A}\\
          \judgecsubt{\Gamma}{X}{\subst{Y}{y}{v}}\\
        }
        { \judgecsubt{\Gamma}{X}{(\letval{y:A}{e}{Y})}}

  \Infer{let$\subt$let}
        {
          \judgevsubt{\Gamma}{A}{B}\\
          \judgevsubt{\Gamma}{B}{A}\\
          \judgeequiv{\Gamma}{e_1}{e_2}{A}\\
          \judgecsubt{\Gamma, x:A}{X}{Y}\\
         }
        {
          \judgecsubt{\Gamma}{\letval{x:A}{e_1}{X}}{\letval{x:B}{e_2}{Y}}
        }


\end{mathpar}


\section{Algorithmic Subtyping}

\begin{mathpar}

  \Infer{$\subt \Sigma$}
        {
          \judgeavsubt{\varphi}{A_1}{B_1}{\varphi'}\\
          \judgeavsubt{\varphi', x:A_1}{A_2}{B_2}{\varphi''}\\
        }
        {\judgeavsubt{\varphi}{\sigmatype{x:A_1}{A_2}}{\sigmatype{x:B_1}{B_2}}{\varphi''}}

  \Infer{$\subt \Pi$}
        {
          \judgeavsubt{\varphi}{A_2}{A_1}{\varphi'}\\
          \judgeacsubt{\varphi', x:A_2}{\ctxtapp{\varphi'}{X_1}}{X_2}{\varphi''}\\
        }
        {\judgeacsubt{\varphi}{\pitype{x:A_1}{X_1}}{\pitype{x:A_2}{X_2}}{\varphi''}}

  \Infer{$\subt \ctov$}
        {
          \judgeacsubt{\varphi}{X_2}{X_1}{\varphi'} \\
          \judgeacsubt{\varphi'}{X_1}{\ctxtapp{\varphi'}{X_2}}{\varphi''} \\
        }
        {\judgeavsubt{\varphi}{\comptoval{X_1}}{\comptoval{X_2}}{\varphi''}}

  \Infer{$\subt \vtoc$}
        {
          \judgeavsubt{\varphi}{A_2}{A_1}{\varphi'} \\
          \judgeavsubt{\varphi'}{\ctxtapp{\varphi'}{A_1}}{A_2}{\varphi''} \\
        }
        {\judgeacsubt{\varphi}{\valtocomp{A_1}}{\valtocomp{A_2}}{\varphi''}}
  
  \Infer{$\subt$Eq}
        {
          \judgeavsubt{\varphi}{A}{B}{\varphi'} \\
          \judgeaequiv{\varphi'}{v_1}{\ctxtapp{\varphi'}{v_2}}{A}{\varphi''} \\
          \judgeaequiv{\varphi''}{w_1}{\ctxtapp{\varphi''}{w_2}}{A}{\varphi'''} \\
        }
        {\judgevsubt{\Gamma}{\eqtype{A}{v_1}{w_1}}{\eqtype{B}{v_2}{w_2}}}

   \Infer{$\forall \subt$}
         {
           \judgeacsubt{\varphi,\hat{v}}
                       {\subst{X}{x}{\hat{v}}}
                       {Y}
                       {\varphi'}
         }
         {\judgeacsubt{\varphi}{(\foralltype{x:A}{X})}{Y}{\varphi'}}

   \Infer{$\subt \forall$}
         {
           \judgeacsubt{\varphi, y : A}{X}{Y}{\varphi'}\\
         }
         {\judgeacsubt{\varphi}{X}{(\foralltype{y:A}{Y})}{\varphi'}}

   \Infer{let$\subt$}
         {
           e \text{ is ground}\\
           \judgeaequiv{\varphi, \hat{v}}
                       {e}
                       {\return{\hat{v}}}
                       {A}
                       {\varphi', \evarassign{\hat{v}}{v}}\\
           \judgeacsubt{\varphi'}
                       {\subst{\ctxtapp{\varphi'}{X}}{x}{v}}{Y}{\varphi', \evarassign{\hat{v}}{v}}\\
         }
         { \judgeacsubt{\varphi}{(\letval{x:A}{e}{X})}{Y}{\varphi''}}

   \Infer{$\subt$let}
         {
           \judgeaequiv{\varphi, \hat{v}}
                       {e}
                       {\return{\hat{v}}}
                       {A}
                       {\varphi', \evarassign{\hat{v}}{v}}\\
           \judgeacsubt{\varphi'}
                       {\ctxtapp{\varphi'}{X}}
                       {\subst{Y}{y}{v}}
                       {\varphi''}\\
         }
         { \judgeacsubt{\varphi}{X}{(\letval{y:A}{e}{Y})}{\varphi''} }

   \Infer{let$\subt$let}
         {
           \judgeavsubt{\varphi}{B}{A}{\varphi_1}\\
           \judgeavsubt{\varphi_1}{\ctxtapp{\varphi_1}{A}}{B}{\varphi_2}\\
           \judgeaequiv{\varphi_2}{\ctxtapp{\varphi_1}{e_2}}{e_1}{\ctxtapp{\varphi_1}{A}}{\varphi_3}\\
           \judgeacsubt{\varphi_3, x:{\ctxtapp{\varphi_1}{A}}}{\ctxtapp{\varphi_3}{X}}{Y}{\varphi_4}\\
         }
         {
           \judgeacsubt{\varphi}{\letval{x:A}{e_1}{X}}{\letval{x:B}{e_2}{Y}}{\varphi_4}
         }

\end{mathpar}


\ilyam{In (let$\subt$), type $A$ can have unresolved variables, hence, the first
  unification in the premises can instantiate them, and thus, must be
  algorithmic.}

\ilyam{In (let$\subt$), we require $e$ to be ground, which makes the algorithmic
  system incomplete w.r.t. the declarative system.\\
  E.g. $(\foralltype{x:1}{\letval{y:1}{\return{x}}{\valtocomp{\eqtype{\comptoval{\valtocomp{1}}}{\thunk{y}}{\thunk{y}}}}}) \leqslant \eqtype{\comptoval{\valtocomp{1}}}{\thunk{\return{()}}}{\thunk{\return{()}}}$
  holds for the declarative system but not for the algorithmic.}

\subsection{Natural Numbers and Undecidability}

The type system can be easily extended with natural numbers. To this purpose, we
must add $\nattype$, $\natzero$, and $\natsucc{v}$ to the values, and
$\recnat{v}{X}{base}{step}$ to the computations with obvious typing inference
rules.
We also add $\reduces{\recnat{\natzero}{X}{b}{s}}{b}$ and
$\reduces{\recnat{\natsucc{v}}{X}{b}{s}}{s \, v \, \recnat{v}{X}{b}{s}}$ to the reduction rules.

Notice that we do not unify under the induction operators. For example,
$\judgeaequiv{\varphi}{\recnat{\hat{v}}{X}{\natzero}{\fun{x\,y}{\natzero}}}{\natzero}{\nattype}{\varphi, \evarassign{\hat{v}}{\natzero}}$
is not admissible.
Moreover, the general unification is undecidable in this case.

Roughly, this is because we can easily define integers,
arithmetic operations, and hence, any arbitrary polynomial
$P(\hat{x_1}, \dots, \hat{x_n})$.
The unification of this polynomial with $\natzero$
corresponds to solving a diophantine equation, which is undecidable.

\subsection{Invariants}

We should be able to infer
$\judgeacsubt{\varphi}{(\letval{x:\valtocomp{\eqtype{A}{\hat{u}}{\hat{v}}}}{\hat{w}}{\valtocomp{Int}})}{\valtocomp{Int}}{\varphi}$.
As you can see, the unused existential variables $\hat{u}$ and $\hat{v}$ stay uninitialized.
It breaks the invariant that the subtyping algorithm `makes' both sides of $\leqslant$ ground (i.e. all existential variables are initialized in the output context).
As such, we weaken the notion of `ground` terms in such a way that they might have existential variables as long as they are not used in the outcome.

\ilyam{I've just realized that what I would like to mean by the usage of the variables depends on the evaluation. So maybe it's worth trying another approach,
  e.g. instantiate existential variables with `?' and promise that it won't cause any problem in the unification. }


\section{Properties}
\ilyam{Outdated}

%% \subsection{Mode-correctness}
%% \subsection{Regularity}

\begin{lemma}[Mode-correctness]
  Each rule in \cref{sec:rules} is mode-correct. Specifically, as defined in \cite{dunfield2021:bidirectional},
  \begin{enumerate}
    \item The premises are mode-correct: for each premise, every input meta-variable is known from the input of the rule's conclusion and the outputs of the earlier premises.
    \item The conclusion is mode-correct: if all premises have been derived, the outputs of the conclusion are known.
  \end{enumerate}
\end{lemma}
\begin{proof}
  First, we prove the mode-correctness of \emph{conclusion} for each rule.
  Note that it is only relevant for the \emph{synthesizing} rules, because for the \emph{checking} rules, the resulting type is given as an input.

  \begin{multicols}{2}
  \begin{itemize}
  \item[(Var)]
    $A$ is known from the input of the conclusion.
  \item[(Universes)]
    For rules in \cref{sec:rules:universes} ($\ctov$, $\vtoc$, $\Pi$,
    $\Sigma$, $\mathsf{eq}$), the resulting type (a universe) is the only
    possible option.

  \item[($\ctov$I$\infers$)]
    $X$ is known from the output of $\judgecInfer{\Gamma}{t}{X}$.

  \item[($\vtoc$E$\infers$)]
    $X$ is known from the output of $\judgevInfer{\Gamma}{v}{\comptoval{X}}$.

  \item[($\vtoc$I$\infers$)]
    $A$ is known from the output of $\judgevInfer{\Gamma}{v}{\comptoval{X}}$.

  \item[(Let$\infers$)]
    $X$ is known from the output of $\judgecInfer{\Gamma, x : A}{u}{X}$.

  \item[(DLet$\infers$)]
    $x$, $A$, and $t$ are given in the input of the conclusion; $X$ is known
    from the output of $\judgecInfer{\Gamma, x:A}{u}{X}$.

  \item[($\Pi$E)]
    $v$ is given in the input of the conclusion; $x$ and $X$ are known from the
    output of $\judgecInfer{\Gamma}{t}{\pitype{x:A}{X}}$.

  \item[($\Sigma$E)]
    $X$ and $v$ are given in the input of the conclusion.

  \item[($\mathsf{eq}$E$\infers$)]
    $X$ and $v$ are given in the input of the conclusion;
    $w_2$ is known from the output of $\judgevInfer{\Gamma}{v}{\eqtype{A}{w_1}{w_2}}$.
  \end{itemize}
  \end{multicols}

  Second, we let us show the mode-correctness of \emph{premises}.
  
  \newcommand{\fromconcl}{given in the input of the conclusion}

  \begin{multicols}{2}
  \begin{itemize}
      \item[(Ctx0)]
        There are no premises.

      \item[(CtxI)]
        $\Gamma$ and $A$ are \fromconcl.

      \item[(CtxExt)]
        $X$, $A$, and $\Gamma$ are \fromconcl.

      \item[(CtxInit)]
        There are no premises. 

      \item[(Var)]
        $x$, $A$, and $\Gamma$ are \fromconcl.

      \item[(EqivC)]
        $\Gamma$, $t$, and $X$ are \fromconcl;
        $Y$ is known from the output of $\judgecInfer{\Gamma}{t}{Y}$.

      \item[(EqivV)]
        $\Gamma$, $v$, and $A$ are \fromconcl;
        $B$ is known from the output of $\judgevInfer{\Gamma}{v}{B}$.

      \item[($\vtoc$)]
        $\Gamma$ and $A$ are \fromconcl.

      \item[($\ctov$)]
        $\Gamma$ and $X$ are \fromconcl.

      \item[($\Pi$)]
        $\Gamma$, $A$, $x$, and $X$ are \fromconcl.

      \item[($\Sigma$)]
        $\Gamma$, $A$, $x$, and $B$ are \fromconcl.

      \item[($\mathsf{eq}$)]
        $\Gamma$, $A$, $v$, and $w$ are \fromconcl.

      \item[($\unival$ and $\unicomp$)]
        There are no premises.

      \item[($\ctov$I$\checks$)]
        $\Gamma$, $t$, and $X$ are \fromconcl.

      \item[($\ctov$I$\infers$)]
        $\Gamma$ and $t$ are \fromconcl.

      \item[($\ctov$E$\checks$)]
        $\Gamma$, $v$, and $X$ are \fromconcl.

      \item[($\vtoc$E$\infers$)]
        $\Gamma$ and $v$ are \fromconcl.

      \item[($\vtoc$I$\checks$)]
        $\Gamma$, $v$, and $A$ are \fromconcl.

      \item[($\vtoc$I$\infers$)]
        $\Gamma$ and $v$ are \fromconcl.

      \item[(Let$\infers$)]
        $\Gamma$, $x$, $A$, $u$, and $t$ are \fromconcl;
        $X$ is known from the output of $\judgecInfer{\Gamma, x : A}{u}{X}$.
        
      \item[(Let$\checks$)]
        $\Gamma$, $t$, $A$, $X$, $x$, and $u$ are \fromconcl.

      \item[(DLet$\infers$)]
        $\Gamma$, $x$, $A$, $u$, and $t$ are \fromconcl.
        $X$ is known from the output of $\judgecInfer{\Gamma, x:A}{u}{X}$.

      \item[(DLet$\checks$)]
        $\Gamma$, $t$, $A$, $x$, $X$, and $u$ are \fromconcl.

      \item[($\Pi$I$\checks$)]
        $\Gamma$, $x$, $A$, $X$, and $t$ are \fromconcl.

      \item[($\Pi$E)]
        $\Gamma$, $t$, and $v$ are \fromconcl;
        $A$ is known from the output of $\judgecInfer{\Gamma}{t}{\pitype{x:A}{X}}$

      \item[($\Sigma$I$\checks$)]
        $\Gamma$, $v$, $A$, $w$, $B$, $x$ are \fromconcl.

      \item[($\Sigma$E)]
        $\Gamma$, $X$, and $v$, are \fromconcl;
        $x$, $A$, and $B$ are known from the output of
        $\judgecInfer{\Gamma}{X}{\sigmatype{x:A}{B} \to \unicomp}$;
        $y$ is an arbitrary fresh variable.
        
      \item[($\mathsf{eq}$I)]
        $\Gamma$, $A$, and $v$ are \fromconcl.

      \item[($\mathsf{eq}$E$\infers$)]
        $\Gamma$, $v$, $X$, and $t$ are \fromconcl;
        $A$ and $w_1$ are known from the output of $\judgevInfer{\Gamma}{v}{\eqtype{A}{w_1}{w_2}}$.
  \end{itemize}
  \end{multicols}


\end{proof}

\begin{lemma}[Context Soundness]
  \label{lemma:ctx-soundness}
  If $\judgeInctx{x:A}{\Gamma}$ and $\judgectx{}{\Gamma}$ then $\judgevCheck{\Gamma}{A}{\unival}$
\end{lemma}
\begin{proof}
  \ilyam{By trivial induction on $\judgeInctx{x:A}{\Gamma}$}
\end{proof}

\begin{lemma}[Regularity]
  The types synthesized by $\infers$ are well-formed. Specifically, the following properties hold
  \begin{enumerate}
  \item if $\judgectx{}{\Gamma}$ and $\judgevInfer{\Gamma}{v}{A}$ then $\judgevCheck{\Gamma}{A}{\unival}$
  \item if $\judgectx{}{\Gamma}$ and $\judgecInfer{\Gamma}{t}{X}$ then $\judgevCheck{\Gamma}{X}{\unicomp}$
  \end{enumerate}
\end{lemma}

\begin{proof}
  We prove this property by mutual structural induction on
  $\judgevInfer{\Gamma}{v}{A}$ and 
  $\judgecInfer{\Gamma}{t}{X}$.
  Let us consider the synthesizing rules.
  \begin{itemize}
  \item[(Var)]
    Since $(x : A)$ belongs to a \emph{well-formed} context $\Gamma$, 
    the property we need
    ($\judgevCheck{\Gamma}{A}{\unival}$) holds by \cref{lemma:ctx-soundness}.
  \item[(Universes)]
    Each rule in \cref{sec:rules:universes} synthesizes either $\unival$ or $\unicomp$.
    The desired properties hold by the following derivation trees:
    \begin{mathpar}
      \Infer{EqivV}
            {\Infer{$\unival$}
                    { }
                    { \judgevInfer{\Gamma}{\unival}{\unival} }\\
              \unival \equiv \unival \\
            }
            { \judgevCheck{\Gamma}{\unival}{\unival} }
      \and
      \Infer{EqivC}
            {\Infer{$\unicomp$}
              { }
              { \judgecInfer{\Gamma}{\unicomp}{\unicomp} }\\
              \unicomp \equiv \unicomp \\
            }
            { \judgecCheck{\Gamma}{\unicomp}{\unicomp} }

     \end{mathpar}
  \item[($\ctov$I$\infers$ and $\vtoc$I$\infers$)]
    The following derivation trees prove the required properties,
    where $\dag$ and $\ddag$ are derived from the inductive hypotheses.
    \begin{mathpar}
      \Infer{EqivC}
            {\Infer{$\ctov$}
              { \Infer{}{\dag}{\judgecCheck{\Gamma}{X}{\unicomp}} }
              { \judgevInfer{\Gamma}{\comptoval{X}}{\unival} } \\
              \comptoval{X} \equiv \comptoval{X} \\
            }
            { \judgevCheck{\Gamma}{\comptoval{X}}{\unival} }
      \and

      \Infer{EqivV}
            {\Infer{$\vtoc$}
              { \Infer{}{\ddag}{\judgevCheck{\Gamma}{A}{\unival}} }
              { \judgecInfer{\Gamma}{\valtocomp{A}}{\unicomp} } \\
              \valtocomp{A} \equiv \valtocomp{A} \\
            }
            { \judgecCheck{\Gamma}{\valtocomp{A}}{\unicomp} }

    \end{mathpar}
     
  \item[($\vtoc$E$\infers$)]
    \ilyam{Depends on $\unival \equiv \cdot$ }
  \item[(Let$\infers$)]
    The desired property is in the premises.
  \item[(DLet$\infers$)]
    The following derivation tree proves the required property.
    $\judgecCheck{\Gamma}{t}{\valtocomp{A}}$ and 
    $\judgecInfer{\Gamma, x : A}{u}{\unicomp}$ are given as premises.
  \begin{mathpar}
    \Infer{Let$\checks$}
          { \judgecCheck{\Gamma}{t}{\valtocomp{A}} \\ 
            \Infer{ }{\Infer{$\unicomp$}{ }{\judgecInfer{\Gamma}{\unicomp}{\unicomp}}}
                     {\judgecCheck{\Gamma}{\unicomp}{\unicomp}} \\ 
            \Infer{ }{\judgecInfer{\Gamma, x : A}{u}{\unicomp}}
                     {\judgecCheck{\Gamma, x : A}{u}{\unicomp}}}
          { \judgecCheck{\Gamma}{\letval{x : A}{t}{u}}{\unicomp} }
          \and
  \end{mathpar}

\item[($\Pi$E)]
  \ilyam{Depends on $\equiv$ and requires the substitution lemma}
\item[($\Sigma$E)]
  By applying ($\Pi$E) to the first two premises. 

\item[($\mathsf{eq}$E$\infers$)]
  \ilyam{The same trick as in ($\Sigma$E) doesn't work...}

\end{itemize}


\end{proof}

\printbibliography

\end{document}
